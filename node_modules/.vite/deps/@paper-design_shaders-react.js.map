{
  "version": 3,
  "sources": ["../../@paper-design/shaders-react/src/shader-mount.tsx", "../../@paper-design/shaders/src/vertex-shader.ts", "../../@paper-design/shaders/src/shader-mount.ts", "../../@paper-design/shaders/src/shader-sizing.ts", "../../@paper-design/shaders/src/shader-utils.ts", "../../@paper-design/shaders/src/shaders/mesh-gradient.ts", "../../@paper-design/shaders/src/shaders/smoke-ring.ts", "../../@paper-design/shaders/src/shaders/neuro-noise.ts", "../../@paper-design/shaders/src/shaders/dot-orbit.ts", "../../@paper-design/shaders/src/shaders/dot-grid.ts", "../../@paper-design/shaders/src/shaders/simplex-noise.ts", "../../@paper-design/shaders/src/shaders/metaballs.ts", "../../@paper-design/shaders/src/shaders/perlin-noise.ts", "../../@paper-design/shaders/src/shaders/voronoi.ts", "../../@paper-design/shaders/src/shaders/waves.ts", "../../@paper-design/shaders/src/shaders/warp.ts", "../../@paper-design/shaders/src/shaders/god-rays.ts", "../../@paper-design/shaders/src/shaders/spiral.ts", "../../@paper-design/shaders/src/shaders/swirl.ts", "../../@paper-design/shaders/src/shaders/dithering.ts", "../../@paper-design/shaders/src/shaders/grain-gradient.ts", "../../@paper-design/shaders/src/shaders/pulsing-border.ts", "../../@paper-design/shaders/src/shaders/color-panels.ts", "../../@paper-design/shaders/src/shaders/static-mesh-gradient.ts", "../../@paper-design/shaders/src/shaders/static-radial-gradient.ts", "../../@paper-design/shaders/src/shaders/paper-texture.ts", "../../@paper-design/shaders/src/shaders/water.ts", "../../@paper-design/shaders/src/shaders/fluted-glass.ts", "../../@paper-design/shaders/src/shaders/image-dithering.ts", "../../@paper-design/shaders/src/shaders/heatmap.ts", "../../@paper-design/shaders/src/shaders/liquid-metal.ts", "../../@paper-design/shaders/src/shaders/halftone-dots.ts", "../../@paper-design/shaders/src/shaders/halftone-cmyk.ts", "../../@paper-design/shaders/src/get-shader-color-from-string.ts", "../../@paper-design/shaders/src/get-shader-noise-texture.ts", "../../@paper-design/shaders/src/get-empty-pixel.ts", "../../@paper-design/shaders-react/src/use-merge-refs.ts", "../../@paper-design/shaders-react/src/set-min-image-size.tsx", "../../@paper-design/shaders-react/src/shaders/mesh-gradient.tsx", "../../@paper-design/shaders-react/src/color-props-are-equal.ts", "../../@paper-design/shaders-react/src/shaders/smoke-ring.tsx", "../../@paper-design/shaders-react/src/shaders/neuro-noise.tsx", "../../@paper-design/shaders-react/src/shaders/dot-orbit.tsx", "../../@paper-design/shaders-react/src/shaders/dot-grid.tsx", "../../@paper-design/shaders-react/src/shaders/simplex-noise.tsx", "../../@paper-design/shaders-react/src/shaders/metaballs.tsx", "../../@paper-design/shaders-react/src/shaders/waves.tsx", "../../@paper-design/shaders-react/src/shaders/perlin-noise.tsx", "../../@paper-design/shaders-react/src/shaders/voronoi.tsx", "../../@paper-design/shaders-react/src/shaders/warp.tsx", "../../@paper-design/shaders-react/src/shaders/god-rays.tsx", "../../@paper-design/shaders-react/src/shaders/spiral.tsx", "../../@paper-design/shaders-react/src/shaders/swirl.tsx", "../../@paper-design/shaders-react/src/shaders/dithering.tsx", "../../@paper-design/shaders-react/src/shaders/grain-gradient.tsx", "../../@paper-design/shaders-react/src/shaders/pulsing-border.tsx", "../../@paper-design/shaders-react/src/shaders/color-panels.tsx", "../../@paper-design/shaders-react/src/shaders/static-mesh-gradient.tsx", "../../@paper-design/shaders-react/src/shaders/static-radial-gradient.tsx", "../../@paper-design/shaders-react/src/shaders/paper-texture.tsx", "../../@paper-design/shaders-react/src/shaders/fluted-glass.tsx", "../../@paper-design/shaders-react/src/shaders/water.tsx", "../../@paper-design/shaders-react/src/shaders/image-dithering.tsx", "../../@paper-design/shaders-react/src/shaders/heatmap.tsx", "../../@paper-design/shaders-react/src/transparent-pixel.ts", "../../@paper-design/shaders-react/src/suspend.tsx", "../../@paper-design/shaders-react/src/shaders/liquid-metal.tsx", "../../@paper-design/shaders-react/src/shaders/halftone-dots.tsx", "../../@paper-design/shaders-react/src/shaders/halftone-cmyk.tsx"],
  "sourcesContent": ["'use client';\n\nimport { useEffect, useRef, forwardRef, useState } from 'react';\nimport {\n  ShaderMount as ShaderMountVanilla,\n  getEmptyPixel,\n  type PaperShaderElement,\n  type ShaderMotionParams,\n  type ShaderMountUniforms,\n} from '@paper-design/shaders';\nimport { useMergeRefs } from './use-merge-refs.js';\nimport { setMinImageSize } from './set-min-image-size.js';\n\n/**\n * React Shader Mount can also accept strings as uniform values, which will assumed to be URLs and loaded as images\n *\n * We accept undefined as a convenience for server rendering, when some things may be undefined\n * We just skip setting the uniform if it's undefined. This allows the shader mount to still take up space during server rendering\n */\ninterface ShaderMountUniformsReact {\n  [key: string]: string | boolean | number | number[] | number[][] | HTMLImageElement | undefined;\n}\n\nexport interface ShaderMountProps extends Omit<React.ComponentProps<'div'>, 'color' | 'ref'>, ShaderMotionParams {\n  ref?: React.Ref<PaperShaderElement>;\n  fragmentShader: string;\n  uniforms: ShaderMountUniformsReact;\n  mipmaps?: string[];\n  minPixelRatio?: number;\n  maxPixelCount?: number;\n  webGlContextAttributes?: WebGLContextAttributes;\n\n  /** Inline CSS width style */\n  width?: string | number;\n  /** Inline CSS height style */\n  height?: string | number;\n}\n\nexport interface ShaderComponentProps extends Omit<React.ComponentProps<'div'>, 'color' | 'ref'> {\n  ref?: React.Ref<PaperShaderElement>;\n  minPixelRatio?: number;\n  maxPixelCount?: number;\n  webGlContextAttributes?: WebGLContextAttributes;\n\n  /** Inline CSS width style */\n  width?: string | number;\n  /** Inline CSS height style */\n  height?: string | number;\n}\n\n/** Parse the provided uniforms, turning URL strings into loaded images */\nasync function processUniforms(uniformsProp: ShaderMountUniformsReact): Promise<ShaderMountUniforms> {\n  const processedUniforms = {} as ShaderMountUniforms;\n  const imageLoadPromises: Promise<void>[] = [];\n\n  const isValidUrl = (url: string): boolean => {\n    try {\n      // Handle absolute paths\n      if (url.startsWith('/')) return true;\n      // Check if it's a valid URL\n      new URL(url);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n\n  const isExternalUrl = (url: string): boolean => {\n    try {\n      if (url.startsWith('/')) return false;\n      const urlObject = new URL(url, window.location.origin);\n      return urlObject.origin !== window.location.origin;\n    } catch {\n      return false;\n    }\n  };\n\n  Object.entries(uniformsProp).forEach(([key, value]) => {\n    if (typeof value === 'string') {\n      // Use a transparent pixel for empty strings\n      if (!value) {\n        processedUniforms[key] = getEmptyPixel();\n        return;\n      }\n\n      // Make sure the provided string is a valid URL or just skip trying to set this uniform entirely\n      if (!isValidUrl(value)) {\n        console.warn(`Uniform \"${key}\" has invalid URL \"${value}\". Skipping image loading.`);\n        return;\n      }\n\n      const imagePromise = new Promise<void>((resolve, reject) => {\n        const img = new Image();\n        if (isExternalUrl(value)) {\n          img.crossOrigin = 'anonymous';\n        }\n        img.onload = () => {\n          setMinImageSize(img);\n          processedUniforms[key] = img;\n          resolve();\n        };\n        img.onerror = () => {\n          console.error(`Could not set uniforms. Failed to load image at ${value}`);\n          reject();\n        };\n        img.src = value;\n      });\n\n      imageLoadPromises.push(imagePromise);\n    } else if (value instanceof HTMLImageElement) {\n      setMinImageSize(value);\n      processedUniforms[key] = value;\n    } else {\n      processedUniforms[key] = value;\n    }\n  });\n\n  await Promise.all(imageLoadPromises);\n  return processedUniforms;\n}\n\n/**\n * A React component that mounts a shader and updates its uniforms as the component's props change\n * If you pass a string as a uniform value, it will be assumed to be a URL and attempted to be loaded as an image\n */\nexport const ShaderMount: React.FC<ShaderMountProps> = forwardRef<PaperShaderElement, ShaderMountProps>(\n  function ShaderMountImpl(\n    {\n      fragmentShader,\n      uniforms: uniformsProp,\n      webGlContextAttributes,\n      speed = 0,\n      frame = 0,\n      width,\n      height,\n      minPixelRatio,\n      maxPixelCount,\n      mipmaps,\n      style,\n      ...divProps\n    },\n    forwardedRef\n  ) {\n    const [isInitialized, setIsInitialized] = useState(false);\n    const divRef = useRef<PaperShaderElement>(null);\n    const shaderMountRef: React.RefObject<ShaderMountVanilla | null> = useRef<ShaderMountVanilla>(null);\n    const webGlContextAttributesRef = useRef(webGlContextAttributes);\n\n    // Initialize the ShaderMountVanilla\n    useEffect(() => {\n      const initShader = async () => {\n        const uniforms = await processUniforms(uniformsProp);\n\n        if (divRef.current && !shaderMountRef.current) {\n          shaderMountRef.current = new ShaderMountVanilla(\n            divRef.current,\n            fragmentShader,\n            uniforms,\n            webGlContextAttributesRef.current,\n            speed,\n            frame,\n            minPixelRatio,\n            maxPixelCount,\n            mipmaps\n          );\n\n          setIsInitialized(true);\n        }\n      };\n\n      initShader();\n\n      return () => {\n        shaderMountRef.current?.dispose();\n        shaderMountRef.current = null;\n      };\n    }, [fragmentShader]);\n\n    // Uniforms\n    useEffect(() => {\n      let isStale = false;\n\n      const updateUniforms = async () => {\n        const uniforms = await processUniforms(uniformsProp);\n\n        if (!isStale) {\n          // We only use the freshest uniforms otherwise we can get into race conditions\n          // if some uniforms (images!) take longer to load in subsequent effect runs.\n          shaderMountRef.current?.setUniforms(uniforms);\n        }\n      };\n\n      updateUniforms();\n\n      return () => {\n        isStale = true;\n      };\n    }, [uniformsProp, isInitialized]);\n\n    // Speed\n    useEffect(() => {\n      shaderMountRef.current?.setSpeed(speed);\n    }, [speed, isInitialized]);\n\n    // Max Pixel Count\n    useEffect(() => {\n      shaderMountRef.current?.setMaxPixelCount(maxPixelCount);\n    }, [maxPixelCount, isInitialized]);\n\n    // Min Pixel Ratio\n    useEffect(() => {\n      shaderMountRef.current?.setMinPixelRatio(minPixelRatio);\n    }, [minPixelRatio, isInitialized]);\n\n    // Frame\n    useEffect(() => {\n      shaderMountRef.current?.setFrame(frame);\n    }, [frame, isInitialized]);\n\n    const mergedRef = useMergeRefs([divRef, forwardedRef]) as unknown as React.RefObject<HTMLDivElement>;\n    return (\n      <div\n        ref={mergedRef}\n        style={\n          width !== undefined || height !== undefined\n            ? {\n                width: typeof width === 'string' && isNaN(+width) === false ? +width : width,\n                height: typeof height === 'string' && isNaN(+height) === false ? +height : height,\n                ...style,\n              }\n            : style\n        }\n        {...divProps}\n      />\n    );\n  }\n);\n\nShaderMount.displayName = 'ShaderMount';\n", "/** Vertex shader for the shader mount */\n// language=GLSL\nexport const vertexShaderSource = `#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec4 a_position;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\nuniform float u_imageAspectRatio;\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nout vec2 v_objectUV;\nout vec2 v_objectBoxSize;\nout vec2 v_responsiveUV;\nout vec2 v_responsiveBoxGivenSize;\nout vec2 v_patternUV;\nout vec2 v_patternBoxSize;\nout vec2 v_imageUV;\n\nvec3 getBoxSize(float boxRatio, vec2 givenBoxSize) {\n  vec2 box = vec2(0.);\n  // fit = none\n  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);\n  float noFitBoxWidth = box.x;\n  if (u_fit == 1.) { // fit = contain\n    box.x = boxRatio * min(u_resolution.x / boxRatio, u_resolution.y);\n  } else if (u_fit == 2.) { // fit = cover\n    box.x = boxRatio * max(u_resolution.x / boxRatio, u_resolution.y);\n  }\n  box.y = box.x / boxRatio;\n  return vec3(box, noFitBoxWidth);\n}\n\nvoid main() {\n  gl_Position = a_position;\n\n  vec2 uv = gl_Position.xy * .5;\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n\n  // ===================================================\n\n  float fixedRatio = 1.;\n  vec2 fixedRatioBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n\n  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize).xy;\n  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;\n\n  v_objectUV = uv;\n  v_objectUV *= objectWorldScale;\n  v_objectUV += boxOrigin * (objectWorldScale - 1.);\n  v_objectUV += graphicOffset;\n  v_objectUV /= u_scale;\n  v_objectUV = graphicRotation * v_objectUV;\n\n  // ===================================================\n\n  v_responsiveBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  vec2 responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize).xy;\n  vec2 responsiveBoxScale = u_resolution.xy / responsiveBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_responsiveHelperBox = uv;\n  v_responsiveHelperBox *= responsiveBoxScale;\n  v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);\n  #endif\n\n  v_responsiveUV = uv;\n  v_responsiveUV *= responsiveBoxScale;\n  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);\n  v_responsiveUV += graphicOffset;\n  v_responsiveUV /= u_scale;\n  v_responsiveUV.x *= responsiveRatio;\n  v_responsiveUV = graphicRotation * v_responsiveUV;\n  v_responsiveUV.x /= responsiveRatio;\n\n  // ===================================================\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 patternBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n\n  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize);\n  v_patternBoxSize = boxSizeData.xy;\n  float patternBoxNoFitBoxWidth = boxSizeData.z;\n  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n\n  v_patternUV = uv;\n  v_patternUV += graphicOffset / patternBoxScale;\n  v_patternUV += boxOrigin;\n  v_patternUV -= boxOrigin / patternBoxScale;\n  v_patternUV *= u_resolution.xy;\n  v_patternUV /= u_pixelRatio;\n  if (u_fit > 0.) {\n    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n  }\n  v_patternUV /= u_scale;\n  v_patternUV = graphicRotation * v_patternUV;\n  v_patternUV += boxOrigin / patternBoxScale;\n  v_patternUV -= boxOrigin;\n  // x100 is a default multiplier between vertex and fragmant shaders\n  // we use it to avoid UV presision issues\n  v_patternUV *= .01;\n\n  // ===================================================\n\n  vec2 imageBoxSize;\n  if (u_fit == 1.) { // contain\n    imageBoxSize.x = min(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else if (u_fit == 2.) { // cover\n    imageBoxSize.x = max(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else {\n    imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n  }\n  imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n  vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n  v_imageUV = uv;\n  v_imageUV *= imageBoxScale;\n  v_imageUV += boxOrigin * (imageBoxScale - 1.);\n  v_imageUV += graphicOffset;\n  v_imageUV /= u_scale;\n  v_imageUV.x *= u_imageAspectRatio;\n  v_imageUV = graphicRotation * v_imageUV;\n  v_imageUV.x /= u_imageAspectRatio;\n\n  v_imageUV += .5;\n  v_imageUV.y = 1. - v_imageUV.y;\n}`;\n", "import { vertexShaderSource } from './vertex-shader.js';\n\nconst DEFAULT_MAX_PIXEL_COUNT: number = 1920 * 1080 * 4;\n\nexport class ShaderMount {\n  public parentElement: PaperShaderElement;\n  public canvasElement: HTMLCanvasElement;\n  private gl: WebGL2RenderingContext;\n  private program: WebGLProgram | null = null;\n  private uniformLocations: Record<string, WebGLUniformLocation | null> = {};\n  /** The fragment shader that we are using */\n  private fragmentShader: string;\n  /** Stores the RAF for the render loop */\n  private rafId: number | null = null;\n  /** Time of the last rendered frame */\n  private lastRenderTime = 0;\n  /** Total time that we have played any animation, passed as a uniform to the shader for time-based VFX */\n  private currentFrame = 0;\n  /** The speed that we progress through animation time (multiplies by delta time every update). Allows negatives to play in reverse. If set to 0, rAF will stop entirely so static shaders have no recurring performance costs */\n  private speed = 0;\n  /** Actual speed used that accounts for document visibility (we pause the shader if the tab is hidden) */\n  private currentSpeed = 0;\n  /** Uniforms that are provided by the user for the specific shader being mounted (not including uniforms that this Mount adds, like time and resolution) */\n  private providedUniforms: ShaderMountUniforms;\n  /** Names of the uniforms that should have mipmaps generated for them */\n  private mipmaps: string[] = [];\n  /** Just a sanity check to make sure frames don't run after we're disposed */\n  private hasBeenDisposed = false;\n  /** If the resolution of the canvas has changed since the last render */\n  private resolutionChanged = true;\n  /** Store textures that are provided by the user */\n  private textures: Map<string, WebGLTexture> = new Map();\n  private minPixelRatio;\n  private maxPixelCount;\n  private isSafari = isSafari();\n  private uniformCache: Record<string, unknown> = {};\n  private textureUnitMap: Map<string, number> = new Map();\n\n  constructor(\n    /** The div you'd like to mount the shader to. The shader will match its size. */\n    parentElement: HTMLElement,\n    fragmentShader: string,\n    uniforms: ShaderMountUniforms,\n    webGlContextAttributes?: WebGLContextAttributes,\n    /** The speed of the animation, or 0 to stop it. Supports negative values to play in reverse. */\n    speed = 0,\n    /** Pass a frame to offset the starting u_time value and give deterministic results*/\n    frame = 0,\n    /**\n     * The minimum pixel ratio to render at, defaults to 2.\n     * May be reduced to improve performance or increased together with `maxPixelCount` to improve antialiasing.\n     */\n    minPixelRatio = 2,\n    /**\n     * The maximum amount of physical device pixels to render for the shader,\n     * by default it's 1920 * 1080 * 2x dpi (per each side) = 8,294,400 pixels of a 4K screen.\n     * Actual DOM size of the canvas can be larger, it will just lose quality after this.\n     *\n     * May be reduced to improve performance or increased to improve quality on high-resolution screens.\n     */\n    maxPixelCount: number = DEFAULT_MAX_PIXEL_COUNT,\n    /** Names of the uniforms that should have mipmaps generated for them */\n    mipmaps: string[] = []\n  ) {\n    if (parentElement instanceof HTMLElement) {\n      this.parentElement = parentElement as PaperShaderElement;\n    } else {\n      throw new Error('Paper Shaders: parent element must be an HTMLElement');\n    }\n\n    if (!document.querySelector('style[data-paper-shader]')) {\n      const styleElement = document.createElement('style');\n      styleElement.innerHTML = defaultStyle;\n      styleElement.setAttribute('data-paper-shader', '');\n      document.head.prepend(styleElement);\n    }\n\n    // Create the canvas element and mount it into the provided element\n    const canvasElement = document.createElement('canvas');\n    this.canvasElement = canvasElement;\n    this.parentElement.prepend(canvasElement);\n    this.fragmentShader = fragmentShader;\n    this.providedUniforms = uniforms;\n    this.mipmaps = mipmaps;\n    // Base our starting animation time on the provided frame value\n    this.currentFrame = frame;\n    this.minPixelRatio = minPixelRatio;\n    this.maxPixelCount = maxPixelCount;\n\n    const gl = canvasElement.getContext('webgl2', webGlContextAttributes);\n    if (!gl) {\n      throw new Error('Paper Shaders: WebGL is not supported in this browser');\n    }\n    this.gl = gl;\n\n    this.initProgram();\n    this.setupPositionAttribute();\n    // Grab the locations of the uniforms in the fragment shader\n    this.setupUniforms();\n    // Put the user provided values into the uniforms\n    this.setUniformValues(this.providedUniforms);\n    // Set up the resize observer to handle window resizing and set u_resolution\n    this.setupResizeObserver();\n    // Set up the visual viewport change listener to handle zoom changes (pinch zoom and classic browser zoom)\n    visualViewport?.addEventListener('resize', this.handleVisualViewportChange);\n\n    // Set the animation speed after everything is ready to go\n    this.setSpeed(speed);\n\n    // Mark parent element as paper shader mount\n    this.parentElement.setAttribute('data-paper-shader', '');\n\n    // Add the shaderMount instance to the div mount element to make it easily accessible\n    this.parentElement.paperShaderMount = this;\n\n    // Listen for document visibility changes to pause the shader when the tab is hidden\n    document.addEventListener('visibilitychange', this.handleDocumentVisibilityChange);\n  }\n\n  private initProgram = () => {\n    const program = createProgram(this.gl, vertexShaderSource, this.fragmentShader);\n    if (!program) return;\n    this.program = program;\n  };\n\n  private setupPositionAttribute = () => {\n    const positionAttributeLocation = this.gl.getAttribLocation(this.program!, 'a_position');\n    const positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);\n    this.gl.enableVertexAttribArray(positionAttributeLocation);\n    this.gl.vertexAttribPointer(positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);\n  };\n\n  private setupUniforms = () => {\n    // Create a map to store all uniform locations\n    const uniformLocations: Record<string, WebGLUniformLocation | null> = {\n      u_time: this.gl.getUniformLocation(this.program!, 'u_time'),\n      u_pixelRatio: this.gl.getUniformLocation(this.program!, 'u_pixelRatio'),\n      u_resolution: this.gl.getUniformLocation(this.program!, 'u_resolution'),\n    };\n\n    // Add locations for all provided uniforms\n    Object.entries(this.providedUniforms).forEach(([key, value]) => {\n      uniformLocations[key] = this.gl.getUniformLocation(this.program!, key);\n\n      // For texture uniforms, also look for the aspect ratio uniform\n      if (value instanceof HTMLImageElement) {\n        const aspectRatioUniformName = `${key}AspectRatio`;\n        uniformLocations[aspectRatioUniformName] = this.gl.getUniformLocation(this.program!, aspectRatioUniformName);\n      }\n    });\n\n    this.uniformLocations = uniformLocations;\n  };\n\n  /**\n   * The scale that we should render at.\n   * - Used to target 2x rendering even on 1x screens for better antialiasing\n   * - Prevents the virtual resolution from going beyond the maximum resolution\n   * - Accounts for the page zoom level so we render in physical device pixels rather than CSS pixels\n   */\n  private renderScale = 1;\n  private parentWidth = 0;\n  private parentHeight = 0;\n  private parentDevicePixelWidth = 0;\n  private parentDevicePixelHeight = 0;\n  private devicePixelsSupported = false;\n\n  private resizeObserver: ResizeObserver | null = null;\n  private setupResizeObserver = () => {\n    this.resizeObserver = new ResizeObserver(([entry]) => {\n      if (entry?.borderBoxSize[0]) {\n        const physicalPixelSize = entry.devicePixelContentBoxSize?.[0];\n\n        if (physicalPixelSize !== undefined) {\n          this.devicePixelsSupported = true;\n          this.parentDevicePixelWidth = physicalPixelSize.inlineSize;\n          this.parentDevicePixelHeight = physicalPixelSize.blockSize;\n        }\n\n        this.parentWidth = entry.borderBoxSize[0].inlineSize;\n        this.parentHeight = entry.borderBoxSize[0].blockSize;\n      }\n\n      this.handleResize();\n    });\n\n    this.resizeObserver.observe(this.parentElement);\n  };\n\n  // Visual viewport resize handler, mainly used to react to browser zoom changes.\n  // Resize observer by itself does not react to pinch zoom, and although it usually\n  // reacts to classic browser zoom, it's not guaranteed in edge cases.\n  // Since timing between visual viewport changes and resize observer is complex\n  // and because we'd like to know the device pixel sizes of elements, we just restart\n  // the observer to get a guaranteed fresh callback regardless if it would have triggered or not.\n  private handleVisualViewportChange = () => {\n    this.resizeObserver?.disconnect();\n    this.setupResizeObserver();\n\n    // In case of debugging timing, from here on:\n    // - animation frame 1: a paint after the visual viewport resize\n    // - animation frame 2: a paint after the resize observer has been handled, if it was ever triggered\n  };\n\n  /** Resize handler for when the container div changes size or the max pixel count changes and we want to resize our canvas to match */\n  private handleResize = () => {\n    // Aim to render at least as many pixels as physically displayed\n    // This will overshoot when the user zooms out, but that's acceptable\n\n    let targetPixelWidth = 0;\n    let targetPixelHeight = 0;\n\n    // If window.devicePixelRatio is below 1, it's safe to say the browser is just zoomed out\n    // We can use 1 as the minimum value not to upscale it needlessly to meet the min pixel ratio param\n    const dpr = Math.max(1, window.devicePixelRatio);\n    const pinchZoom = visualViewport?.scale ?? 1;\n\n    if (this.devicePixelsSupported) {\n      // Use the real pixel size if we know it, plus meet the min pixel ratio requirement and add in pinch zoom\n      const scaleToMeetMinPixelRatio = Math.max(1, this.minPixelRatio / dpr);\n      targetPixelWidth = this.parentDevicePixelWidth * scaleToMeetMinPixelRatio * pinchZoom;\n      targetPixelHeight = this.parentDevicePixelHeight * scaleToMeetMinPixelRatio * pinchZoom;\n    } else {\n      // Otherwise try to approximate the element size in device pixels using devicePixelRatio.\n      // (devicePixelRatio is imprecise and element's width/height may be fractional CSS sizes, not real pixels).\n      let targetRenderScale = Math.max(dpr, this.minPixelRatio) * pinchZoom;\n\n      if (this.isSafari) {\n        // As of 2025, Safari reports physical devicePixelRatio, but other browsers add the current zoom level:\n        // https://bugs.webkit.org/show_bug.cgi?id=124862\n        //\n        // In Safari we need to factor in the zoom level manually in order to set the target resolution.\n        // To avoid sidebars upscaling the target resolution, set a minimum zoom level of 1.\n        // This will render at higher resolution when zoomed out, but that's fine.\n        // (We mostly care about maintaining good quality when zoomed in).\n        const zoomLevel = bestGuessBrowserZoom();\n        targetRenderScale *= Math.max(1, zoomLevel);\n      }\n\n      // Rounding the client width/height since they may be fractional in CSS layout values\n      targetPixelWidth = Math.round(this.parentWidth) * targetRenderScale;\n      targetPixelHeight = Math.round(this.parentHeight) * targetRenderScale;\n    }\n\n    // Prevent the total rendered pixel count from exceeding maxPixelCount\n    const maxPixelCountHeadroom = Math.sqrt(this.maxPixelCount) / Math.sqrt(targetPixelWidth * targetPixelHeight);\n    const scaleToMeetMaxPixelCount = Math.min(1, maxPixelCountHeadroom);\n    const newWidth = Math.round(targetPixelWidth * scaleToMeetMaxPixelCount);\n    const newHeight = Math.round(targetPixelHeight * scaleToMeetMaxPixelCount);\n    const newRenderScale = newWidth / Math.round(this.parentWidth);\n\n    if (\n      this.canvasElement.width !== newWidth ||\n      this.canvasElement.height !== newHeight ||\n      this.renderScale !== newRenderScale // Usually, only render scale changes when the user zooms in/out\n    ) {\n      this.renderScale = newRenderScale;\n      this.canvasElement.width = newWidth;\n      this.canvasElement.height = newHeight;\n      this.resolutionChanged = true;\n      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n\n      // this is necessary to avoid flashes while resizing (the next scheduled render will set uniforms)\n      this.render(performance.now());\n    }\n  };\n\n  private render = (currentTime: number) => {\n    if (this.hasBeenDisposed) return;\n\n    if (this.program === null) {\n      console.warn('Tried to render before program or gl was initialized');\n      return;\n    }\n\n    // Calculate the delta time\n    const dt = currentTime - this.lastRenderTime;\n    this.lastRenderTime = currentTime;\n    // Increase the total animation time by dt * animationSpeed\n    if (this.currentSpeed !== 0) {\n      this.currentFrame += dt * this.currentSpeed;\n    }\n\n    // Clear the canvas\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n    // Update uniforms\n    this.gl.useProgram(this.program);\n\n    // Update the time uniform\n    this.gl.uniform1f(this.uniformLocations.u_time!, this.currentFrame * 0.001);\n\n    // If the resolution has changed, we need to update the uniform\n    if (this.resolutionChanged) {\n      this.gl.uniform2f(this.uniformLocations.u_resolution!, this.gl.canvas.width, this.gl.canvas.height);\n      this.gl.uniform1f(this.uniformLocations.u_pixelRatio!, this.renderScale);\n      this.resolutionChanged = false;\n    }\n\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n\n    // Loop if we're animating\n    if (this.currentSpeed !== 0) {\n      this.requestRender();\n    } else {\n      this.rafId = null;\n    }\n  };\n\n  private requestRender = () => {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n    }\n    this.rafId = requestAnimationFrame(this.render);\n  };\n\n  /** Creates a texture from an image and sets it into a uniform value */\n  private setTextureUniform = (uniformName: string, image: HTMLImageElement): void => {\n    if (!image.complete || image.naturalWidth === 0) {\n      throw new Error(`Paper Shaders: image for uniform ${uniformName} must be fully loaded`);\n    }\n\n    // Clean up existing texture if present\n    const existingTexture = this.textures.get(uniformName);\n    if (existingTexture) {\n      this.gl.deleteTexture(existingTexture);\n    }\n\n    // Get texture unit\n    if (!this.textureUnitMap.has(uniformName)) {\n      this.textureUnitMap.set(uniformName, this.textureUnitMap.size);\n    }\n    const textureUnit = this.textureUnitMap.get(uniformName)!;\n    // Activate correct texture unit before creating the texture\n    this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n\n    // Create and set up the new texture\n    const texture = this.gl.createTexture();\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n\n    // Set texture parameters\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n\n    // Upload image to texture\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n\n    // Generate mipmaps if the uniform is in the mipmaps list\n    if (this.mipmaps.includes(uniformName)) {\n      this.gl.generateMipmap(this.gl.TEXTURE_2D);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR);\n    }\n\n    const error = this.gl.getError();\n    if (error !== this.gl.NO_ERROR || texture === null) {\n      console.error('Paper Shaders: WebGL error when uploading texture:', error);\n      return;\n    }\n\n    // Store the texture\n    this.textures.set(uniformName, texture);\n\n    // Set up texture unit and uniform\n    const location = this.uniformLocations[uniformName];\n    if (location) {\n      this.gl.uniform1i(location, textureUnit);\n\n      // Calculate and set the aspect ratio uniform\n      const aspectRatioUniformName = `${uniformName}AspectRatio`;\n      const aspectRatioLocation = this.uniformLocations[aspectRatioUniformName];\n      if (aspectRatioLocation) {\n        const aspectRatio = image.naturalWidth / image.naturalHeight;\n        this.gl.uniform1f(aspectRatioLocation, aspectRatio);\n      }\n    }\n  };\n\n  /** Utility: recursive equality test for all the uniforms */\n  private areUniformValuesEqual = (a: any, b: any): boolean => {\n    if (a === b) return true;\n    if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {\n      return a.every((val, i) => this.areUniformValuesEqual(val, (b as any)[i]));\n    }\n    return false;\n  };\n\n  /** Sets the provided uniform values into the WebGL program, can be a partial list of uniforms that have changed */\n  private setUniformValues = (updatedUniforms: ShaderMountUniforms) => {\n    this.gl.useProgram(this.program);\n    Object.entries(updatedUniforms).forEach(([key, value]) => {\n      // Grab the value to use in the uniform cache\n      let cacheValue: ShaderMountUniforms[keyof ShaderMountUniforms] | string = value;\n      if (value instanceof HTMLImageElement) {\n        // Images use their src for the cache value to save memory\n        cacheValue = `${value.src.slice(0, 200)}|${value.naturalWidth}x${value.naturalHeight}`;\n      }\n\n      // Check if the uniform value has changed and, if not, bail early to avoid extra work\n      if (this.areUniformValuesEqual(this.uniformCache[key], cacheValue)) return;\n      // Update the uniform cache if we are still here\n      this.uniformCache[key] = cacheValue;\n\n      const location = this.uniformLocations[key];\n      if (!location) {\n        console.warn(`Uniform location for ${key} not found`);\n        return;\n      }\n\n      if (value instanceof HTMLImageElement) {\n        // Texture case, requires a good amount of code so it gets its own function:\n        this.setTextureUniform(key, value);\n      } else if (Array.isArray(value)) {\n        // Array case\n        let flatArray: number[] | null = null;\n        let valueLength: number | null = null;\n\n        // If it's an array of same-sized arrays, flatten it down so we can set the uniform\n        if (value[0] !== undefined && Array.isArray(value[0])) {\n          const firstChildLength = value[0].length;\n          if (value.every((arr) => (arr as number[]).length === firstChildLength)) {\n            // Array of same-sized arrays case, flattens the array sets it\n            flatArray = value.flat();\n            valueLength = firstChildLength;\n          } else {\n            console.warn(`All child arrays must be the same length for ${key}`);\n            return;\n          }\n        } else {\n          // Array of primitive values case, supports 2, 3, 4, 9, 16 length arrays\n          flatArray = value as number[];\n          valueLength = flatArray.length;\n        }\n\n        // Set the uniform based on array length... supports 2, 3, 4, 9, 16 length arrays of primitive values\n        // or arbitrary length arrays of arrays\n        switch (valueLength) {\n          case 2:\n            this.gl.uniform2fv(location, flatArray);\n            break;\n          case 3:\n            this.gl.uniform3fv(location, flatArray);\n            break;\n          case 4:\n            this.gl.uniform4fv(location, flatArray);\n            break;\n          case 9:\n            this.gl.uniformMatrix3fv(location, false, flatArray);\n            break;\n          case 16:\n            this.gl.uniformMatrix4fv(location, false, flatArray);\n            break;\n          default:\n            console.warn(`Unsupported uniform array length: ${valueLength}`);\n        }\n      } else if (typeof value === 'number') {\n        // Number case, supports floats and ints\n        this.gl.uniform1f(location, value);\n      } else if (typeof value === 'boolean') {\n        // Boolean case, supports true and false\n        this.gl.uniform1i(location, value ? 1 : 0);\n      } else {\n        // May happen on the server for SSR when undefined images are passed in\n        console.warn(`Unsupported uniform type for ${key}: ${typeof value}`);\n      }\n    });\n  };\n\n  /** Gets the current total animation time from 0ms */\n  public getCurrentFrame = (): number => {\n    return this.currentFrame;\n  };\n\n  /** Set a frame to get a deterministic result, frames are literally just milliseconds from zero since the animation started */\n  public setFrame = (newFrame: number): void => {\n    this.currentFrame = newFrame;\n    this.lastRenderTime = performance.now();\n    this.render(performance.now());\n  };\n\n  /** Set an animation speed (or 0 to stop animation) */\n  public setSpeed = (newSpeed = 1): void => {\n    // Set the new animation speed\n    this.speed = newSpeed;\n    this.setCurrentSpeed(document.hidden ? 0 : newSpeed);\n  };\n\n  private setCurrentSpeed = (newSpeed: number): void => {\n    this.currentSpeed = newSpeed;\n\n    if (this.rafId === null && newSpeed !== 0) {\n      // Moving from 0 to animating, kick off a new rAF loop\n      this.lastRenderTime = performance.now();\n      this.rafId = requestAnimationFrame(this.render);\n    }\n\n    if (this.rafId !== null && newSpeed === 0) {\n      // Moving from animating to not animating, cancel the rAF loop\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n  };\n\n  /** Set the maximum pixel count for the shader, this will limit the number of pixels that will be rendered */\n  public setMaxPixelCount = (newMaxPixelCount: number = DEFAULT_MAX_PIXEL_COUNT): void => {\n    this.maxPixelCount = newMaxPixelCount;\n\n    this.handleResize();\n  };\n\n  /** Set the minimum pixel ratio for the shader */\n  public setMinPixelRatio = (newMinPixelRatio: number = 2): void => {\n    this.minPixelRatio = newMinPixelRatio;\n\n    this.handleResize();\n  };\n\n  /** Update the uniforms that are provided by the outside shader, can be a partial set with only the uniforms that have changed */\n  public setUniforms = (newUniforms: ShaderMountUniforms): void => {\n    this.setUniformValues(newUniforms);\n    this.providedUniforms = { ...this.providedUniforms, ...newUniforms };\n\n    this.render(performance.now());\n  };\n\n  private handleDocumentVisibilityChange = () => {\n    this.setCurrentSpeed(document.hidden ? 0 : this.speed);\n  };\n\n  /** Dispose of the shader mount, cleaning up all of the WebGL resources */\n  public dispose = (): void => {\n    // Immediately mark as disposed to prevent future renders from leaking in\n    this.hasBeenDisposed = true;\n\n    // Cancel the rAF loop\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n\n    if (this.gl && this.program) {\n      // Clean up all textures\n      this.textures.forEach((texture) => {\n        this.gl.deleteTexture(texture);\n      });\n      this.textures.clear();\n\n      this.gl.deleteProgram(this.program);\n      this.program = null;\n\n      // Reset the WebGL context\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n\n      // Clear any errors\n      this.gl.getError();\n    }\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n\n    visualViewport?.removeEventListener('resize', this.handleVisualViewportChange);\n    document.removeEventListener('visibilitychange', this.handleDocumentVisibilityChange);\n\n    this.uniformLocations = {};\n\n    // Remove the shader from the div wrapper element\n    this.canvasElement.remove();\n    // Free up the reference to self to enable garbage collection\n    delete this.parentElement.paperShaderMount;\n  };\n}\n\nfunction createShader(gl: WebGL2RenderingContext, type: number, source: string): WebGLShader | null {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n\n  return shader;\n}\n\nfunction createProgram(\n  gl: WebGL2RenderingContext,\n  vertexShaderSource: string,\n  fragmentShaderSource: string\n): WebGLProgram | null {\n  const format = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n  const precision = format ? format.precision : null;\n  // MEDIUM_FLOAT precision can be 10, 16 or 23 bits depending on device;\n  // Shaders fail on 10 bit (and 16 bit is hard to test) => we force 23-bit by switching to highp\n  if (precision && precision < 23) {\n    vertexShaderSource = vertexShaderSource.replace(/precision\\s+(lowp|mediump)\\s+float;/g, 'precision highp float;');\n    fragmentShaderSource = fragmentShaderSource\n      .replace(/precision\\s+(lowp|mediump)\\s+float/g, 'precision highp float')\n      .replace(/\\b(uniform|varying|attribute)\\s+(lowp|mediump)\\s+(\\w+)/g, '$1 highp $3');\n  }\n\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n  if (!vertexShader || !fragmentShader) return null;\n\n  const program = gl.createProgram();\n  if (!program) return null;\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return null;\n  }\n\n  // Clean up shaders after successful linking\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n\n  return program;\n}\n\nconst defaultStyle = `@layer paper-shaders {\n  :where([data-paper-shader]) {\n    isolation: isolate;\n    position: relative;\n\n    & canvas {\n      contain: strict;\n      display: block;\n      position: absolute;\n      inset: 0;\n      z-index: -1;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n      corner-shape: inherit;\n    }\n  }\n}`;\n\n/** The parent `<div>` element that has a ShaderMount available on it */\nexport interface PaperShaderElement extends HTMLElement {\n  paperShaderMount: ShaderMount | undefined;\n}\n\n/** Check if an element is a Paper shader element */\nexport function isPaperShaderElement(element: HTMLElement): element is PaperShaderElement {\n  return 'paperShaderMount' in element;\n}\n\n/**\n * Uniform types that we support to be auto-mapped into the fragment shader\n *\n * We accept undefined as a convenience for server rendering, when some things may be undefined\n * We just skip setting the uniform if it's undefined. This allows the shader mount to still take up space during server rendering\n */\nexport interface ShaderMountUniforms {\n  [key: string]: boolean | number | number[] | number[][] | HTMLImageElement | undefined;\n}\n\nexport interface ShaderMotionParams {\n  speed?: number;\n  frame?: number;\n}\n\nexport type ShaderPreset<T> = {\n  name: string;\n  params: Required<T>;\n};\n\nexport type ImageShaderPreset<T> = {\n  name: string;\n  /**\n   * Params for the shader excluding the image.\n   * Image is excluded as it isn't considered a preset,\n   * e.g. when switching between presets it shouldn't switch the image.\n   *\n   * While we exclude images from presets they should still be set with a default prop value so the code-first usage of shaders remains great.\n   */\n  params: Required<Omit<T, 'image'>>;\n};\n\nfunction isSafari() {\n  const ua = navigator.userAgent.toLowerCase();\n  return ua.includes('safari') && !ua.includes('chrome') && !ua.includes('android');\n}\n\n// Zoom level can be estimated comparing the browser's outerWidth and the viewport width.\n// It's nowhere near perfect because it's affected by the presence of browser sidebars,\n// like a vertical web inspector or Arc's sidebar. Also, both outerWidth and innerWidth\n// are integers, which would almost never give us a perfect ratio at face values.\n//\n// Still, this is pretty accurate in the vast majority of cases.\n//\n// Note 1:\n// Avoid innerWidth, use visualViewport.width instead.\n// - innerWidth is affected by pinch zoom in Safari, but not other browsers.\n//   visualViewport.width works consistently in all browsers.\n// - innerWidth is rounded to integer, but not visualViewport.width.\n// - visualViewport.width is affected by hard scrollbars, so they need to be added manually\n//\n// Note 2:\n// Opening a sidebar in Safari like web inspector or bookmarks will throw off the zoom\n// level detection and result in a larger target resolution. Not a concern in real-world usage\n// with Safari, but we'd rather not try to detect zoom levels with other browsers\n// (e.g. Arc always has a sidebar, which affects outerWidth vs visualViewport.width).\nfunction bestGuessBrowserZoom() {\n  const viewportScale = visualViewport?.scale ?? 1;\n  const viewportWidth = visualViewport?.width ?? window.innerWidth;\n  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  const innerWidth = viewportScale * viewportWidth + scrollbarWidth;\n\n  // outerWidth and innerWidth are always integers so we won't often get the original zoom ratio\n  // E.g. given a 125% zoom, outerWidth = 1657, innerWidth = 1325, 1657 / 1325 = 1.2505660377\n  // We check for common zoom levels and return the closest one if found.\n\n  const ratio = outerWidth / innerWidth;\n  const zoomPercentageRounded = Math.round(100 * ratio);\n\n  // All zoom levels divisible by 5%\n  if (zoomPercentageRounded % 5 === 0) {\n    return zoomPercentageRounded / 100;\n  }\n\n  // 33% zoom\n  if (zoomPercentageRounded === 33) {\n    return 1 / 3;\n  }\n\n  // 67% zoom\n  if (zoomPercentageRounded === 67) {\n    return 2 / 3;\n  }\n\n  // 133% zoom\n  if (zoomPercentageRounded === 133) {\n    return 4 / 3;\n  }\n\n  return ratio;\n}\n", "export interface ShaderSizingUniforms {\n  u_fit: (typeof ShaderFitOptions)[ShaderFit];\n  u_scale: number;\n  u_rotation: number;\n  u_originX: number;\n  u_originY: number;\n  u_offsetX: number;\n  u_offsetY: number;\n  u_worldWidth: number;\n  u_worldHeight: number;\n}\n\nexport interface ShaderSizingParams {\n  fit?: 'none' | 'contain' | 'cover';\n  scale?: number;\n  rotation?: number;\n  originX?: number;\n  originY?: number;\n  offsetX?: number;\n  offsetY?: number;\n  worldWidth?: number;\n  worldHeight?: number;\n}\n\nexport const defaultObjectSizing: Required<ShaderSizingParams> = {\n  fit: 'contain',\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0,\n};\n\nexport const defaultPatternSizing: Required<ShaderSizingParams> = {\n  fit: 'none',\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0,\n};\n\nexport const ShaderFitOptions = {\n  none: 0,\n  contain: 1,\n  cover: 2,\n} as const;\n\nexport type ShaderFit = keyof typeof ShaderFitOptions;\n", "// language=GLSL\nexport const declarePI = `\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n`;\n\n// language=GLSL\nexport const rotation2 = `\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n`;\n\n// language=GLSL\nexport const proceduralHash11 = `\n  float hash11(float p) {\n    p = fract(p * 0.3183099) + 0.1;\n    p *= p + 19.19;\n    return fract(p * p);\n  }\n`;\n\n// language=GLSL\nexport const proceduralHash21 = `\n  float hash21(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p + 19.19);\n    return fract(p.x * p.y);\n  }\n`;\n\n// language=GLSL\nexport const proceduralHash22 = `\n  vec2 hash22(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p.yx + 19.19);\n    return fract(vec2(p.x * p.y, p.x + p.y));\n  }\n`;\n\n// language=GLSL\nexport const textureRandomizerR = `\n  float randomR(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).r;\n  }\n`;\n\n// language=GLSL\nexport const textureRandomizerGB = `\n  vec2 randomGB(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).gb;\n  }\n`;\n\n// language=GLSL\nexport const colorBandingFix = `\n  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);\n`;\n\n// language=GLSL\nexport const simplexNoise = `\nvec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, 0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n      dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n`;\n\n// language=GLSL\nexport const fiberNoise = `\nfloat fiberRandom(vec2 p) {\n  vec2 uv = floor(p) / 100.;\n  return texture(u_noiseTexture, fract(uv)).b;\n}\n\nfloat fiberValueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = fiberRandom(i);\n  float b = fiberRandom(i + vec2(1.0, 0.0));\n  float c = fiberRandom(i + vec2(0.0, 1.0));\n  float d = fiberRandom(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat fiberNoiseFbm(in vec2 n, vec2 seedOffset) {\n  float total = 0.0, amplitude = 1.;\n  for (int i = 0; i < 4; i++) {\n    n = rotate(n, .7);\n    total += fiberValueNoise(n + seedOffset) * amplitude;\n    n *= 2.;\n    amplitude *= 0.6;\n  }\n  return total;\n}\n\nfloat fiberNoise(vec2 uv, vec2 seedOffset) {\n  float epsilon = 0.001;\n  float n1 = fiberNoiseFbm(uv + vec2(epsilon, 0.0), seedOffset);\n  float n2 = fiberNoiseFbm(uv - vec2(epsilon, 0.0), seedOffset);\n  float n3 = fiberNoiseFbm(uv + vec2(0.0, epsilon), seedOffset);\n  float n4 = fiberNoiseFbm(uv - vec2(0.0, epsilon), seedOffset);\n  return length(vec2(n1 - n2, n3 - n4)) / (2.0 * epsilon);\n}\n`;\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport {\n  type ShaderSizingParams,\n  type ShaderSizingUniforms,\n} from '../shader-sizing.js';\nimport { declarePI, rotation2, proceduralHash21 } from '../shader-utils.js';\n\nexport const meshGradientMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n * A flowing composition of color spots, moving along distinct trajectories\n * and transformed by organic distortion.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_colors (vec4[]): Up to 10 color spots in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_distortion (float): Power of organic noise distortion (0 to 1)\n * - u_swirl (float): Power of vortex distortion (0 to 1)\n * - u_grainMixer (float): Strength of grain distortion applied to shape edges (0 to 1)\n * - u_grainOverlay (float): Post-processing black/white grain overlay (0 to 1)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_objectUV (vec2): Object box UV coordinates with global sizing (scale, rotation, offsets, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const meshGradientFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colors[${meshGradientMeta.maxColorCount}];\nuniform float u_colorsCount;\n\nuniform float u_distortion;\nuniform float u_swirl;\nuniform float u_grainMixer;\nuniform float u_grainOverlay;\n\nin vec2 v_objectUV;\nout vec4 fragColor;\n\n${declarePI}\n${rotation2}\n${proceduralHash21}\n\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = hash21(i);\n  float b = hash21(i + vec2(1.0, 0.0));\n  float c = hash21(i + vec2(0.0, 1.0));\n  float d = hash21(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat noise(vec2 n, vec2 seedOffset) {\n  return valueNoise(n + seedOffset);\n}\n\nvec2 getPosition(int i, float t) {\n  float a = float(i) * .37;\n  float b = .6 + fract(float(i) / 3.) * .9;\n  float c = .8 + fract(float(i + 1) / 4.);\n\n  float x = sin(t * b + a);\n  float y = cos(t * c + a * 1.5);\n\n  return .5 + .5 * vec2(x, y);\n}\n\nvoid main() {\n  vec2 uv = v_objectUV;\n  uv += .5;\n  vec2 grainUV = uv * 1000.;\n\n  float grain = noise(grainUV, vec2(0.));\n  float mixerGrain = .4 * u_grainMixer * (grain - .5);\n\n  const float firstFrameOffset = 41.5;\n  float t = .5 * (u_time + firstFrameOffset);\n\n  float radius = smoothstep(0., 1., length(uv - .5));\n  float center = 1. - radius;\n  for (float i = 1.; i <= 2.; i++) {\n    uv.x += u_distortion * center / i * sin(t + i * .4 * smoothstep(.0, 1., uv.y)) * cos(.2 * t + i * 2.4 * smoothstep(.0, 1., uv.y));\n    uv.y += u_distortion * center / i * cos(t + i * 2. * smoothstep(.0, 1., uv.x));\n  }\n\n  vec2 uvRotated = uv;\n  uvRotated -= vec2(.5);\n  float angle = 3. * u_swirl * radius;\n  uvRotated = rotate(uvRotated, -angle);\n  uvRotated += vec2(.5);\n\n  vec3 color = vec3(0.);\n  float opacity = 0.;\n  float totalWeight = 0.;\n\n  for (int i = 0; i < ${meshGradientMeta.maxColorCount}; i++) {\n    if (i >= int(u_colorsCount)) break;\n\n    vec2 pos = getPosition(i, t) + mixerGrain;\n    vec3 colorFraction = u_colors[i].rgb * u_colors[i].a;\n    float opacityFraction = u_colors[i].a;\n\n    float dist = length(uvRotated - pos);\n\n    dist = pow(dist, 3.5);\n    float weight = 1. / (dist + 1e-3);\n    color += colorFraction * weight;\n    opacity += opacityFraction * weight;\n    totalWeight += weight;\n  }\n\n  color /= max(1e-4, totalWeight);\n  opacity /= max(1e-4, totalWeight);\n\n  float grainOverlay = valueNoise(rotate(grainUV, 1.) + vec2(3.));\n  grainOverlay = mix(grainOverlay, valueNoise(rotate(grainUV, 2.) + vec2(-1.)), .5);\n  grainOverlay = pow(grainOverlay, 1.3);\n\n  float grainOverlayV = grainOverlay * 2. - 1.;\n  vec3 grainOverlayColor = vec3(step(0., grainOverlayV));\n  float grainOverlayStrength = u_grainOverlay * abs(grainOverlayV);\n  grainOverlayStrength = pow(grainOverlayStrength, .8);\n  color = mix(color, grainOverlayColor, .35 * grainOverlayStrength);\n\n  opacity += .5 * grainOverlayStrength;\n  opacity = clamp(opacity, 0., 1.);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface MeshGradientUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_distortion: number;\n  u_swirl: number;\n  u_grainMixer: number;\n  u_grainOverlay: number;\n}\n\nexport interface MeshGradientParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  distortion?: number;\n  swirl?: number;\n  grainMixer?: number;\n  grainOverlay?: number;\n}\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, textureRandomizerR, colorBandingFix } from '../shader-utils.js';\n\nexport const smokeRingMeta = {\n  maxColorCount: 10,\n  maxNoiseIterations: 8,\n} as const;\n\n/**\n * Radial multi-colored gradient shaped with layered noise for a natural, smoky aesthetic.\n *\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colors (vec4[]): Up to 10 gradient colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_thickness (float): Thickness of the ring shape (0.01 to 1)\n * - u_radius (float): Radius of the ring shape (0 to 1)\n * - u_innerShape (float): Ring inner fill amount (0 to 4)\n * - u_noiseIterations (float): Number of noise layers, more layers gives more details (1 to 8)\n * - u_noiseScale (float): Noise frequency (0.01 to 5)\n * - u_noiseTexture (sampler2D): Pre-computed randomizer source texture\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_objectUV (vec2): Object box UV coordinates with global sizing (scale, rotation, offsets, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const smokeRingFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform sampler2D u_noiseTexture;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${ smokeRingMeta.maxColorCount }];\nuniform float u_colorsCount;\n\nuniform float u_thickness;\nuniform float u_radius;\nuniform float u_innerShape;\nuniform float u_noiseScale;\nuniform float u_noiseIterations;\n\nin vec2 v_objectUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ textureRandomizerR }\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = randomR(i);\n  float b = randomR(i + vec2(1.0, 0.0));\n  float c = randomR(i + vec2(0.0, 1.0));\n  float d = randomR(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\nvec2 fbm(vec2 n0, vec2 n1) {\n  vec2 total = vec2(0.0);\n  float amplitude = .4;\n  for (int i = 0; i < ${ smokeRingMeta.maxNoiseIterations }; i++) {\n    if (i >= int(u_noiseIterations)) break;\n    total.x += valueNoise(n0) * amplitude;\n    total.y += valueNoise(n1) * amplitude;\n    n0 *= 1.99;\n    n1 *= 1.99;\n    amplitude *= 0.65;\n  }\n  return total;\n}\n\nfloat getNoise(vec2 uv, vec2 pUv, float t) {\n  vec2 pUvLeft = pUv + .03 * t;\n  float period = max(abs(u_noiseScale * TWO_PI), 1e-6);\n  vec2 pUvRight = vec2(fract(pUv.x / period) * period, pUv.y) + .03 * t;\n  vec2 noise = fbm(pUvLeft, pUvRight);\n  return mix(noise.y, noise.x, smoothstep(-.25, .25, uv.x));\n}\n\nfloat getRingShape(vec2 uv) {\n  float radius = u_radius;\n  float thickness = u_thickness;\n\n  float distance = length(uv);\n  float ringValue = 1. - smoothstep(radius, radius + thickness, distance);\n  ringValue *= smoothstep(radius - pow(u_innerShape, 3.) * thickness, radius, distance);\n\n  return ringValue;\n}\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n\n  float t = u_time;\n\n  float cycleDuration = 3.;\n  float period2 = 2.0 * cycleDuration;\n  float localTime1 = fract((0.1 * t + cycleDuration) / period2) * period2;\n  float localTime2 = fract((0.1 * t) / period2) * period2;\n  float timeBlend = .5 + .5 * sin(.1 * t * PI / cycleDuration - .5 * PI);\n\n  float atg = atan(shape_uv.y, shape_uv.x) + .001;\n  float l = length(shape_uv);\n  float radialOffset = .5 * l - inversesqrt(max(1e-4, l));\n  vec2 polar_uv1 = vec2(atg, localTime1 - radialOffset) * u_noiseScale;\n  vec2 polar_uv2 = vec2(atg, localTime2 - radialOffset) * u_noiseScale;\n  \n  float noise1 = getNoise(shape_uv, polar_uv1, t);\n  float noise2 = getNoise(shape_uv, polar_uv2, t);\n\n  float noise = mix(noise1, noise2, timeBlend);\n\n  shape_uv *= (.8 + 1.2 * noise);\n\n  float ringShape = getRingShape(shape_uv);\n\n  float mixer = ringShape * ringShape * (u_colorsCount - 1.);\n  int idxLast = int(u_colorsCount) - 1;\n  vec4 gradient = u_colors[idxLast];\n  gradient.rgb *= gradient.a;\n  for (int i = ${ smokeRingMeta.maxColorCount } - 2; i >= 0; i--) {\n    float localT = clamp(mixer - float(idxLast - i - 1), 0., 1.);\n    vec4 c = u_colors[i];\n    c.rgb *= c.a;\n    gradient = mix(gradient, c, localT);\n  }\n\n  vec3 color = gradient.rgb * ringShape;\n  float opacity = gradient.a * ringShape;\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1. - opacity);\n  opacity = opacity + u_colorBack.a * (1. - opacity);\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface SmokeRingUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_noiseScale: number;\n  u_thickness: number;\n  u_radius: number;\n  u_innerShape: number;\n  u_noiseIterations: number;\n  u_noiseTexture?: HTMLImageElement;\n}\n\nexport interface SmokeRingParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colors?: string[];\n  noiseScale?: number;\n  thickness?: number;\n  radius?: number;\n  innerShape?: number;\n  noiseIterations?: number;\n}\n", "import type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { rotation2, colorBandingFix } from '../shader-utils.js';\n\n/**\n * A glowing, web-like structure of fluid lines and soft intersections.\n * Great for creating atmospheric, organic-yet-futuristic visuals.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_colorFront (vec4): Graphics highlight color in RGBA\n * - u_colorMid (vec4): Graphics main color in RGBA\n * - u_colorBack (vec4): Background color in RGBA\n * - u_brightness (float): Luminosity of the crossing points (0 to 1)\n * - u_contrast (float): Sharpness of the bright-dark transition (0 to 1)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_patternUV (vec2): UV coordinates for pattern with global sizing (rotation, scale, offset, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n * Original algorithm: https://x.com/zozuar/status/1625182758745128981/\n */\n\n// language=GLSL\nexport const neuroNoiseFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\nuniform vec4 u_colorFront;\nuniform vec4 u_colorMid;\nuniform vec4 u_colorBack;\nuniform float u_brightness;\nuniform float u_contrast;\n\nin vec2 v_patternUV;\n\nout vec4 fragColor;\n\n${ rotation2 }\n\nfloat neuroShape(vec2 uv, float t) {\n  vec2 sine_acc = vec2(0.);\n  vec2 res = vec2(0.);\n  float scale = 8.;\n\n  for (int j = 0; j < 15; j++) {\n    uv = rotate(uv, 1.);\n    sine_acc = rotate(sine_acc, 1.);\n    vec2 layer = uv * scale + float(j) + sine_acc - t;\n    sine_acc += sin(layer);\n    res += (.5 + .5 * cos(layer)) / scale;\n    scale *= (1.2);\n  }\n  return res.x + res.y;\n}\n\nvoid main() {\n  vec2 shape_uv = v_patternUV;\n  shape_uv *= .13;\n\n  float t = .5 * u_time;\n\n  float noise = neuroShape(shape_uv, t);\n\n  noise = (1. + u_brightness) * noise * noise;\n  noise = pow(noise, .7 + 6. * u_contrast);\n  noise = min(1.4, noise);\n\n  float blend = smoothstep(0.7, 1.4, noise);\n\n  vec4 frontC = u_colorFront;\n  frontC.rgb *= frontC.a;\n  vec4 midC = u_colorMid;\n  midC.rgb *= midC.a;\n  vec4 blendFront = mix(midC, frontC, blend);\n\n  float safeNoise = max(noise, 0.0);\n  vec3 color = blendFront.rgb * safeNoise;\n  float opacity = clamp(blendFront.a * safeNoise, 0., 1.);\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1. - opacity);\n  opacity = opacity + u_colorBack.a * (1. - opacity);\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface NeuroNoiseUniforms extends ShaderSizingUniforms {\n  u_colorFront: [number, number, number, number];\n  u_colorMid: [number, number, number, number];\n  u_colorBack: [number, number, number, number];\n  u_brightness: number;\n  u_contrast: number;\n}\n\nexport interface NeuroNoiseParams extends ShaderSizingParams, ShaderMotionParams {\n  colorFront?: string;\n  colorMid?: string;\n  colorBack?: string;\n  brightness?: number;\n  contrast?: number;\n}\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, rotation2, textureRandomizerR, textureRandomizerGB } from '../shader-utils.js';\n\nexport const dotOrbitMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n * Animated multi-color dots pattern with each dot orbiting around its cell center.\n * Supports up to 10 colors and various shape and motion controls.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colors (vec4[]): Up to 10 base colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_stepsPerColor (float): Number of extra colors between base colors, 1 = N colors, 2 = 2\u00D7N, etc. (1 to 4)\n * - u_size (float): Dot radius relative to cell size (0 to 1)\n * - u_sizeRange (float): Random variation in shape size, 0 = uniform, higher = random up to base size (0 to 1)\n * - u_spreading (float): Maximum orbit distance around cell center (0 to 1)\n * - u_noiseTexture (sampler2D): Pre-computed randomizer source texture\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_patternUV (vec2): UV coordinates in pixels (scaled by 0.01 for precision), with rotation and offset applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const dotOrbitFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform sampler2D u_noiseTexture;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${ dotOrbitMeta.maxColorCount }];\nuniform float u_colorsCount;\nuniform float u_stepsPerColor;\nuniform float u_size;\nuniform float u_sizeRange;\nuniform float u_spreading;\n\nin vec2 v_patternUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ rotation2 }\n${ textureRandomizerR }\n${ textureRandomizerGB }\n\n\nvec3 voronoiShape(vec2 uv, float time) {\n  vec2 i_uv = floor(uv);\n  vec2 f_uv = fract(uv);\n\n  float spreading = .25 * clamp(u_spreading, 0., 1.);\n\n  float minDist = 1.;\n  vec2 randomizer = vec2(0.);\n  for (int y = -1; y <= 1; y++) {\n    for (int x = -1; x <= 1; x++) {\n      vec2 tileOffset = vec2(float(x), float(y));\n      vec2 rand = randomGB(i_uv + tileOffset);\n      vec2 cellCenter = vec2(.5 + 1e-4);\n      cellCenter += spreading * cos(time + TWO_PI * rand);\n      cellCenter -= .5;\n      cellCenter = rotate(cellCenter, randomR(vec2(rand.x, rand.y)) + .1 * time);\n      cellCenter += .5;\n      float dist = length(tileOffset + cellCenter - f_uv);\n      if (dist < minDist) {\n        minDist = dist;\n        randomizer = rand;\n      }\n    }\n  }\n\n  return vec3(minDist, randomizer);\n}\n\nvoid main() {\n\n  vec2 shape_uv = v_patternUV;\n  shape_uv *= 1.5;\n\n  const float firstFrameOffset = -10.;\n  float t = u_time + firstFrameOffset;\n\n  vec3 voronoi = voronoiShape(shape_uv, t) + 1e-4;\n\n  float radius = .25 * clamp(u_size, 0., 1.) - .5 * clamp(u_sizeRange, 0., 1.) * voronoi[2];\n  float dist = voronoi[0];\n  float edgeWidth = fwidth(dist);\n  float dots = 1. - smoothstep(radius - edgeWidth, radius + edgeWidth, dist);\n\n  float shape = voronoi[1];\n\n  float mixer = shape * (u_colorsCount - 1.);\n  mixer = (shape - .5 / u_colorsCount) * u_colorsCount;\n  float steps = max(1., u_stepsPerColor);\n\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  for (int i = 1; i < ${ dotOrbitMeta.maxColorCount }; i++) {\n    if (i >= int(u_colorsCount)) break;\n    float localT = clamp(mixer - float(i - 1), 0.0, 1.0);\n    localT = round(localT * steps) / steps;\n    vec4 c = u_colors[i];\n    c.rgb *= c.a;\n    gradient = mix(gradient, c, localT);\n  }\n\n  if ((mixer < 0.) || (mixer > (u_colorsCount - 1.))) {\n    float localT = mixer + 1.;\n    if (mixer > (u_colorsCount - 1.)) {\n      localT = mixer - (u_colorsCount - 1.);\n    }\n    localT = round(localT * steps) / steps;\n    vec4 cFst = u_colors[0];\n    cFst.rgb *= cFst.a;\n    vec4 cLast = u_colors[int(u_colorsCount - 1.)];\n    cLast.rgb *= cLast.a;\n    gradient = mix(cLast, cFst, localT);\n  }\n\n  vec3 color = gradient.rgb * dots;\n  float opacity = gradient.a * dots;\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1. - opacity);\n  opacity = opacity + u_colorBack.a * (1. - opacity);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface DotOrbitUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_size: number;\n  u_sizeRange: number;\n  u_spreading: number;\n  u_stepsPerColor: number;\n  u_noiseTexture?: HTMLImageElement;\n}\n\nexport interface DotOrbitParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colors?: string[];\n  size?: number;\n  sizeRange?: number;\n  spreading?: number;\n  stepsPerColor?: number;\n}\n", "import { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, simplexNoise } from '../shader-utils.js';\n\n/**\n * Static grid pattern made of circles, diamonds, squares or triangles.\n *\n * Fragment shader uniforms:\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colorFill (vec4): Shape fill color in RGBA\n * - u_colorStroke (vec4): Shape stroke color in RGBA\n * - u_dotSize (float): Base size of each shape in pixels (1 to 100)\n * - u_gapX (float): Pattern horizontal spacing in pixels (2 to 500)\n * - u_gapY (float): Pattern vertical spacing in pixels (2 to 500)\n * - u_strokeWidth (float): Outline stroke width in pixels (0 to 50)\n * - u_sizeRange (float): Random variation in shape size, 0 = uniform, higher = random up to base size (0 to 1)\n * - u_opacityRange (float): Random variation in shape opacity, 0 = opaque, higher = semi-transparent (0 to 1)\n * - u_shape (float): Shape type (0 = circle, 1 = diamond, 2 = square, 3 = triangle)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_patternUV (vec2): UV coordinates in pixels (scaled by 0.01 for precision), with scale, rotation and offset applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const dotGridFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colorFill;\nuniform vec4 u_colorStroke;\nuniform float u_dotSize;\nuniform float u_gapX;\nuniform float u_gapY;\nuniform float u_strokeWidth;\nuniform float u_sizeRange;\nuniform float u_opacityRange;\nuniform float u_shape;\n\nin vec2 v_patternUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ simplexNoise }\n\nfloat polygon(vec2 p, float N, float rot) {\n  float a = atan(p.x, p.y) + rot;\n  float r = TWO_PI / float(N);\n\n  return cos(floor(.5 + a / r) * r - a) * length(p);\n}\n\nvoid main() {\n\n  // x100 is a default multiplier between vertex and fragmant shaders\n  // we use it to avoid UV presision issues\n  vec2 shape_uv = 100. * v_patternUV;\n\n  vec2 gap = max(abs(vec2(u_gapX, u_gapY)), vec2(1e-6));\n  vec2 grid = fract(shape_uv / gap) + 1e-4;\n  vec2 grid_idx = floor(shape_uv / gap);\n  float sizeRandomizer = .5 + .8 * snoise(2. * vec2(grid_idx.x * 100., grid_idx.y));\n  float opacity_randomizer = .5 + .7 * snoise(2. * vec2(grid_idx.y, grid_idx.x));\n\n  vec2 center = vec2(0.5) - 1e-3;\n  vec2 p = (grid - center) * vec2(u_gapX, u_gapY);\n\n  float baseSize = u_dotSize * (1. - sizeRandomizer * u_sizeRange);\n  float strokeWidth = u_strokeWidth * (1. - sizeRandomizer * u_sizeRange);\n\n  float dist;\n  if (u_shape < 0.5) {\n    // Circle\n    dist = length(p);\n  } else if (u_shape < 1.5) {\n    // Diamond\n    strokeWidth *= 1.5;\n    dist = polygon(1.5 * p, 4., .25 * PI);\n  } else if (u_shape < 2.5) {\n    // Square\n    dist = polygon(1.03 * p, 4., 1e-3);\n  } else {\n    // Triangle\n    strokeWidth *= 1.5;\n    p = p * 2. - 1.;\n    p *= .9;\n    p.y = 1. - p.y;\n    p.y -= .75 * baseSize;\n    dist = polygon(p, 3., 1e-3);\n  }\n\n  float edgeWidth = fwidth(dist);\n  float shapeOuter = 1. - smoothstep(baseSize - edgeWidth, baseSize + edgeWidth, dist - strokeWidth);\n  float shapeInner = 1. - smoothstep(baseSize - edgeWidth, baseSize + edgeWidth, dist);\n  float stroke = shapeOuter - shapeInner;\n\n  float dotOpacity = max(0., 1. - opacity_randomizer * u_opacityRange);\n  stroke *= dotOpacity;\n  shapeInner *= dotOpacity;\n\n  stroke *= u_colorStroke.a;\n  shapeInner *= u_colorFill.a;\n\n  vec3 color = vec3(0.);\n  color += stroke * u_colorStroke.rgb;\n  color += shapeInner * u_colorFill.rgb;\n  color += (1. - shapeInner - stroke) * u_colorBack.rgb * u_colorBack.a;\n\n  float opacity = 0.;\n  opacity += stroke;\n  opacity += shapeInner;\n  opacity += (1. - opacity) * u_colorBack.a;\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface DotGridUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colorFill: [number, number, number, number];\n  u_colorStroke: [number, number, number, number];\n  u_dotSize: number;\n  u_gapX: number;\n  u_gapY: number;\n  u_strokeWidth: number;\n  u_sizeRange: number;\n  u_opacityRange: number;\n  u_shape: (typeof DotGridShapes)[DotGridShape];\n}\n\nexport interface DotGridParams extends ShaderSizingParams {\n  colorBack?: string;\n  colorFill?: string;\n  colorStroke?: string;\n  size?: number;\n  gapX?: number;\n  gapY?: number;\n  strokeWidth?: number;\n  sizeRange?: number;\n  opacityRange?: number;\n  shape?: DotGridShape;\n}\n\nexport const DotGridShapes = {\n  circle: 0,\n  diamond: 1,\n  square: 2,\n  triangle: 3,\n} as const;\n\nexport type DotGridShape = keyof typeof DotGridShapes;\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { simplexNoise, colorBandingFix } from '../shader-utils.js';\n\nexport const simplexNoiseMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n * A multi-color gradient mapped into smooth, animated curves built as a combination of 2 Simplex noises.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_scale (float): Overall zoom level, used for anti-aliasing calculations\n * - u_colors (vec4[]): Up to 10 base colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_stepsPerColor (float): Number of extra colors between base colors, 1 = N colors, 2 = 2\u00D7N, etc. (1 to 10)\n * - u_softness (float): Color transition sharpness, 0 = hard edge, 1 = smooth gradient (0 to 1)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_patternUV (vec2): UV coordinates for pattern with global sizing (rotation, scale, offset, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const simplexNoiseFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\nuniform float u_scale;\n\nuniform vec4 u_colors[${ simplexNoiseMeta.maxColorCount }];\nuniform float u_colorsCount;\nuniform float u_stepsPerColor;\nuniform float u_softness;\n\nin vec2 v_patternUV;\n\nout vec4 fragColor;\n\n${ simplexNoise }\n\nfloat getNoise(vec2 uv, float t) {\n  float noise = .5 * snoise(uv - vec2(0., .3 * t));\n  noise += .5 * snoise(2. * uv + vec2(0., .32 * t));\n\n  return noise;\n}\n\nfloat steppedSmooth(float m, float steps, float softness) {\n  float stepT = floor(m * steps) / steps;\n  float f = m * steps - floor(m * steps);\n  float fw = steps * fwidth(m);\n  float smoothed = smoothstep(.5 - softness, min(1., .5 + softness + fw), f);\n  return stepT + smoothed / steps;\n}\n\nvoid main() {\n  vec2 shape_uv = v_patternUV;\n  shape_uv *= .1;\n\n  float t = .2 * u_time;\n\n  float shape = .5 + .5 * getNoise(shape_uv, t);\n\n  bool u_extraSides = true;\n\n  float mixer = shape * (u_colorsCount - 1.);\n  if (u_extraSides == true) {\n    mixer = (shape - .5 / u_colorsCount) * u_colorsCount;\n  }\n\n  float steps = max(1., u_stepsPerColor);\n\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  for (int i = 1; i < ${ simplexNoiseMeta.maxColorCount }; i++) {\n    if (i >= int(u_colorsCount)) break;\n\n    float localM = clamp(mixer - float(i - 1), 0., 1.);\n    localM = steppedSmooth(localM, steps, .5 * u_softness);\n\n    vec4 c = u_colors[i];\n    c.rgb *= c.a;\n    gradient = mix(gradient, c, localM);\n  }\n\n  if (u_extraSides == true) {\n    if ((mixer < 0.) || (mixer > (u_colorsCount - 1.))) {\n      float localM = mixer + 1.;\n      if (mixer > (u_colorsCount - 1.)) {\n        localM = mixer - (u_colorsCount - 1.);\n      }\n      localM = steppedSmooth(localM, steps, .5 * u_softness);\n      vec4 cFst = u_colors[0];\n      cFst.rgb *= cFst.a;\n      vec4 cLast = u_colors[int(u_colorsCount - 1.)];\n      cLast.rgb *= cLast.a;\n      gradient = mix(cLast, cFst, localM);\n    }\n  }\n\n  vec3 color = gradient.rgb;\n  float opacity = gradient.a;\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface SimplexNoiseUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_stepsPerColor: number;\n  u_softness: number;\n}\n\nexport interface SimplexNoiseParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  stepsPerColor?: number;\n  softness?: number;\n}\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, textureRandomizerR, colorBandingFix } from '../shader-utils.js';\n\nexport const metaballsMeta = {\n  maxColorCount: 8,\n  maxBallsCount: 20,\n} as const;\n\n/**\n * Up to 20 colored gooey balls moving around the center and merging into smooth organic shapes.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colors (vec4[]): Up to 8 base colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_count (float): Number of balls (1 to 20)\n * - u_size (float): Size of the balls (0 to 1)\n * - u_noiseTexture (sampler2D): Pre-computed randomizer source texture\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_objectUV (vec2): Object box UV coordinates with global sizing (scale, rotation, offsets, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const metaballsFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform sampler2D u_noiseTexture;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${ metaballsMeta.maxColorCount }];\nuniform float u_colorsCount;\nuniform float u_size;\nuniform float u_sizeRange;\nuniform float u_count;\n\nin vec2 v_objectUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ textureRandomizerR }\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  vec2 p0 = vec2(i, 0.0);\n  vec2 p1 = vec2(i + 1.0, 0.0);\n  return mix(randomR(p0), randomR(p1), u);\n}\n\nfloat getBallShape(vec2 uv, vec2 c, float p) {\n  float s = .5 * length(uv - c);\n  s = 1. - clamp(s, 0., 1.);\n  s = pow(s, p);\n  return s;\n}\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n\n  shape_uv += .5;\n\n  const float firstFrameOffset = 2503.4;\n  float t = .2 * (u_time + firstFrameOffset);\n\n  vec3 totalColor = vec3(0.);\n  float totalShape = 0.;\n  float totalOpacity = 0.;\n\n  for (int i = 0; i < ${ metaballsMeta.maxBallsCount }; i++) {\n    if (i >= int(ceil(u_count))) break;\n\n    float idxFract = float(i) / float(${ metaballsMeta.maxBallsCount });\n    float angle = TWO_PI * idxFract;\n\n    float speed = 1. - .2 * idxFract;\n    float noiseX = noise(angle * 10. + float(i) + t * speed);\n    float noiseY = noise(angle * 20. + float(i) - t * speed);\n\n    vec2 pos = vec2(.5) + 1e-4 + .9 * (vec2(noiseX, noiseY) - .5);\n\n    int safeIndex = i % int(u_colorsCount + 0.5);\n    vec4 ballColor = u_colors[safeIndex];\n    ballColor.rgb *= ballColor.a;\n\n    float sizeFrac = 1.;\n    if (float(i) > floor(u_count - 1.)) {\n      sizeFrac *= fract(u_count);\n    }\n\n    float shape = getBallShape(shape_uv, pos, 45. - 30. * u_size * sizeFrac);\n    shape *= pow(u_size, .2);\n    shape = smoothstep(0., 1., shape);\n\n    totalColor += ballColor.rgb * shape;\n    totalShape += shape;\n    totalOpacity += ballColor.a * shape;\n  }\n\n  totalColor /= max(totalShape, 1e-4);\n  totalOpacity /= max(totalShape, 1e-4);\n\n  float edge_width = fwidth(totalShape);\n  float finalShape = smoothstep(.4, .4 + edge_width, totalShape);\n\n  vec3 color = totalColor * finalShape;\n  float opacity = totalOpacity * finalShape;\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1. - opacity);\n  opacity = opacity + u_colorBack.a * (1. - opacity);\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface MetaballsUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_count: number;\n  u_size: number;\n  u_noiseTexture?: HTMLImageElement;\n}\n\nexport interface MetaballsParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colors?: string[];\n  count?: number;\n  size?: number;\n}\n", "import type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, colorBandingFix, proceduralHash11, proceduralHash21 } from '../shader-utils.js';\n\n/**\n * Classic animated 3D Perlin noise with exposed controls.\n * Original algorithm: https://www.shadertoy.com/view/NlSGDz\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_colorFront (vec4): Foreground color in RGBA\n * - u_colorBack (vec4): Background color in RGBA\n * - u_proportion (float): Blend point between 2 colors, 0.5 = equal distribution (0 to 1)\n * - u_softness (float): Color transition sharpness, 0 = hard edge, 1 = smooth gradient (0 to 1)\n * - u_octaveCount (float): Perlin noise octaves number, more octaves for more detailed patterns (1 to 8)\n * - u_persistence (float): Roughness, falloff between octaves (0.3 to 1)\n * - u_lacunarity (float): Frequency step, defines how compressed the pattern is (1.5 to 10)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_patternUV (vec2): UV coordinates for pattern with global sizing (rotation, scale, offset, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const perlinNoiseFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colorFront;\nuniform vec4 u_colorBack;\nuniform float u_proportion;\nuniform float u_softness;\nuniform float u_octaveCount;\nuniform float u_persistence;\nuniform float u_lacunarity;\n\nin vec2 v_patternUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ proceduralHash11 }\n${ proceduralHash21 }\n\nfloat hash31(vec3 p) {\n  p = fract(p * 0.3183099) + 0.1;\n  p += dot(p, p.yzx + 19.19);\n  return fract(p.x * (p.y + p.z));\n}\n\nvec3 gradientPredefined(float hash) {\n  int idx = int(hash * 12.0) % 12;\n\n  if (idx == 0) return vec3(1, 1, 0);\n  if (idx == 1) return vec3(-1, 1, 0);\n  if (idx == 2) return vec3(1, -1, 0);\n  if (idx == 3) return vec3(-1, -1, 0);\n  if (idx == 4) return vec3(1, 0, 1);\n  if (idx == 5) return vec3(-1, 0, 1);\n  if (idx == 6) return vec3(1, 0, -1);\n  if (idx == 7) return vec3(-1, 0, -1);\n  if (idx == 8) return vec3(0, 1, 1);\n  if (idx == 9) return vec3(0, -1, 1);\n  if (idx == 10) return vec3(0, 1, -1);\n  return vec3(0, -1, -1);// idx == 11\n}\n\nfloat interpolateSafe(float v000, float v001, float v010, float v011,\nfloat v100, float v101, float v110, float v111, vec3 t) {\n  t = clamp(t, 0.0, 1.0);\n\n  float v00 = mix(v000, v100, t.x);\n  float v01 = mix(v001, v101, t.x);\n  float v10 = mix(v010, v110, t.x);\n  float v11 = mix(v011, v111, t.x);\n\n  float v0 = mix(v00, v10, t.y);\n  float v1 = mix(v01, v11, t.y);\n\n  return mix(v0, v1, t.z);\n}\n\nvec3 fade(vec3 t) {\n  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec3 position, float seed) {\n  position += vec3(seed * 127.1, seed * 311.7, seed * 74.7);\n\n  vec3 i = floor(position);\n  vec3 f = fract(position);\n  float h000 = hash31(i);\n  float h001 = hash31(i + vec3(0, 0, 1));\n  float h010 = hash31(i + vec3(0, 1, 0));\n  float h011 = hash31(i + vec3(0, 1, 1));\n  float h100 = hash31(i + vec3(1, 0, 0));\n  float h101 = hash31(i + vec3(1, 0, 1));\n  float h110 = hash31(i + vec3(1, 1, 0));\n  float h111 = hash31(i + vec3(1, 1, 1));\n  vec3 g000 = gradientPredefined(h000);\n  vec3 g001 = gradientPredefined(h001);\n  vec3 g010 = gradientPredefined(h010);\n  vec3 g011 = gradientPredefined(h011);\n  vec3 g100 = gradientPredefined(h100);\n  vec3 g101 = gradientPredefined(h101);\n  vec3 g110 = gradientPredefined(h110);\n  vec3 g111 = gradientPredefined(h111);\n  float v000 = dot(g000, f - vec3(0, 0, 0));\n  float v001 = dot(g001, f - vec3(0, 0, 1));\n  float v010 = dot(g010, f - vec3(0, 1, 0));\n  float v011 = dot(g011, f - vec3(0, 1, 1));\n  float v100 = dot(g100, f - vec3(1, 0, 0));\n  float v101 = dot(g101, f - vec3(1, 0, 1));\n  float v110 = dot(g110, f - vec3(1, 1, 0));\n  float v111 = dot(g111, f - vec3(1, 1, 1));\n\n  vec3 u = fade(f);\n  return interpolateSafe(v000, v001, v010, v011, v100, v101, v110, v111, u);\n}\n\nfloat p_noise(vec3 position, int octaveCount, float persistence, float lacunarity) {\n  float value = 0.0;\n  float amplitude = 1.0;\n  float frequency = 10.0;\n  float maxValue = 0.0;\n  octaveCount = clamp(octaveCount, 1, 8);\n\n  for (int i = 0; i < octaveCount; i++) {\n    float seed = float(i) * 0.7319;\n    value += perlinNoise(position * frequency, seed) * amplitude;\n    maxValue += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n  return value;\n}\n\nfloat get_max_amp(float persistence, float octaveCount) {\n  persistence = clamp(persistence * 0.999, 0.0, 0.999);\n  octaveCount = clamp(octaveCount, 1.0, 8.0);\n\n  if (abs(persistence - 1.0) < 0.001) {\n    return octaveCount;\n  }\n\n  return (1.0 - pow(persistence, octaveCount)) / max(1e-4, (1.0 - persistence));\n}\n\nvoid main() {\n  vec2 uv = v_patternUV;\n  uv *= .5;\n\n  float t = .2 * u_time;\n\n  vec3 p = vec3(uv, t);\n\n  float octCount = floor(u_octaveCount);\n  float noise = p_noise(p, int(octCount), u_persistence, u_lacunarity);\n\n  float max_amp = get_max_amp(u_persistence, octCount);\n  float noise_normalized = clamp((noise + max_amp) / max(1e-4, (2. * max_amp)) + (u_proportion - .5), 0.0, 1.0);\n  float sharpness = clamp(u_softness, 0., 1.);\n  float smooth_w = 0.5 * max(fwidth(noise_normalized), 0.001);\n  float res = smoothstep(\n  .5 - .5 * sharpness - smooth_w,\n  .5 + .5 * sharpness + smooth_w,\n  noise_normalized\n  );\n\n  vec3 fgColor = u_colorFront.rgb * u_colorFront.a;\n  float fgOpacity = u_colorFront.a;\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  float bgOpacity = u_colorBack.a;\n\n  vec3 color = fgColor * res;\n  float opacity = fgOpacity * res;\n\n  color += bgColor * (1. - opacity);\n  opacity += bgOpacity * (1. - opacity);\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface PerlinNoiseUniforms extends ShaderSizingUniforms {\n  u_colorFront: [number, number, number, number];\n  u_colorBack: [number, number, number, number];\n  u_proportion: number;\n  u_softness: number;\n  u_octaveCount: number;\n  u_persistence: number;\n  u_lacunarity: number;\n}\n\nexport interface PerlinNoiseParams extends ShaderSizingParams, ShaderMotionParams {\n  colorFront?: string;\n  colorBack?: string;\n  proportion?: number;\n  softness?: number;\n  octaveCount?: number;\n  persistence?: number;\n  lacunarity?: number;\n}\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, textureRandomizerGB } from '../shader-utils.js';\n\nexport const voronoiMeta = {\n  maxColorCount: 5,\n} as const;\n\n/**\n * Anti-aliased animated Voronoi pattern with smooth and customizable edges.\n *\n * Double-pass Voronoi pattern cell edges.\n * Original algorithm: https://www.shadertoy.com/view/ldl3W8\n *\n * Note: gaps can't be removed completely due to natural artifacts of Voronoi cells borders\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_scale (float): Overall zoom level, used for anti-aliasing calculations\n * - u_colors (vec4[]): Up to 5 base cell colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_stepsPerColor (float): Number of extra colors between base colors, 1 = N colors, 2 = 2\u00D7N, etc. (1 to 3)\n * - u_colorGlow (vec4): Color tint for radial inner shadow inside cells in RGBA, effective with glow > 0\n * - u_colorGap (vec4): Color used for cell borders/gaps in RGBA\n * - u_distortion (float): Strength of noise-driven displacement of cell centers (0 to 0.5)\n * - u_gap (float): Width of the border/gap between cells (0 to 0.1)\n * - u_glow (float): Strength of the radial inner shadow inside cells (0 to 1)\n * - u_noiseTexture (sampler2D): Pre-computed randomizer source texture\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_patternUV (vec2): UV coordinates for pattern with global sizing (rotation, scale, offset, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const voronoiFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform float u_scale;\n\nuniform sampler2D u_noiseTexture;\n\nuniform vec4 u_colors[${ voronoiMeta.maxColorCount }];\nuniform float u_colorsCount;\n\nuniform float u_stepsPerColor;\nuniform vec4 u_colorGlow;\nuniform vec4 u_colorGap;\nuniform float u_distortion;\nuniform float u_gap;\nuniform float u_glow;\n\nin vec2 v_patternUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ textureRandomizerGB }\n\nvec4 voronoi(vec2 x, float t) {\n  vec2 ip = floor(x);\n  vec2 fp = fract(x);\n\n  vec2 mg, mr;\n  float md = 8.;\n  float rand = 0.;\n\n  for (int j = -1; j <= 1; j++) {\n    for (int i = -1; i <= 1; i++) {\n      vec2 g = vec2(float(i), float(j));\n      vec2 o = randomGB(ip + g);\n      float raw_hash = o.x;\n      o = .5 + u_distortion * sin(t + TWO_PI * o);\n      vec2 r = g + o - fp;\n      float d = dot(r, r);\n\n      if (d < md) {\n        md = d;\n        mr = r;\n        mg = g;\n        rand = raw_hash;\n      }\n    }\n  }\n\n  md = 8.;\n  for (int j = -2; j <= 2; j++) {\n    for (int i = -2; i <= 2; i++) {\n      vec2 g = mg + vec2(float(i), float(j));\n      vec2 o = randomGB(ip + g);\n      o = .5 + u_distortion * sin(t + TWO_PI * o);\n      vec2 r = g + o - fp;\n      if (dot(mr - r, mr - r) > .00001) {\n        md = min(md, dot(.5 * (mr + r), normalize(r - mr)));\n      }\n    }\n  }\n\n  return vec4(md, mr, rand);\n}\n\nvoid main() {\n  vec2 shape_uv = v_patternUV;\n  shape_uv *= 1.25;\n\n  float t = u_time;\n\n  vec4 voronoiRes = voronoi(shape_uv, t);\n\n  float shape = clamp(voronoiRes.w, 0., 1.);\n  float mixer = shape * (u_colorsCount - 1.);\n  mixer = (shape - .5 / u_colorsCount) * u_colorsCount;\n  float steps = max(1., u_stepsPerColor);\n\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  for (int i = 1; i < ${ voronoiMeta.maxColorCount }; i++) {\n    if (i >= int(u_colorsCount)) break;\n    float localT = clamp(mixer - float(i - 1), 0.0, 1.0);\n    localT = round(localT * steps) / steps;\n    vec4 c = u_colors[i];\n    c.rgb *= c.a;\n    gradient = mix(gradient, c, localT);\n  }\n\n  if ((mixer < 0.) || (mixer > (u_colorsCount - 1.))) {\n    float localT = mixer + 1.;\n    if (mixer > (u_colorsCount - 1.)) {\n      localT = mixer - (u_colorsCount - 1.);\n    }\n    localT = round(localT * steps) / steps;\n    vec4 cFst = u_colors[0];\n    cFst.rgb *= cFst.a;\n    vec4 cLast = u_colors[int(u_colorsCount - 1.)];\n    cLast.rgb *= cLast.a;\n    gradient = mix(cLast, cFst, localT);\n  }\n\n  vec3 cellColor = gradient.rgb;\n  float cellOpacity = gradient.a;\n\n  float glows = length(voronoiRes.yz * u_glow);\n  glows = pow(glows, 1.5);\n\n  vec3 color = mix(cellColor, u_colorGlow.rgb * u_colorGlow.a, u_colorGlow.a * glows);\n  float opacity = cellOpacity + u_colorGlow.a * glows;\n\n  float edge = voronoiRes.x;\n  float smoothEdge = .02 / (2. * u_scale) * (1. + .5 * u_gap);\n  edge = smoothstep(u_gap - smoothEdge, u_gap + smoothEdge, edge);\n\n  color = mix(u_colorGap.rgb * u_colorGap.a, color, edge);\n  opacity = mix(u_colorGap.a, opacity, edge);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface VoronoiUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_stepsPerColor: number;\n  u_colorGap: [number, number, number, number];\n  u_colorGlow: [number, number, number, number];\n  u_distortion: number;\n  u_gap: number;\n  u_glow: number;\n  u_noiseTexture?: HTMLImageElement;\n}\n\nexport interface VoronoiParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  stepsPerColor?: number;\n  colorGap?: string;\n  colorGlow?: string;\n  distortion?: number;\n  gap?: number;\n  glow?: number;\n}\n", "import { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI } from '../shader-utils.js';\n\n/**\n * Static line pattern configurable into textures ranging from sharp zigzags to smooth flowing waves.\n *\n * Fragment shader uniforms:\n * - u_colorFront (vec4): Foreground color in RGBA\n * - u_colorBack (vec4): Background color in RGBA\n * - u_shape (float): Line shape, 0 = zigzag, 1 = sine, 2-3 = irregular waves, fractional values morph between shapes (0 to 3)\n * - u_amplitude (float): Wave amplitude (0 to 1)\n * - u_frequency (float): Wave frequency (0 to 2)\n * - u_spacing (float): Space between every two wavy lines (0 to 2)\n * - u_proportion (float): Blend point between front and back colors, 0.5 = equal distribution (0 to 1)\n * - u_softness (float): Color transition sharpness, 0 = hard edge, 1 = smooth gradient (0 to 1)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_patternUV (vec2): UV coordinates for pattern with global sizing (rotation, scale, offset, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const wavesFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform vec4 u_colorFront;\nuniform vec4 u_colorBack;\nuniform float u_shape;\nuniform float u_frequency;\nuniform float u_amplitude;\nuniform float u_spacing;\nuniform float u_proportion;\nuniform float u_softness;\n\nin vec2 v_patternUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n\nvoid main() {\n  vec2 shape_uv = v_patternUV;\n  shape_uv *= 4.;\n\n  float wave = .5 * cos(shape_uv.x * u_frequency * TWO_PI);\n  float zigzag = 2. * abs(fract(shape_uv.x * u_frequency) - .5);\n  float irregular = sin(shape_uv.x * .25 * u_frequency * TWO_PI) * cos(shape_uv.x * u_frequency * TWO_PI);\n  float irregular2 = .75 * (sin(shape_uv.x * u_frequency * TWO_PI) + .5 * cos(shape_uv.x * .5 * u_frequency * TWO_PI));\n\n  float offset = mix(zigzag, wave, smoothstep(0., 1., u_shape));\n  offset = mix(offset, irregular, smoothstep(1., 2., u_shape));\n  offset = mix(offset, irregular2, smoothstep(2., 3., u_shape));\n  offset *= 2. * u_amplitude;\n\n  float spacing = (.001 + u_spacing);\n  float shape = .5 + .5 * sin((shape_uv.y + offset) * PI / spacing);\n\n  float aa = .0001 + fwidth(shape);\n  float dc = 1. - clamp(u_proportion, 0., 1.);\n  float e0 = dc - u_softness - aa;\n  float e1 = dc + u_softness + aa;\n  float res = smoothstep(min(e0, e1), max(e0, e1), shape);\n\n  vec3 fgColor = u_colorFront.rgb * u_colorFront.a;\n  float fgOpacity = u_colorFront.a;\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  float bgOpacity = u_colorBack.a;\n\n  vec3 color = fgColor * res;\n  float opacity = fgOpacity * res;\n\n  color += bgColor * (1. - opacity);\n  opacity += bgOpacity * (1. - opacity);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface WavesUniforms extends ShaderSizingUniforms {\n  u_colorFront: [number, number, number, number];\n  u_colorBack: [number, number, number, number];\n  u_shape: number;\n  u_frequency: number;\n  u_amplitude: number;\n  u_spacing: number;\n  u_proportion: number;\n  u_softness: number;\n}\n\nexport interface WavesParams extends ShaderSizingParams {\n  colorFront?: string;\n  colorBack?: string;\n  rotation?: number;\n  shape?: number;\n  frequency?: number;\n  amplitude?: number;\n  spacing?: number;\n  proportion?: number;\n  softness?: number;\n}\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, rotation2, colorBandingFix } from '../shader-utils.js';\n\nexport const warpMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n * Animated color fields warped by noise and swirls, applied over base patterns\n * (checks, stripes, or split edge). Blends up to 10 colors with adjustable distribution,\n * softness, distortion, and swirl. Great for fluid, smoky, or marbled effects.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_scale (float): Overall zoom level, used for anti-aliasing calculations\n * - u_colors (vec4[]): Up to 10 gradient colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_proportion (float): Blend point between colors, 0.5 = equal distribution (0 to 1)\n * - u_softness (float): Color transition sharpness, 0 = hard edge, 1 = smooth gradient (0 to 1)\n * - u_shape (float): Base pattern type (0 = checks, 1 = stripes, 2 = edge)\n * - u_shapeScale (float): Zoom level of the base pattern (0 to 1)\n * - u_distortion (float): Strength of noise-based distortion (0 to 1)\n * - u_swirl (float): Strength of the swirl distortion (0 to 1)\n * - u_swirlIterations (float): Number of layered swirl passes, effective with swirl > 0 (0 to 20)\n * - u_noiseTexture (sampler2D): Pre-computed randomizer source texture\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_patternUV (vec2): UV coordinates for pattern with global sizing (rotation, scale, offset, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const warpFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\nuniform float u_scale;\n\nuniform sampler2D u_noiseTexture;\n\nuniform vec4 u_colors[${ warpMeta.maxColorCount }];\nuniform float u_colorsCount;\nuniform float u_proportion;\nuniform float u_softness;\nuniform float u_shape;\nuniform float u_shapeScale;\nuniform float u_distortion;\nuniform float u_swirl;\nuniform float u_swirlIterations;\n\nin vec2 v_patternUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ rotation2 }\nfloat randomG(vec2 p) {\n  vec2 uv = floor(p) / 100. + .5;\n  return texture(u_noiseTexture, fract(uv)).g;\n}\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = randomG(i);\n  float b = randomG(i + vec2(1.0, 0.0));\n  float c = randomG(i + vec2(0.0, 1.0));\n  float d = randomG(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\n\nvoid main() {\n  vec2 uv = v_patternUV;\n  uv *= .5;\n\n  const float firstFrameOffset = 118.;\n  float t = 0.0625 * (u_time + firstFrameOffset);\n\n  float n1 = valueNoise(uv * 1. + t);\n  float n2 = valueNoise(uv * 2. - t);\n  float angle = n1 * TWO_PI;\n  uv.x += 4. * u_distortion * n2 * cos(angle);\n  uv.y += 4. * u_distortion * n2 * sin(angle);\n\n  float swirl = u_swirl;\n  for (int i = 1; i <= 20; i++) {\n    if (i >= int(u_swirlIterations)) break;\n    float iFloat = float(i);\n    //    swirl *= (1. - smoothstep(.0, .25, length(fwidth(uv))));\n    uv.x += swirl / iFloat * cos(t + iFloat * 1.5 * uv.y);\n    uv.y += swirl / iFloat * cos(t + iFloat * 1. * uv.x);\n  }\n\n  float proportion = clamp(u_proportion, 0., 1.);\n\n  float shape = 0.;\n  if (u_shape < .5) {\n    vec2 checksShape_uv = uv * (.5 + 3.5 * u_shapeScale);\n    shape = .5 + .5 * sin(checksShape_uv.x) * cos(checksShape_uv.y);\n    shape += .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);\n  } else if (u_shape < 1.5) {\n    vec2 stripesShape_uv = uv * (2. * u_shapeScale);\n    float f = fract(stripesShape_uv.y);\n    shape = smoothstep(.0, .55, f) * (1.0 - smoothstep(.45, 1., f));\n    shape += .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);\n  } else {\n    float shapeScaling = 5. * (1. - u_shapeScale);\n    float e0 = 0.45 - shapeScaling;\n    float e1 = 0.55 + shapeScaling;\n    shape = smoothstep(min(e0, e1), max(e0, e1), 1.0 - uv.y + 0.3 * (proportion - 0.5));\n  }\n\n  float mixer = shape * (u_colorsCount - 1.);\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  float aa = fwidth(shape);\n  for (int i = 1; i < ${ warpMeta.maxColorCount }; i++) {\n    if (i >= int(u_colorsCount)) break;\n    float m = clamp(mixer - float(i - 1), 0.0, 1.0);\n\n    float localMixerStart = floor(m);\n    float softness = .5 * u_softness + fwidth(m);\n    float smoothed = smoothstep(max(0., .5 - softness - aa), min(1., .5 + softness + aa), m - localMixerStart);\n    float stepped = localMixerStart + smoothed;\n\n    m = mix(stepped, m, u_softness);\n\n    vec4 c = u_colors[i];\n    c.rgb *= c.a;\n    gradient = mix(gradient, c, m);\n  }\n\n  vec3 color = gradient.rgb;\n  float opacity = gradient.a;\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface WarpUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_proportion: number;\n  u_softness: number;\n  u_shape: (typeof WarpPatterns)[WarpPattern];\n  u_shapeScale: number;\n  u_distortion: number;\n  u_swirl: number;\n  u_swirlIterations: number;\n  u_noiseTexture?: HTMLImageElement;\n}\n\nexport interface WarpParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  rotation?: number;\n  proportion?: number;\n  softness?: number;\n  shape?: WarpPattern;\n  shapeScale?: number;\n  distortion?: number;\n  swirl?: number;\n  swirlIterations?: number;\n}\n\nexport const WarpPatterns = {\n  checks: 0,\n  stripes: 1,\n  edge: 2,\n} as const;\n\nexport type WarpPattern = keyof typeof WarpPatterns;\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, rotation2, textureRandomizerR, colorBandingFix, proceduralHash11 } from '../shader-utils.js';\n\nexport const godRaysMeta = {\n  maxColorCount: 5,\n} as const;\n\n/**\n * Animated rays of light radiating from the center, blended with up to 5 colors.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colorBloom (vec4): Color overlay blended with the rays in RGBA\n * - u_colors (vec4[]): Up to 5 ray colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_bloom (float): Strength of the bloom/overlay effect, 0 = alpha blend, 1 = additive blend (0 to 1)\n * - u_intensity (float): Visibility/strength of the rays (0 to 1)\n * - u_density (float): The number of rays (0 to 1)\n * - u_spotty (float): The length of the rays, higher = more spots/shorter rays (0 to 1)\n * - u_midSize (float): Size of the circular glow shape in the center (0 to 1)\n * - u_midIntensity (float): Brightness/intensity of the central glow (0 to 1)\n * - u_noiseTexture (sampler2D): Pre-computed randomizer source texture\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_objectUV (vec2): Object box UV coordinates with global sizing (scale, rotation, offsets, etc) applied\n *\n * The rays are adjustable by size, density, brightness and center glow.\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const godRaysFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform sampler2D u_noiseTexture;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colorBloom;\nuniform vec4 u_colors[${ godRaysMeta.maxColorCount }];\nuniform float u_colorsCount;\n\nuniform float u_density;\nuniform float u_spotty;\nuniform float u_midSize;\nuniform float u_midIntensity;\nuniform float u_intensity;\nuniform float u_bloom;\n\nin vec2 v_objectUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ rotation2 }\n${ textureRandomizerR }\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = randomR(i);\n  float b = randomR(i + vec2(1.0, 0.0));\n  float c = randomR(i + vec2(0.0, 1.0));\n  float d = randomR(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\n${ proceduralHash11 }\n\nfloat raysShape(vec2 uv, float r, float freq, float intensity, float radius) {\n  float a = atan(uv.y, uv.x);\n  vec2 left = vec2(a * freq, r);\n  vec2 right = vec2(fract(a / TWO_PI) * TWO_PI * freq, r);\n  float n_left = pow(valueNoise(left), intensity);\n  float n_right = pow(valueNoise(right), intensity);\n  float shape = mix(n_right, n_left, smoothstep(-.15, .15, uv.x));\n  return shape;\n}\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n\n  float t = .2 * u_time;\n\n  float radius = length(shape_uv);\n  float spots = 6.5 * abs(u_spotty);\n\n  float intensity = 4. - 3. * clamp(u_intensity, 0., 1.);\n\n  float delta = 1. - smoothstep(0., 1., radius);\n\n  float midSize = 10. * abs(u_midSize);\n  float ms_lo = 0.02 * midSize;\n  float ms_hi = max(midSize, 1e-6);\n  float middleShape = pow(u_midIntensity, 0.3) * (1. - smoothstep(ms_lo, ms_hi, 3.0 * radius));\n  middleShape = pow(middleShape, 5.0);\n\n  vec3 accumColor = vec3(0.0);\n  float accumAlpha = 0.0;\n\n  for (int i = 0; i < ${ godRaysMeta.maxColorCount }; i++) {\n    if (i >= int(u_colorsCount)) break;\n\n    vec2 rotatedUV = rotate(shape_uv, float(i) + 1.0);\n\n    float r1 = radius * (1.0 + 0.4 * float(i)) - 3.0 * t;\n    float r2 = 0.5 * radius * (1.0 + spots) - 2.0 * t;\n    float density = 6. * u_density + step(.5, u_density) * pow(4.5 * (u_density - .5), 4.);\n    float f = mix(1.0, 3.0 + 0.5 * float(i), hash11(float(i) * 15.)) * density;\n\n    float ray = raysShape(rotatedUV, r1, 5.0 * f, intensity, radius);\n    ray *= raysShape(rotatedUV, r2, 4.0 * f, intensity, radius);\n    ray += (1. + 4. * ray) * middleShape;\n    ray = clamp(ray, 0.0, 1.0);\n\n    float srcAlpha = u_colors[i].a * ray;\n    vec3 srcColor = u_colors[i].rgb * srcAlpha;\n\n    vec3 alphaBlendColor = accumColor + (1.0 - accumAlpha) * srcColor;\n    float alphaBlendAlpha = accumAlpha + (1.0 - accumAlpha) * srcAlpha;\n\n    vec3 addBlendColor = accumColor + srcColor;\n    float addBlendAlpha = accumAlpha + srcAlpha;\n\n    accumColor = mix(alphaBlendColor, addBlendColor, u_bloom);\n    accumAlpha = mix(alphaBlendAlpha, addBlendAlpha, u_bloom);\n  }\n\n  float overlayAlpha = u_colorBloom.a;\n  vec3 overlayColor = u_colorBloom.rgb * overlayAlpha;\n\n  vec3 colorWithOverlay = accumColor + accumAlpha * overlayColor;\n  accumColor = mix(accumColor, colorWithOverlay, u_bloom);\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n\n  vec3 color = accumColor + (1. - accumAlpha) * bgColor;\n  float opacity = accumAlpha + (1. - accumAlpha) * u_colorBack.a;\n  color = clamp(color, 0., 1.);\n  opacity = clamp(opacity, 0., 1.);\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface GodRaysUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colorBloom: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_spotty: number;\n  u_midSize: number;\n  u_midIntensity: number;\n  u_density: number;\n  u_intensity: number;\n  u_bloom: number;\n  u_noiseTexture?: HTMLImageElement;\n}\n\nexport interface GodRaysParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colorBloom?: string;\n  colors?: string[];\n  spotty?: number;\n  midSize?: number;\n  midIntensity?: number;\n  density?: number;\n  intensity?: number;\n  bloom?: number;\n}\n", "import type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { simplexNoise, declarePI, colorBandingFix } from '../shader-utils.js';\n\n/**\n * A single-colored animated spiral that morphs across a wide range of shapes -\n * from crisp, thin-lined geometry to flowing whirlpool forms and wavy, abstract rings.\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_patternUV (vec2): UV coordinates in pixels (scaled by 0.01 for precision), with rotation and offset applied\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colorFront (vec4): Foreground (ink) color in RGBA\n * - u_density (float): Spacing falloff simulating perspective, 0 = flat spiral (0 to 1)\n * - u_distortion (float): Power of shape distortion applied along the spiral (0 to 1)\n * - u_strokeWidth (float): Thickness of spiral curve (0 to 1)\n * - u_strokeTaper (float): How much stroke loses width away from center, 0 = full visibility (0 to 1)\n * - u_strokeCap (float): Extra stroke width at the center, no effect with strokeWidth = 0.5 (0 to 1)\n * - u_noise (float): Noise distortion applied over the canvas, no effect with noiseFrequency = 0 (0 to 1)\n * - u_noiseFrequency (float): Noise frequency, no effect with noise = 0 (0 to 1)\n * - u_softness (float): Color transition sharpness, 0 = hard edge, 1 = smooth gradient (0 to 1)\n *\n */\n\n// language=GLSL\nexport const spiralFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colorFront;\nuniform float u_density;\nuniform float u_distortion;\nuniform float u_strokeWidth;\nuniform float u_strokeCap;\nuniform float u_strokeTaper;\nuniform float u_noise;\nuniform float u_noiseFrequency;\nuniform float u_softness;\n\nin vec2 v_patternUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ simplexNoise }\n\nvoid main() {\n  vec2 uv = 2. * v_patternUV;\n\n  float t = u_time;\n  float l = length(uv);\n  float density = clamp(u_density, 0., 1.);\n  l = pow(max(l, 1e-6), density);\n  float angle = atan(uv.y, uv.x) - t;\n  float angleNormalised = angle / TWO_PI;\n\n  angleNormalised += .125 * u_noise * snoise(16. * pow(u_noiseFrequency, 3.) * uv);\n\n  float offset = l + angleNormalised;\n  offset -= u_distortion * (sin(4. * l - .5 * t) * cos(PI + l + .5 * t));\n  float stripe = fract(offset);\n\n  float shape = 2. * abs(stripe - .5);\n  float width = 1. - clamp(u_strokeWidth, .005 * u_strokeTaper, 1.);\n\n\n  float wCap = mix(width, (1. - stripe) * (1. - step(.5, stripe)), (1. - clamp(l, 0., 1.)));\n  width = mix(width, wCap, u_strokeCap);\n  width *= (1. - clamp(u_strokeTaper, 0., 1.) * l);\n\n  float fw = fwidth(offset);\n  float fwMult = 4. - 3. * (smoothstep(.05, .4, 2. * u_strokeWidth) * smoothstep(.05, .4, 2. * (1. - u_strokeWidth)));\n  float pixelSize = mix(fwMult * fw, fwidth(shape), clamp(fw, 0., 1.));\n  pixelSize = mix(pixelSize, .002, u_strokeCap * (1. - clamp(l, 0., 1.)));\n\n  float res = smoothstep(width - pixelSize - u_softness, width + pixelSize + u_softness, shape);\n\n  vec3 fgColor = u_colorFront.rgb * u_colorFront.a;\n  float fgOpacity = u_colorFront.a;\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  float bgOpacity = u_colorBack.a;\n\n  vec3 color = fgColor * res;\n  float opacity = fgOpacity * res;\n\n  color += bgColor * (1. - opacity);\n  opacity += bgOpacity * (1. - opacity);\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface SpiralUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colorFront: [number, number, number, number];\n  u_density: number;\n  u_distortion: number;\n  u_strokeWidth: number;\n  u_strokeTaper: number;\n  u_strokeCap: number;\n  u_noise: number;\n  u_noiseFrequency: number;\n  u_softness: number;\n}\n\nexport interface SpiralParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colorFront?: string;\n  density?: number;\n  distortion?: number;\n  strokeWidth?: number;\n  strokeTaper?: number;\n  strokeCap?: number;\n  noise?: number;\n  noiseFrequency?: number;\n  softness?: number;\n}\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { simplexNoise, declarePI, rotation2, colorBandingFix } from '../shader-utils.js';\n\nexport const swirlMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n * Animated bands of color twisting and bending, producing spirals, arcs, and flowing circular patterns.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colors (vec4[]): Up to 10 stripe colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_bandCount (float): Number of color bands, 0 = concentric ripples (0 to 15)\n * - u_twist (float): Vortex power, 0 = straight sectoral shapes (0 to 1)\n * - u_center (float): How far from the center the swirl colors begin to appear (0 to 1)\n * - u_proportion (float): Blend point between colors, 0.5 = equal distribution (0 to 1)\n * - u_softness (float): Color transition sharpness, 0 = hard edge, 1 = smooth gradient (0 to 1)\n * - u_noise (float): Strength of noise distortion, no effect with noiseFrequency = 0 (0 to 1)\n * - u_noiseFrequency (float): Noise frequency, no effect with noise = 0 (0 to 1)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_objectUV (vec2): Object box UV coordinates with global sizing (scale, rotation, offsets, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const swirlFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${ swirlMeta.maxColorCount }];\nuniform float u_colorsCount;\nuniform float u_bandCount;\nuniform float u_twist;\nuniform float u_center;\nuniform float u_proportion;\nuniform float u_softness;\nuniform float u_noise;\nuniform float u_noiseFrequency;\n\nin vec2 v_objectUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ simplexNoise }\n${ rotation2 }\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n\n  float l = length(shape_uv);\n  l = max(1e-4, l);\n\n  float t = u_time;\n\n  float angle = ceil(u_bandCount) * atan(shape_uv.y, shape_uv.x) + t;\n  float angle_norm = angle / TWO_PI;\n\n  float twist = 3. * clamp(u_twist, 0., 1.);\n  float offset = pow(l, -twist) + angle_norm;\n\n  float shape = fract(offset);\n  shape = 1. - abs(2. * shape - 1.);\n  shape += u_noise * snoise(15. * pow(u_noiseFrequency, 2.) * shape_uv);\n\n  float mid = smoothstep(.2, .2 + .8 * u_center, pow(l, twist));\n  shape = mix(0., shape, mid);\n\n  float proportion = clamp(u_proportion, 0., 1.);\n  float exponent = mix(.25, 1., proportion * 2.);\n  exponent = mix(exponent, 10., max(0., proportion * 2. - 1.));\n  shape = pow(shape, exponent);\n\n  float mixer = shape * u_colorsCount;\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n\n  float outerShape = 0.;\n  for (int i = 1; i < ${ swirlMeta.maxColorCount + 1 }; i++) {\n    if (i > int(u_colorsCount)) break;\n\n    float m = clamp(mixer - float(i - 1), 0., 1.);\n    float aa = fwidth(m);\n    m = smoothstep(.5 - .5 * u_softness - aa, .5 + .5 * u_softness + aa, m);\n\n    if (i == 1) {\n      outerShape = m;\n    }\n\n    vec4 c = u_colors[i - 1];\n    c.rgb *= c.a;\n    gradient = mix(gradient, c, m);\n  }\n\n  float midAA = .1 * fwidth(pow(l, -twist));\n  float outerMid = smoothstep(.2, .2 + midAA, pow(l, twist));\n  outerShape = mix(0., outerShape, outerMid);\n\n  vec3 color = gradient.rgb * outerShape;\n  float opacity = gradient.a * outerShape;\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1.0 - opacity);\n  opacity = opacity + u_colorBack.a * (1.0 - opacity);\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface SwirlUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_bandCount: number;\n  u_twist: number;\n  u_center: number;\n  u_proportion: number;\n  u_softness: number;\n  u_noiseFrequency: number;\n  u_noise: number;\n}\n\nexport interface SwirlParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colors?: string[];\n  bandCount?: number;\n  twist?: number;\n  center?: number;\n  proportion?: number;\n  softness?: number;\n  noiseFrequency?: number;\n  noise?: number;\n}\n", "import type { ShaderMotionParams } from '../shader-mount.js';\nimport {\n  type ShaderSizingParams,\n  type ShaderSizingUniforms,\n} from '../shader-sizing.js';\nimport { simplexNoise, declarePI, proceduralHash11, proceduralHash21 } from '../shader-utils.js';\n\n/**\n * Animated 2-color dithering over multiple pattern sources (noise, warp, dots, waves, ripple, swirl, sphere).\n *\n * SIZING NOTE: This shader performs sizing in the fragment shader (not vertex shader) to keep\n * u_pxSize in consistent actual pixels. The pixel grid is computed from gl_FragCoord before any\n * transforms, so scaling/rotating only affects the underlying pattern shape.\n * No vertex shader outputs (v_objectUV, v_patternUV, etc.) are used.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colorFront (vec4): Foreground (ink) color in RGBA\n * - u_shape (float): Shape pattern type (1 = simplex, 2 = warp, 3 = dots, 4 = wave, 5 = ripple, 6 = swirl, 7 = sphere)\n * - u_type (float): Dithering type (1 = random, 2 = 2x2 Bayer, 3 = 4x4 Bayer, 4 = 8x8 Bayer)\n * - u_pxSize (float): Pixel size of dithering grid (0.5 to 20)\n *\n * */\n\n// language=GLSL\nexport const ditheringFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform float u_pxSize;\nuniform vec4 u_colorBack;\nuniform vec4 u_colorFront;\nuniform float u_shape;\nuniform float u_type;\n\nout vec4 fragColor;\n\n${ simplexNoise }\n${ declarePI }\n${ proceduralHash11 }\n${ proceduralHash21 }\n\nfloat getSimplexNoise(vec2 uv, float t) {\n  float noise = .5 * snoise(uv - vec2(0., .3 * t));\n  noise += .5 * snoise(2. * uv + vec2(0., .32 * t));\n\n  return noise;\n}\n\nconst int bayer2x2[4] = int[4](0, 2, 3, 1);\nconst int bayer4x4[16] = int[16](\n0, 8, 2, 10,\n12, 4, 14, 6,\n3, 11, 1, 9,\n15, 7, 13, 5\n);\n\nconst int bayer8x8[64] = int[64](\n0, 32, 8, 40, 2, 34, 10, 42,\n48, 16, 56, 24, 50, 18, 58, 26,\n12, 44, 4, 36, 14, 46, 6, 38,\n60, 28, 52, 20, 62, 30, 54, 22,\n3, 35, 11, 43, 1, 33, 9, 41,\n51, 19, 59, 27, 49, 17, 57, 25,\n15, 47, 7, 39, 13, 45, 5, 37,\n63, 31, 55, 23, 61, 29, 53, 21\n);\n\nfloat getBayerValue(vec2 uv, int size) {\n  ivec2 pos = ivec2(fract(uv / float(size)) * float(size));\n  int index = pos.y * size + pos.x;\n\n  if (size == 2) {\n    return float(bayer2x2[index]) / 4.0;\n  } else if (size == 4) {\n    return float(bayer4x4[index]) / 16.0;\n  } else if (size == 8) {\n    return float(bayer8x8[index]) / 64.0;\n  }\n  return 0.0;\n}\n\n\nvoid main() {\n  float t = .5 * u_time;\n\n  float pxSize = u_pxSize * u_pixelRatio;\n  vec2 pxSizeUV = gl_FragCoord.xy - .5 * u_resolution;\n  pxSizeUV /= pxSize;\n  vec2 canvasPixelizedUV = (floor(pxSizeUV) + .5) * pxSize;\n  vec2 normalizedUV = canvasPixelizedUV / u_resolution;\n\n  vec2 ditheringNoiseUV = canvasPixelizedUV;\n  vec2 shapeUV = normalizedUV;\n\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  float r = u_rotation * PI / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 boxSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  \n  if (u_shape > 3.5) {\n    vec2 objectBoxSize = vec2(0.);\n    // fit = none\n    objectBoxSize.x = min(boxSize.x, boxSize.y);\n    if (u_fit == 1.) { // fit = contain\n      objectBoxSize.x = min(u_resolution.x, u_resolution.y);\n    } else if (u_fit == 2.) { // fit = cover\n      objectBoxSize.x = max(u_resolution.x, u_resolution.y);\n    }\n    objectBoxSize.y = objectBoxSize.x;\n    vec2 objectWorldScale = u_resolution.xy / objectBoxSize;\n\n    shapeUV *= objectWorldScale;\n    shapeUV += boxOrigin * (objectWorldScale - 1.);\n    shapeUV += vec2(-u_offsetX, u_offsetY);\n    shapeUV /= u_scale;\n    shapeUV = graphicRotation * shapeUV;\n  } else {\n    vec2 patternBoxSize = vec2(0.);\n    // fit = none\n    patternBoxSize.x = patternBoxRatio * min(boxSize.x / patternBoxRatio, boxSize.y);\n    float patternWorldNoFitBoxWidth = patternBoxSize.x;\n    if (u_fit == 1.) { // fit = contain\n      patternBoxSize.x = patternBoxRatio * min(u_resolution.x / patternBoxRatio, u_resolution.y);\n    } else if (u_fit == 2.) { // fit = cover\n      patternBoxSize.x = patternBoxRatio * max(u_resolution.x / patternBoxRatio, u_resolution.y);\n    }\n    patternBoxSize.y = patternBoxSize.x / patternBoxRatio;\n    vec2 patternWorldScale = u_resolution.xy / patternBoxSize;\n\n    shapeUV += vec2(-u_offsetX, u_offsetY) / patternWorldScale;\n    shapeUV += boxOrigin;\n    shapeUV -= boxOrigin / patternWorldScale;\n    shapeUV *= u_resolution.xy;\n    shapeUV /= u_pixelRatio;\n    if (u_fit > 0.) {\n      shapeUV *= (patternWorldNoFitBoxWidth / patternBoxSize.x);\n    }\n    shapeUV /= u_scale;\n    shapeUV = graphicRotation * shapeUV;\n    shapeUV += boxOrigin / patternWorldScale;\n    shapeUV -= boxOrigin;\n    shapeUV += .5;\n  }\n\n  float shape = 0.;\n  if (u_shape < 1.5) {\n    // Simplex noise\n    shapeUV *= .001;\n\n    shape = 0.5 + 0.5 * getSimplexNoise(shapeUV, t);\n    shape = smoothstep(0.3, 0.9, shape);\n\n  } else if (u_shape < 2.5) {\n    // Warp\n    shapeUV *= .003;\n\n    for (float i = 1.0; i < 6.0; i++) {\n      shapeUV.x += 0.6 / i * cos(i * 2.5 * shapeUV.y + t);\n      shapeUV.y += 0.6 / i * cos(i * 1.5 * shapeUV.x + t);\n    }\n\n    shape = .15 / max(0.001, abs(sin(t - shapeUV.y - shapeUV.x)));\n    shape = smoothstep(0.02, 1., shape);\n\n  } else if (u_shape < 3.5) {\n    // Dots\n    shapeUV *= .05;\n\n    float stripeIdx = floor(2. * shapeUV.x / TWO_PI);\n    float rand = hash11(stripeIdx * 10.);\n    rand = sign(rand - .5) * pow(.1 + abs(rand), .4);\n    shape = sin(shapeUV.x) * cos(shapeUV.y - 5. * rand * t);\n    shape = pow(abs(shape), 6.);\n\n  } else if (u_shape < 4.5) {\n    // Sine wave\n    shapeUV *= 4.;\n\n    float wave = cos(.5 * shapeUV.x - 2. * t) * sin(1.5 * shapeUV.x + t) * (.75 + .25 * cos(3. * t));\n    shape = 1. - smoothstep(-1., 1., shapeUV.y + wave);\n\n  } else if (u_shape < 5.5) {\n    // Ripple\n\n    float dist = length(shapeUV);\n    float waves = sin(pow(dist, 1.7) * 7. - 3. * t) * .5 + .5;\n    shape = waves;\n\n  } else if (u_shape < 6.5) {\n    // Swirl\n\n    float l = length(shapeUV);\n    float angle = 6. * atan(shapeUV.y, shapeUV.x) + 4. * t;\n    float twist = 1.2;\n    float offset = 1. / pow(max(l, 1e-6), twist) + angle / TWO_PI;\n    float mid = smoothstep(0., 1., pow(l, twist));\n    shape = mix(0., fract(offset), mid);\n\n  } else {\n    // Sphere\n    shapeUV *= 2.;\n\n    float d = 1. - pow(length(shapeUV), 2.);\n    vec3 pos = vec3(shapeUV, sqrt(max(0., d)));\n    vec3 lightPos = normalize(vec3(cos(1.5 * t), .8, sin(1.25 * t)));\n    shape = .5 + .5 * dot(lightPos, pos);\n    shape *= step(0., d);\n  }\n\n\n  int type = int(floor(u_type));\n  float dithering = 0.0;\n\n  switch (type) {\n    case 1: {\n      dithering = step(hash21(ditheringNoiseUV), shape);\n    } break;\n    case 2:\n    dithering = getBayerValue(pxSizeUV, 2);\n    break;\n    case 3:\n    dithering = getBayerValue(pxSizeUV, 4);\n    break;\n    default :\n    dithering = getBayerValue(pxSizeUV, 8);\n    break;\n  }\n\n  dithering -= .5;\n  float res = step(.5, shape + dithering);\n\n  vec3 fgColor = u_colorFront.rgb * u_colorFront.a;\n  float fgOpacity = u_colorFront.a;\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  float bgOpacity = u_colorBack.a;\n\n  vec3 color = fgColor * res;\n  float opacity = fgOpacity * res;\n\n  color += bgColor * (1. - opacity);\n  opacity += bgOpacity * (1. - opacity);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface DitheringUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colorFront: [number, number, number, number];\n  u_shape: (typeof DitheringShapes)[DitheringShape];\n  u_type: (typeof DitheringTypes)[DitheringType];\n  u_pxSize: number;\n}\n\nexport interface DitheringParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colorFront?: string;\n  shape?: DitheringShape;\n  type?: DitheringType;\n  size?: number;\n}\n\nexport const DitheringShapes = {\n  simplex: 1,\n  warp: 2,\n  dots: 3,\n  wave: 4,\n  ripple: 5,\n  swirl: 6,\n  sphere: 7,\n} as const;\n\nexport type DitheringShape = keyof typeof DitheringShapes;\n\nexport const DitheringTypes = {\n  'random': 1,\n  '2x2': 2,\n  '4x4': 3,\n  '8x8': 4,\n} as const;\n\nexport type DitheringType = keyof typeof DitheringTypes;\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport {\n  type ShaderSizingParams,\n  type ShaderSizingUniforms,\n} from '../shader-sizing.js';\nimport {\n  simplexNoise,\n  declarePI,\n  rotation2,\n  textureRandomizerR,\n  proceduralHash11,\n} from '../shader-utils.js';\n\nexport const grainGradientMeta = {\n  maxColorCount: 7,\n} as const;\n\n/**\n * Multi-color gradients with grainy, noise-textured distortion available in 7 animated abstract forms.\n *\n * Note: grains are calculated using gl_FragCoord & u_resolution, meaning grains don't react to scaling and fit\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning (0 to 1)\n * - u_originY (float): Reference point for positioning (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic\n * - u_worldHeight (float): Virtual height of the graphic\n * - u_fit (float): Fit mode (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level (0.01 to 4)\n * - u_rotation (float): Rotation angle in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset (-1 to 1)\n * - u_offsetY (float): Vertical offset (-1 to 1)\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colors (vec4[]): Up to 7 gradient colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_softness (float): Color transition sharpness, 0 = hard edge, 1 = smooth gradient (0 to 1)\n * - u_intensity (float): Distortion between color bands (0 to 1)\n * - u_noise (float): Grainy noise overlay (0 to 1)\n * - u_shape (float): Shape type (1 = wave, 2 = dots, 3 = truchet, 4 = corners, 5 = ripple, 6 = blob, 7 = sphere)\n * - u_noiseTexture (sampler2D): Pre-computed randomizer source texture\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_objectUV (vec2): Object box UV coordinates with global sizing (scale, rotation, offsets, etc) applied (used for shapes 4-7)\n * - v_objectBoxSize (vec2): Size of the object bounding box in pixels\n * - v_patternUV (vec2): UV coordinates for pattern with global sizing (rotation, scale, offset, etc) applied (used for shapes 1-3)\n * - v_patternBoxSize (vec2): Size of the pattern bounding box in pixels\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const grainGradientFragmentShader: string = `#version 300 es\nprecision lowp float;\n\nuniform mediump float u_time;\nuniform mediump vec2 u_resolution;\nuniform mediump float u_pixelRatio;\n\nuniform sampler2D u_noiseTexture;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${ grainGradientMeta.maxColorCount }];\nuniform float u_colorsCount;\nuniform float u_softness;\nuniform float u_intensity;\nuniform float u_noise;\nuniform float u_shape;\n\nuniform mediump float u_originX;\nuniform mediump float u_originY;\nuniform mediump float u_worldWidth;\nuniform mediump float u_worldHeight;\nuniform mediump float u_fit;\n\nuniform mediump float u_scale;\nuniform mediump float u_rotation;\nuniform mediump float u_offsetX;\nuniform mediump float u_offsetY;\n\nin vec2 v_objectUV;\nin vec2 v_patternUV;\nin vec2 v_objectBoxSize;\nin vec2 v_patternBoxSize;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ simplexNoise }\n${ rotation2 }\n${ textureRandomizerR }\n\nfloat valueNoiseR(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = randomR(i);\n  float b = randomR(i + vec2(1.0, 0.0));\n  float c = randomR(i + vec2(0.0, 1.0));\n  float d = randomR(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\nvec4 fbmR(vec2 n0, vec2 n1, vec2 n2, vec2 n3) {\n  float amplitude = 0.2;\n  vec4 total = vec4(0.);\n  for (int i = 0; i < 3; i++) {\n    n0 = rotate(n0, 0.3);\n    n1 = rotate(n1, 0.3);\n    n2 = rotate(n2, 0.3);\n    n3 = rotate(n3, 0.3);\n    total.x += valueNoiseR(n0) * amplitude;\n    total.y += valueNoiseR(n1) * amplitude;\n    total.z += valueNoiseR(n2) * amplitude;\n    total.z += valueNoiseR(n3) * amplitude;\n    n0 *= 1.99;\n    n1 *= 1.99;\n    n2 *= 1.99;\n    n3 *= 1.99;\n    amplitude *= 0.6;\n  }\n  return total;\n}\n\n${ proceduralHash11 }\n\nvec2 truchet(vec2 uv, float idx){\n  idx = fract(((idx - .5) * 2.));\n  if (idx > 0.75) {\n    uv = vec2(1.0) - uv;\n  } else if (idx > 0.5) {\n    uv = vec2(1.0 - uv.x, uv.y);\n  } else if (idx > 0.25) {\n    uv = 1.0 - vec2(1.0 - uv.x, uv.y);\n  }\n  return uv;\n}\n\nvoid main() {\n\n  const float firstFrameOffset = 7.;\n  float t = .1 * (u_time + firstFrameOffset);\n\n  vec2 shape_uv = vec2(0.);\n  vec2 grain_uv = vec2(0.);\n\n  float r = u_rotation * PI / 180.;\n  float cr = cos(r);\n  float sr = sin(r);\n  mat2 graphicRotation = mat2(cr, sr, -sr, cr);\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n  if (u_shape > 3.5) {\n    shape_uv = v_objectUV;\n    grain_uv = shape_uv;\n\n    // apply inverse transform to grain_uv so it respects the originXY\n    grain_uv = transpose(graphicRotation) * grain_uv;\n    grain_uv *= u_scale;\n    grain_uv -= graphicOffset;\n    grain_uv *= v_objectBoxSize;\n    grain_uv *= .7;\n  } else {\n    shape_uv = .5 * v_patternUV;\n    grain_uv = 100. * v_patternUV;\n\n    // apply inverse transform to grain_uv so it respects the originXY\n    grain_uv = transpose(graphicRotation) * grain_uv;\n    grain_uv *= u_scale;\n    if (u_fit > 0.) {\n      vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n      givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n      float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n      vec2 patternBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n      );\n      patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n      float patternBoxNoFitBoxWidth = patternBoxRatio * min(patternBoxGivenSize.x / patternBoxRatio, patternBoxGivenSize.y);\n      grain_uv /= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n    }\n    vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n    grain_uv -= graphicOffset / patternBoxScale;\n    grain_uv *= 1.6;\n  }\n\n\n  float shape = 0.;\n\n  if (u_shape < 1.5) {\n    // Sine wave\n\n    float wave = cos(.5 * shape_uv.x - 4. * t) * sin(1.5 * shape_uv.x + 2. * t) * (.75 + .25 * cos(6. * t));\n    shape = 1. - smoothstep(-1., 1., shape_uv.y + wave);\n\n  } else if (u_shape < 2.5) {\n    // Grid (dots)\n\n    float stripeIdx = floor(2. * shape_uv.x / TWO_PI);\n    float rand = hash11(stripeIdx * 100.);\n    rand = sign(rand - .5) * pow(4. * abs(rand), .3);\n    shape = sin(shape_uv.x) * cos(shape_uv.y - 5. * rand * t);\n    shape = pow(abs(shape), 4.);\n\n  } else if (u_shape < 3.5) {\n    // Truchet pattern\n\n    float n2 = valueNoiseR(shape_uv * .4 - 3.75 * t);\n    shape_uv.x += 10.;\n    shape_uv *= .6;\n\n    vec2 tile = truchet(fract(shape_uv), randomR(floor(shape_uv)));\n\n    float distance1 = length(tile);\n    float distance2 = length(tile - vec2(1.));\n\n    n2 -= .5;\n    n2 *= .1;\n    shape = smoothstep(.2, .55, distance1 + n2) * (1. - smoothstep(.45, .8, distance1 - n2));\n    shape += smoothstep(.2, .55, distance2 + n2) * (1. - smoothstep(.45, .8, distance2 - n2));\n\n    shape = pow(shape, 1.5);\n\n  } else if (u_shape < 4.5) {\n    // Corners\n\n    shape_uv *= .6;\n    vec2 outer = vec2(.5);\n\n    vec2 bl = smoothstep(vec2(0.), outer, shape_uv + vec2(.1 + .1 * sin(3. * t), .2 - .1 * sin(5.25 * t)));\n    vec2 tr = smoothstep(vec2(0.), outer, 1. - shape_uv);\n    shape = 1. - bl.x * bl.y * tr.x * tr.y;\n\n    shape_uv = -shape_uv;\n    bl = smoothstep(vec2(0.), outer, shape_uv + vec2(.1 + .1 * sin(3. * t), .2 - .1 * cos(5.25 * t)));\n    tr = smoothstep(vec2(0.), outer, 1. - shape_uv);\n    shape -= bl.x * bl.y * tr.x * tr.y;\n\n    shape = 1. - smoothstep(0., 1., shape);\n\n  } else if (u_shape < 5.5) {\n    // Ripple\n\n    shape_uv *= 2.;\n    float dist = length(.4 * shape_uv);\n    float waves = sin(pow(dist, 1.2) * 5. - 3. * t) * .5 + .5;\n    shape = waves;\n\n  } else if (u_shape < 6.5) {\n    // Blob\n\n    t *= 2.;\n\n    vec2 f1_traj = .25 * vec2(1.3 * sin(t), .2 + 1.3 * cos(.6 * t + 4.));\n    vec2 f2_traj = .2 * vec2(1.2 * sin(-t), 1.3 * sin(1.6 * t));\n    vec2 f3_traj = .25 * vec2(1.7 * cos(-.6 * t), cos(-1.6 * t));\n    vec2 f4_traj = .3 * vec2(1.4 * cos(.8 * t), 1.2 * sin(-.6 * t - 3.));\n\n    shape = .5 * pow(1. - clamp(0., 1., length(shape_uv + f1_traj)), 5.);\n    shape += .5 * pow(1. - clamp(0., 1., length(shape_uv + f2_traj)), 5.);\n    shape += .5 * pow(1. - clamp(0., 1., length(shape_uv + f3_traj)), 5.);\n    shape += .5 * pow(1. - clamp(0., 1., length(shape_uv + f4_traj)), 5.);\n\n    shape = smoothstep(.0, .9, shape);\n    float edge = smoothstep(.25, .3, shape);\n    shape = mix(.0, shape, edge);\n\n  } else {\n    // Sphere\n\n    shape_uv *= 2.;\n    float d = 1. - pow(length(shape_uv), 2.);\n    vec3 pos = vec3(shape_uv, sqrt(max(d, 0.)));\n    vec3 lightPos = normalize(vec3(cos(1.5 * t), .8, sin(1.25 * t)));\n    shape = .5 + .5 * dot(lightPos, pos);\n    shape *= step(0., d);\n  }\n\n  float baseNoise = snoise(grain_uv * .5);\n  vec4 fbmVals = fbmR(\n  .002 * grain_uv + 10.,\n  .003 * grain_uv,\n  .001 * grain_uv,\n  rotate(.4 * grain_uv, 2.)\n  );\n  float grainDist = baseNoise * snoise(grain_uv * .2) - fbmVals.x - fbmVals.y;\n  float rawNoise = .75 * baseNoise - fbmVals.w - fbmVals.z;\n  float noise = clamp(rawNoise, 0., 1.);\n\n  shape += u_intensity * 2. / u_colorsCount * (grainDist + .5);\n  shape += u_noise * 10. / u_colorsCount * noise;\n\n  float aa = fwidth(shape);\n\n  shape = clamp(shape - .5 / u_colorsCount, 0., 1.);\n  float totalShape = smoothstep(0., u_softness + 2. * aa, clamp(shape * u_colorsCount, 0., 1.));\n  float mixer = shape * (u_colorsCount - 1.);\n\n  int cntStop = int(u_colorsCount) - 1;\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  for (int i = 1; i < ${ grainGradientMeta.maxColorCount }; i++) {\n    if (i > cntStop) break;\n\n    float localT = clamp(mixer - float(i - 1), 0., 1.);\n    localT = smoothstep(.5 - .5 * u_softness - aa, .5 + .5 * u_softness + aa, localT);\n\n    vec4 c = u_colors[i];\n    c.rgb *= c.a;\n    gradient = mix(gradient, c, localT);\n  }\n\n  vec3 color = gradient.rgb * totalShape;\n  float opacity = gradient.a * totalShape;\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1.0 - opacity);\n  opacity = opacity + u_colorBack.a * (1.0 - opacity);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface GrainGradientUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_softness: number;\n  u_intensity: number;\n  u_noise: number;\n  u_shape: (typeof GrainGradientShapes)[GrainGradientShape];\n  u_noiseTexture?: HTMLImageElement;\n}\n\nexport interface GrainGradientParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colors?: string[];\n  softness?: number;\n  intensity?: number;\n  noise?: number;\n  shape?: GrainGradientShape;\n}\n\nexport const GrainGradientShapes = {\n  wave: 1,\n  dots: 2,\n  truchet: 3,\n  corners: 4,\n  ripple: 5,\n  blob: 6,\n  sphere: 7,\n};\n\nexport type GrainGradientShape = keyof typeof GrainGradientShapes;\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, textureRandomizerGB, colorBandingFix } from '../shader-utils.js';\n\nexport const pulsingBorderMeta = {\n  maxColorCount: 5,\n  maxSpots: 4,\n} as const;\n\n/**\n * Luminous trails of color merging into a glowing gradient contour.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colors (vec4[]): Up to 5 spot colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_roundness (float): Border radius (0 to 1)\n * - u_thickness (float): Border base width (0 to 1)\n * - u_softness (float): Border edge sharpness, 0 = hard edge, 1 = smooth gradient (0 to 1)\n * - u_marginLeft (float): Distance from the left edge to the effect (0 to 1)\n * - u_marginRight (float): Distance from the right edge to the effect (0 to 1)\n * - u_marginTop (float): Distance from the top edge to the effect (0 to 1)\n * - u_marginBottom (float): Distance from the bottom edge to the effect (0 to 1)\n * - u_aspectRatio (float): Aspect ratio mode (0 = auto, 1 = square)\n * - u_intensity (float): Thickness of individual color spots (0 to 1)\n * - u_bloom (float): Power of glow, 0 = normal blending, 1 = additive blending (0 to 1)\n * - u_spots (float): Number of spots added for each color (1 to 20)\n * - u_spotSize (float): Angular size of spots (0 to 1)\n * - u_pulse (float): Optional pulsing animation intensity (0 to 1)\n * - u_smoke (float): Optional noisy shape extending the border (0 to 1)\n * - u_smokeSize (float): Size of the smoke effect (0 to 1)\n * - u_noiseTexture (sampler2D): Pre-computed randomizer source texture\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_responsiveUV (vec2): Responsive UV coordinates that adapt to canvas aspect ratio\n * - v_responsiveBoxGivenSize (vec2): Given size of the responsive bounding box\n * - v_patternUV (vec2): UV coordinates for pattern with global sizing (rotation, scale, offset, etc) applied (used for smoke calculation)\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const pulsingBorderFragmentShader: string = `#version 300 es\nprecision lowp float;\n\nuniform float u_time;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${ pulsingBorderMeta.maxColorCount }];\nuniform float u_colorsCount;\nuniform float u_roundness;\nuniform float u_thickness;\nuniform float u_marginLeft;\nuniform float u_marginRight;\nuniform float u_marginTop;\nuniform float u_marginBottom;\nuniform float u_aspectRatio;\nuniform float u_softness;\nuniform float u_intensity;\nuniform float u_bloom;\nuniform float u_spotSize;\nuniform float u_spots;\nuniform float u_pulse;\nuniform float u_smoke;\nuniform float u_smokeSize;\n\nuniform sampler2D u_noiseTexture;\n\nin vec2 v_responsiveUV;\nin vec2 v_responsiveBoxGivenSize;\nin vec2 v_patternUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n\nfloat beat(float time) {\n  float first = pow(abs(sin(time * TWO_PI)), 10.);\n  float second = pow(abs(sin((time - .15) * TWO_PI)), 10.);\n\n  return clamp(first + 0.6 * second, 0.0, 1.0);\n}\n\nfloat sst(float edge0, float edge1, float x) {\n  return smoothstep(edge0, edge1, x);\n}\n\nfloat roundedBox(vec2 uv, vec2 halfSize, float distance, float cornerDistance, float thickness, float softness) {\n  float borderDistance = abs(distance);\n  float aa = 2. * fwidth(distance);\n  float border = 1. - sst(min(mix(thickness, -thickness, softness), thickness + aa), max(mix(thickness, -thickness, softness), thickness + aa), borderDistance);\n  float cornerFadeCircles = 0.;\n  cornerFadeCircles = mix(1., cornerFadeCircles, sst(0., 1., length((uv + halfSize) / thickness)));\n  cornerFadeCircles = mix(1., cornerFadeCircles, sst(0., 1., length((uv - vec2(-halfSize.x, halfSize.y)) / thickness)));\n  cornerFadeCircles = mix(1., cornerFadeCircles, sst(0., 1., length((uv - vec2(halfSize.x, -halfSize.y)) / thickness)));\n  cornerFadeCircles = mix(1., cornerFadeCircles, sst(0., 1., length((uv - halfSize) / thickness)));\n  aa = fwidth(cornerDistance);\n  float cornerFade = sst(0., mix(aa, thickness, softness), cornerDistance);\n  cornerFade *= cornerFadeCircles;\n  border += cornerFade;\n  return border;\n}\n\n${ textureRandomizerGB }\n\nfloat randomG(vec2 p) {\n  vec2 uv = floor(p) / 100. + .5;\n  return texture(u_noiseTexture, fract(uv)).g;\n}\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = randomG(i);\n  float b = randomG(i + vec2(1.0, 0.0));\n  float c = randomG(i + vec2(0.0, 1.0));\n  float d = randomG(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nvoid main() {\n  const float firstFrameOffset = 109.;\n  float t = 1.2 * (u_time + firstFrameOffset);\n\n  vec2 borderUV = v_responsiveUV;\n  float pulse = u_pulse * beat(.18 * u_time);\n\n  float canvasRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  vec2 halfSize = vec2(.5);\n  borderUV.x *= max(canvasRatio, 1.);\n  borderUV.y /= min(canvasRatio, 1.);\n  halfSize.x *= max(canvasRatio, 1.);\n  halfSize.y /= min(canvasRatio, 1.);\n\n  float mL = u_marginLeft;\n  float mR = u_marginRight;\n  float mT = u_marginTop;\n  float mB = u_marginBottom;\n  float mX = mL + mR;\n  float mY = mT + mB;\n\n  if (u_aspectRatio > 0.) {\n    float shapeRatio = canvasRatio * (1. - mX) / max(1. - mY, 1e-6);\n    float freeX = shapeRatio > 1. ? (1. - mX) * (1. - 1. / max(abs(shapeRatio), 1e-6)) : 0.;\n    float freeY = shapeRatio < 1. ? (1. - mY) * (1. - shapeRatio) : 0.;\n    mL += freeX * 0.5;\n    mR += freeX * 0.5;\n    mT += freeY * 0.5;\n    mB += freeY * 0.5;\n    mX = mL + mR;\n    mY = mT + mB;\n  }\n\n  float thickness = .5 * u_thickness * min(halfSize.x, halfSize.y);\n\n  halfSize.x *= (1. - mX);\n  halfSize.y *= (1. - mY);\n\n  vec2 centerShift = vec2(\n  (mL - mR) * max(canvasRatio, 1.) * 0.5,\n  (mB - mT) / min(canvasRatio, 1.) * 0.5\n  );\n\n  borderUV -= centerShift;\n  halfSize -= mix(thickness, 0., u_softness);\n\n  float radius = mix(0., min(halfSize.x, halfSize.y), u_roundness);\n  vec2 d = abs(borderUV) - halfSize + radius;\n  float outsideDistance = length(max(d, .0001)) - radius;\n  float insideDistance = min(max(d.x, d.y), .0001);\n  float cornerDistance = abs(min(max(d.x, d.y) - .45 * radius, .0));\n  float distance = outsideDistance + insideDistance;\n\n  float borderThickness = mix(thickness, 3. * thickness, u_softness);\n  float border = roundedBox(borderUV, halfSize, distance, cornerDistance, borderThickness, u_softness);\n  border = pow(border, 1. + u_softness);\n\n  vec2 smokeUV = .3 * u_smokeSize * v_patternUV;\n  float smoke = clamp(3. * valueNoise(2.7 * smokeUV + .5 * t), 0., 1.);\n  smoke -= valueNoise(3.4 * smokeUV - .5 * t);\n  float smokeThickness = thickness + .2;\n  smokeThickness = min(.4, max(smokeThickness, .1));\n  smoke *= roundedBox(borderUV, halfSize, distance, cornerDistance, smokeThickness, 1.);\n  smoke = 30. * smoke * smoke;\n  smoke *= mix(0., .5, pow(u_smoke, 2.));\n  smoke *= mix(1., pulse, u_pulse);\n  smoke = clamp(smoke, 0., 1.);\n  border += smoke;\n\n  border = clamp(border, 0., 1.);\n\n  vec3 blendColor = vec3(0.);\n  float blendAlpha = 0.;\n  vec3 addColor = vec3(0.);\n  float addAlpha = 0.;\n\n  float bloom = 4. * u_bloom;\n  float intensity = 1. + (1. + 4. * u_softness) * u_intensity;\n\n  float angle = atan(borderUV.y, borderUV.x) / TWO_PI;\n\n  for (int colorIdx = 0; colorIdx < ${ pulsingBorderMeta.maxColorCount }; colorIdx++) {\n    if (colorIdx >= int(u_colorsCount)) break;\n    float colorIdxF = float(colorIdx);\n\n    vec3 c = u_colors[colorIdx].rgb * u_colors[colorIdx].a;\n    float a = u_colors[colorIdx].a;\n\n    for (int spotIdx = 0; spotIdx < ${ pulsingBorderMeta.maxSpots }; spotIdx++) {\n      if (spotIdx >= int(u_spots)) break;\n      float spotIdxF = float(spotIdx);\n\n      vec2 randVal = randomGB(vec2(spotIdxF * 10. + 2., 40. + colorIdxF));\n\n      float time = (.1 + .15 * abs(sin(spotIdxF * (2. + colorIdxF)) * cos(spotIdxF * (2. + 2.5 * colorIdxF)))) * t + randVal.x * 3.;\n      time *= mix(1., -1., step(.5, randVal.y));\n\n      float mask = .5 + .5 * mix(\n      sin(t + spotIdxF * (5. - 1.5 * colorIdxF)),\n      cos(t + spotIdxF * (3. + 1.3 * colorIdxF)),\n      step(mod(colorIdxF, 2.), .5)\n      );\n\n      float p = clamp(2. * u_pulse - randVal.x, 0., 1.);\n      mask = mix(mask, pulse, p);\n\n      float atg1 = fract(angle + time);\n      float spotSize = .05 + .6 * pow(u_spotSize, 2.) + .05 * randVal.x;\n      spotSize = mix(spotSize, .1, p);\n      float sector = sst(.5 - spotSize, .5, atg1) * (1. - sst(.5, .5 + spotSize, atg1));\n\n      sector *= mask;\n      sector *= border;\n      sector *= intensity;\n      sector = clamp(sector, 0., 1.);\n\n      vec3 srcColor = c * sector;\n      float srcAlpha = a * sector;\n\n      blendColor += ((1. - blendAlpha) * srcColor);\n      blendAlpha = blendAlpha + (1. - blendAlpha) * srcAlpha;\n      addColor += srcColor;\n      addAlpha += srcAlpha;\n    }\n  }\n\n  vec3 accumColor = mix(blendColor, addColor, bloom);\n  float accumAlpha = mix(blendAlpha, addAlpha, bloom);\n  accumAlpha = clamp(accumAlpha, 0., 1.);\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  vec3 color = accumColor + (1. - accumAlpha) * bgColor;\n  float opacity = accumAlpha + (1. - accumAlpha) * u_colorBack.a;\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}`;\n\nexport interface PulsingBorderUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_roundness: number;\n  u_thickness: number;\n  u_marginLeft: number;\n  u_marginRight: number;\n  u_marginTop: number;\n  u_marginBottom: number;\n  u_aspectRatio: (typeof PulsingBorderAspectRatios)[PulsingBorderAspectRatio];\n  u_softness: number;\n  u_intensity: number;\n  u_bloom: number;\n  u_spots: number;\n  u_spotSize: number;\n  u_pulse: number;\n  u_smoke: number;\n  u_smokeSize: number;\n  u_noiseTexture?: HTMLImageElement;\n}\n\nexport interface PulsingBorderParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colors?: string[];\n  roundness?: number;\n  thickness?: number;\n  margin?: number;\n  marginLeft?: number;\n  marginRight?: number;\n  marginTop?: number;\n  marginBottom?: number;\n  aspectRatio?: PulsingBorderAspectRatio;\n  softness?: number;\n  intensity?: number;\n  bloom?: number;\n  spots?: number;\n  spotSize?: number;\n  pulse?: number;\n  smoke?: number;\n  smokeSize?: number;\n}\n\nexport const PulsingBorderAspectRatios = {\n  auto: 0,\n  square: 1,\n} as const;\n\nexport type PulsingBorderAspectRatio = keyof typeof PulsingBorderAspectRatios;\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, colorBandingFix } from '../shader-utils.js';\n\nexport const colorPanelsMeta = {\n  maxColorCount: 7,\n} as const;\n\n/**\n * Pseudo-3D semi-transparent panels rotating around a central axis\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_scale (float): Overall zoom level, used for anti-aliasing calculations\n * - u_colors (vec4[]): Up to 7 RGBA colors used to color the panels\n * - u_colorsCount (float): Number of active colors\n * - u_colorBack (vec4): Background color in RGBA\n * - u_density (float): Angle between every 2 panels (0.25 to 7)\n * - u_angle1 (float): Skew angle applied to all panes (-1 to 1)\n * - u_angle2 (float): Skew angle applied to all panes (-1 to 1)\n * - u_length (float): Panel length relative to total height (0 to 3)\n * - u_edges (bool): Color highlight on the panels edges\n * - u_blur (float): Side blur, 0 for sharp edges (0 to 0.5)\n * - u_fadeIn (float): Transparency near central axis (0 to 1)\n * - u_fadeOut (float): Transparency near viewer (0 to 1)\n * - u_gradient (float): Color mixing within a panel, 0 = solid, 1 = gradient (0 to 1)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_objectUV (vec2): Object box UV coordinates with global sizing (scale, rotation, offsets, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const colorPanelsFragmentShader: string = `#version 300 es\nprecision lowp float;\n\nuniform float u_time;\nuniform mediump float u_scale;\n\nuniform vec4 u_colors[${ colorPanelsMeta.maxColorCount }];\nuniform float u_colorsCount;\nuniform vec4 u_colorBack;\nuniform float u_density;\nuniform float u_angle1;\nuniform float u_angle2;\nuniform float u_length;\nuniform bool u_edges;\nuniform float u_blur;\nuniform float u_fadeIn;\nuniform float u_fadeOut;\nuniform float u_gradient;\n\nin vec2 v_objectUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n\nconst float zLimit = .5;\n\nvec2 getPanel(float angle, vec2 uv, float invLength, float aa) {\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  float denom = sinA - uv.y * cosA;\n  if (abs(denom) < .01) return vec2(0.);\n\n  float z = uv.y / denom;\n\n  if (z <= 0. || z > zLimit) return vec2(0.);\n\n  float zRatio = z / zLimit;\n  float panelMap = 1. - zRatio;\n  float x = uv.x * (cosA * z + 1.) * invLength;\n\n  float zOffset = zRatio - .5;\n  float left = -.5 + zOffset * u_angle1;\n  float right = .5 - zOffset * u_angle2;\n  float blurX = aa + 2. * panelMap * u_blur;\n\n  float leftEdge1 = left - blurX;\n  float leftEdge2 = left + .25 * blurX;\n  float rightEdge1 = right - .25 * blurX;\n  float rightEdge2 = right + blurX;\n\n  float panel = smoothstep(leftEdge1, leftEdge2, x) * (1.0 - smoothstep(rightEdge1, rightEdge2, x));\n  panel *= mix(0., panel, smoothstep(0., .01 / max(u_scale, 1e-6), panelMap));\n\n  float midScreen = abs(sinA);\n  if (u_edges == true) {\n    panelMap = mix(.99, panelMap, panel * clamp(panelMap / (.15 * (1. - pow(midScreen, .1))), 0.0, 1.0));\n  } else if (midScreen < .07) {\n    panel *= (midScreen * 15.);\n  }\n\n  return vec2(panel, panelMap);\n}\n\nvec4 blendColor(vec4 colorA, float panelMask, float panelMap) {\n  float fade = 1. - smoothstep(.97 - .97 * u_fadeIn, 1., panelMap);\n\n  fade *= smoothstep(-.2 * (1. - u_fadeOut), u_fadeOut, panelMap);\n\n  vec3 blendedRGB = mix(vec3(0.), colorA.rgb, fade);\n  float blendedAlpha = mix(0., colorA.a, fade);\n\n  return vec4(blendedRGB, blendedAlpha) * panelMask;\n}\n\nvoid main() {\n  vec2 uv = v_objectUV;\n  uv *= 1.25;\n\n  float t = .02 * u_time;\n  t = fract(t);\n  bool reverseTime = (t < 0.5);\n\n  vec3 color = vec3(0.);\n  float opacity = 0.;\n\n  float aa = .005 / u_scale;\n  int colorsCount = int(u_colorsCount);\n\n  vec4 premultipliedColors[${ colorPanelsMeta.maxColorCount }];\n  for (int i = 0; i < ${ colorPanelsMeta.maxColorCount }; i++) {\n    if (i >= colorsCount) break;\n    vec4 c = u_colors[i];\n    c.rgb *= c.a;\n    premultipliedColors[i] = c;\n  }\n\n  float invLength = 1.5 / max(u_length, .001);\n\n  float totalColorWeight = 0.;\n  int panelsNumber = 12;\n\n  float densityNormalizer = 1.;\n  if (colorsCount == 4) {\n    panelsNumber = 16;\n    densityNormalizer = 1.34;\n  } else if (colorsCount == 5) {\n    panelsNumber = 20;\n    densityNormalizer = 1.67;\n  } else if (colorsCount == 7) {\n    panelsNumber = 14;\n    densityNormalizer = 1.17;\n  }\n\n  float fPanelsNumber = float(panelsNumber);\n\n  float totalPanelsShape = 0.;\n  float panelGrad = 1. - clamp(u_gradient, 0., 1.);\n\n  for (int set = 0; set < 2; set++) {\n    bool isForward = (set == 0 && !reverseTime) || (set == 1 && reverseTime);\n    if (!isForward) continue;\n\n    for (int i = 0; i <= 20; i++) {\n      if (i >= panelsNumber) break;\n\n      int idx = panelsNumber - 1 - i;\n\n      float offset = float(idx) / fPanelsNumber;\n      if (set == 1) {\n        offset += .5;\n      }\n\n      float densityFract = densityNormalizer * fract(t + offset);\n      float angleNorm = densityFract / u_density;\n      if (densityFract >= .5 || angleNorm >= .3) continue;\n\n      float smoothDensity = clamp((.5 - densityFract) / .1, 0., 1.) * clamp(densityFract / .01, 0., 1.);\n      float smoothAngle = clamp((.3 - angleNorm) / .05, 0., 1.);\n      if (smoothDensity * smoothAngle < .001) continue;\n\n      if (angleNorm > .5) {\n        angleNorm = 0.5;\n      }\n      vec2 panel = getPanel(angleNorm * TWO_PI + PI, uv, invLength, aa);\n      if (panel[0] <= .001) continue;\n      float panelMask = panel[0] * smoothDensity * smoothAngle;\n      float panelMap = panel[1];\n\n      int colorIdx = idx % colorsCount;\n      int nextColorIdx = (idx + 1) % colorsCount;\n\n      vec4 colorA = premultipliedColors[colorIdx];\n      vec4 colorB = premultipliedColors[nextColorIdx];\n\n      colorA = mix(colorA, colorB, max(0., smoothstep(.0, .45, panelMap) - panelGrad));\n      vec4 blended = blendColor(colorA, panelMask, panelMap);\n      color = blended.rgb + color * (1. - blended.a);\n      opacity = blended.a + opacity * (1. - blended.a);\n    }\n\n\n    for (int i = 0; i <= 20; i++) {\n      if (i >= panelsNumber) break;\n\n      int idx = panelsNumber - 1 - i;\n\n      float offset = float(idx) / fPanelsNumber;\n      if (set == 0) {\n        offset += .5;\n      }\n\n      float densityFract = densityNormalizer * fract(-t + offset);\n      float angleNorm = -densityFract / u_density;\n      if (densityFract >= .5 || angleNorm < -.3) continue;\n\n      float smoothDensity = clamp((.5 - densityFract) / .1, 0., 1.) * clamp(densityFract / .01, 0., 1.);\n      float smoothAngle = clamp((angleNorm + .3) / .05, 0., 1.);\n      if (smoothDensity * smoothAngle < .001) continue;\n\n      vec2 panel = getPanel(angleNorm * TWO_PI + PI, uv, invLength, aa);\n      float panelMask = panel[0] * smoothDensity * smoothAngle;\n      if (panelMask <= .001) continue;\n      float panelMap = panel[1];\n\n      int colorIdx = (colorsCount - (idx % colorsCount)) % colorsCount;\n      if (colorIdx < 0) colorIdx += colorsCount;\n      int nextColorIdx = (colorIdx + 1) % colorsCount;\n\n      vec4 colorA = premultipliedColors[colorIdx];\n      vec4 colorB = premultipliedColors[nextColorIdx];\n\n      colorA = mix(colorA, colorB, max(0., smoothstep(.0, .45, panelMap) - panelGrad));\n      vec4 blended = blendColor(colorA, panelMask, panelMap);\n      color = blended.rgb + color * (1. - blended.a);\n      opacity = blended.a + opacity * (1. - blended.a);\n    }\n  }\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1.0 - opacity);\n  opacity = opacity + u_colorBack.a * (1.0 - opacity);\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface ColorPanelsUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_colorBack: [number, number, number, number];\n  u_angle1: number;\n  u_angle2: number;\n  u_length: number;\n  u_edges: boolean;\n  u_blur: number;\n  u_fadeIn: number;\n  u_fadeOut: number;\n  u_density: number;\n  u_gradient: number;\n}\n\nexport interface ColorPanelsParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  colorBack?: string;\n  angle1?: number;\n  angle2?: number;\n  length?: number;\n  edges?: boolean;\n  blur?: number;\n  fadeIn?: number;\n  fadeOut?: number;\n  density?: number;\n  gradient?: number;\n}\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport {\n  type ShaderSizingParams,\n  type ShaderSizingUniforms,\n} from '../shader-sizing.js';\nimport { declarePI, rotation2, proceduralHash21 } from '../shader-utils.js';\n\nexport const staticMeshGradientMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n * Multi-point mesh gradient with up to 10 color spots, enhanced by two-direction warping,\n * adjustable blend sharpness, and grain controls.\n *\n * Fragment shader uniforms:\n * - u_colors (vec4[]): Up to 10 gradient colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_positions (float): Color spots placement seed (0 to 100)\n * - u_waveX (float): Strength of sine wave distortion along X axis (0 to 1)\n * - u_waveXShift (float): Phase offset applied to the X-axis wave (0 to 1)\n * - u_waveY (float): Strength of sine wave distortion along Y axis (0 to 1)\n * - u_waveYShift (float): Phase offset applied to the Y-axis wave (0 to 1)\n * - u_mixing (float): Blending behavior, 0 = hard stripes, 0.5 = smooth, 1 = gradual blend (0 to 1)\n * - u_grainMixer (float): Strength of grain distortion applied to shape edges (0 to 1)\n * - u_grainOverlay (float): Post-processing black/white grain overlay (0 to 1)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_objectUV (vec2): Object box UV coordinates with global sizing (scale, rotation, offsets, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const staticMeshGradientFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform vec4 u_colors[${ staticMeshGradientMeta.maxColorCount }];\nuniform float u_colorsCount;\n\nuniform float u_positions;\nuniform float u_waveX;\nuniform float u_waveXShift;\nuniform float u_waveY;\nuniform float u_waveYShift;\nuniform float u_mixing;\nuniform float u_grainMixer;\nuniform float u_grainOverlay;\n\nin vec2 v_objectUV;\nout vec4 fragColor;\n\n${ declarePI }\n${ rotation2 }\n${ proceduralHash21 }\n\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = hash21(i);\n  float b = hash21(i + vec2(1.0, 0.0));\n  float c = hash21(i + vec2(0.0, 1.0));\n  float d = hash21(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat noise(vec2 n, vec2 seedOffset) {\n  return valueNoise(n + seedOffset);\n}\n\nvec2 getPosition(int i, float t) {\n  float a = float(i) * .37;\n  float b = .6 + mod(float(i), 3.) * .3;\n  float c = .8 + mod(float(i + 1), 4.) * 0.25;\n\n  float x = sin(t * b + a);\n  float y = cos(t * c + a * 1.5);\n\n  return .5 + .5 * vec2(x, y);\n}\n\nvoid main() {\n  vec2 uv = v_objectUV;\n  uv += .5;\n  vec2 grainUV = uv * 1000.;\n\n  float grain = noise(grainUV, vec2(0.));\n  float mixerGrain = .4 * u_grainMixer * (grain - .5);\n\n  float radius = smoothstep(0., 1., length(uv - .5));\n  float center = 1. - radius;\n  for (float i = 1.; i <= 2.; i++) {\n    uv.x += u_waveX * center / i * cos(TWO_PI * u_waveXShift + i * 2. * smoothstep(.0, 1., uv.y));\n    uv.y += u_waveY * center / i * cos(TWO_PI * u_waveYShift + i * 2. * smoothstep(.0, 1., uv.x));\n  }\n\n  vec3 color = vec3(0.);\n  float opacity = 0.;\n  float totalWeight = 0.;\n  float positionSeed = 25. + .33 * u_positions;\n\n  for (int i = 0; i < ${ staticMeshGradientMeta.maxColorCount }; i++) {\n    if (i >= int(u_colorsCount)) break;\n\n    vec2 pos = getPosition(i, positionSeed) + mixerGrain;\n    float dist = length(uv - pos);\n    dist = length(uv - pos);\n\n    vec3 colorFraction = u_colors[i].rgb * u_colors[i].a;\n    float opacityFraction = u_colors[i].a;\n\n    float mixing = pow(u_mixing, .7);\n    float power = mix(2., 1., mixing);\n    dist = pow(dist, power);\n\n    float w = 1. / (dist + 1e-3);\n    float baseSharpness = mix(.0, 8., clamp(w, 0., 1.));\n    float sharpness = mix(baseSharpness, 1., mixing);\n    w = pow(w, sharpness);\n    color += colorFraction * w;\n    opacity += opacityFraction * w;\n    totalWeight += w;\n  }\n\n  color /= max(1e-4, totalWeight);\n  opacity /= max(1e-4, totalWeight);\n\n  float grainOverlay = valueNoise(rotate(grainUV, 1.) + vec2(3.));\n  grainOverlay = mix(grainOverlay, valueNoise(rotate(grainUV, 2.) + vec2(-1.)), .5);\n  grainOverlay = pow(grainOverlay, 1.3);\n\n  float grainOverlayV = grainOverlay * 2. - 1.;\n  vec3 grainOverlayColor = vec3(step(0., grainOverlayV));\n  float grainOverlayStrength = u_grainOverlay * abs(grainOverlayV);\n  grainOverlayStrength = pow(grainOverlayStrength, .8);\n  color = mix(color, grainOverlayColor, .35 * grainOverlayStrength);\n\n  opacity += .5 * grainOverlayStrength;\n  opacity = clamp(opacity, 0., 1.);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface StaticMeshGradientUniforms extends ShaderSizingUniforms {\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_positions: number;\n  u_waveX: number;\n  u_waveXShift: number;\n  u_waveY: number;\n  u_waveYShift: number;\n  u_mixing: number;\n  u_grainMixer: number;\n  u_grainOverlay: number;\n}\n\nexport interface StaticMeshGradientParams extends ShaderSizingParams, ShaderMotionParams {\n  colors?: string[];\n  positions?: number;\n  waveX?: number;\n  waveXShift?: number;\n  waveY?: number;\n  waveYShift?: number;\n  mixing?: number;\n  grainMixer?: number;\n  grainOverlay?: number;\n}\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport {\n  type ShaderSizingParams,\n  type ShaderSizingUniforms,\n} from '../shader-sizing.js';\nimport { declarePI, rotation2, proceduralHash21 } from '../shader-utils.js';\n\nexport const staticRadialGradientMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n * Radial gradient with up to 10 blended colors, featuring advanced mixing modes, focal point controls,\n * shape distortion, and grain effects.\n *\n * Fragment shader uniforms:\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colors (vec4[]): Up to 10 gradient colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_radius (float): Size of the shape (0 to 3)\n * - u_focalDistance (float): Distance of the focal point from center (0 to 3)\n * - u_focalAngle (float): Angle of the focal point in degrees, effective with focalDistance > 0 (0 to 360)\n * - u_falloff (float): Gradient decay, 0 = linear gradient (-1 to 1)\n * - u_mixing (float): Blending behavior, 0 = hard stripes, 1 = smooth gradient (0 to 1)\n * - u_distortion (float): Strength of radial distortion (0 to 1)\n * - u_distortionShift (float): Radial distortion offset, effective with distortion > 0 (-1 to 1)\n * - u_distortionFreq (float): Radial distortion frequency, effective with distortion > 0 (0 to 20)\n * - u_grainMixer (float): Strength of grain distortion applied to shape edges (0 to 1)\n * - u_grainOverlay (float): Post-processing black/white grain overlay (0 to 1)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_objectUV (vec2): Object box UV coordinates with global sizing (scale, rotation, offsets, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const staticRadialGradientFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${ staticRadialGradientMeta.maxColorCount }];\nuniform float u_colorsCount;\n\nuniform float u_radius;\nuniform float u_focalDistance;\nuniform float u_focalAngle;\nuniform float u_falloff;\nuniform float u_mixing;\nuniform float u_distortion;\nuniform float u_distortionShift;\nuniform float u_distortionFreq;\nuniform float u_grainMixer;\nuniform float u_grainOverlay;\n\nin vec2 v_objectUV;\nout vec4 fragColor;\n\n${ declarePI }\n${ rotation2 }\n${ proceduralHash21 }\n\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = hash21(i);\n  float b = hash21(i + vec2(1.0, 0.0));\n  float c = hash21(i + vec2(0.0, 1.0));\n  float d = hash21(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat noise(vec2 n, vec2 seedOffset) {\n  return valueNoise(n + seedOffset);\n}\n\nvec2 getPosition(int i, float t) {\n  float a = float(i) * .37;\n  float b = .6 + mod(float(i), 3.) * .3;\n  float c = .8 + mod(float(i + 1), 4.) * 0.25;\n\n  float x = sin(t * b + a);\n  float y = cos(t * c + a * 1.5);\n\n  return .5 + .5 * vec2(x, y);\n}\n\nvoid main() {\n  vec2 uv = 2. * v_objectUV;\n  vec2 grainUV = uv * 1000.;\n\n  vec2 center = vec2(0.);\n  float angleRad = -radians(u_focalAngle + 90.);\n  vec2 focalPoint = vec2(cos(angleRad), sin(angleRad)) * u_focalDistance;\n  float radius = u_radius;\n\n  vec2 c_to_uv = uv - center;\n  vec2 f_to_uv = uv - focalPoint;\n  vec2 f_to_c = center - focalPoint;\n  float r = length(c_to_uv);\n\n  float fragAngle = atan(c_to_uv.y, c_to_uv.x);\n  float angleDiff = fract((fragAngle - angleRad + PI) / TWO_PI) * TWO_PI - PI;\n\n  float halfAngle = acos(clamp(radius / max(u_focalDistance, 1e-4), 0.0, 1.0));\n  float e0 = 0.6 * PI, e1 = halfAngle;\n  float lo = min(e0, e1), hi = max(e0, e1);\n  float s  = smoothstep(lo, hi, abs(angleDiff));\n  float isInSector = (e1 >= e0) ? (1.0 - s) : s;\n\n  float a = dot(f_to_uv, f_to_uv);\n  float b = -2.0 * dot(f_to_uv, f_to_c);\n  float c = dot(f_to_c, f_to_c) - radius * radius;\n\n  float discriminant = b * b - 4.0 * a * c;\n  float t = 1.0;\n\n  if (discriminant >= 0.0) {\n    float sqrtD = sqrt(discriminant);\n    float div = max(1e-4, 2.0 * a);\n    float t0 = (-b - sqrtD) / div;\n    float t1 = (-b + sqrtD) / div;\n    t = max(t0, t1);\n    if (t < 0.0) t = 0.0;\n  }\n\n  float dist = length(f_to_uv);\n  float normalized = dist / max(1e-4, length(f_to_uv * t));\n  float shape = clamp(normalized, 0.0, 1.0);\n\n  float falloffMapped = mix(.2 + .8 * max(0., u_falloff + 1.), mix(1., 15., u_falloff * u_falloff), step(.0, u_falloff));\n\n  float falloffExp = mix(falloffMapped, 1., shape);\n  shape = pow(shape, falloffExp);\n  shape = 1. - clamp(shape, 0., 1.);\n\n\n  float outerMask = .002;\n  float outer = 1.0 - smoothstep(radius - outerMask, radius + outerMask, r);\n  outer = mix(outer, 1., isInSector);\n\n  shape = mix(0., shape, outer);\n  shape *= 1. - smoothstep(radius - .01, radius, r);\n\n  float angle = atan(f_to_uv.y, f_to_uv.x);\n  shape -= pow(u_distortion, 2.) * shape * pow(abs(sin(PI * clamp(length(f_to_uv) - 0.2 + u_distortionShift, 0.0, 1.0))), 4.0) * (sin(u_distortionFreq * angle) + cos(floor(0.65 * u_distortionFreq) * angle));\n\n  float grain = noise(grainUV, vec2(0.));\n  float mixerGrain = .4 * u_grainMixer * (grain - .5);\n\n  float mixer = shape * u_colorsCount + mixerGrain;\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n\n  float outerShape = 0.;\n  for (int i = 1; i < ${ staticRadialGradientMeta.maxColorCount + 1 }; i++) {\n    if (i > int(u_colorsCount)) break;\n    float mLinear = clamp(mixer - float(i - 1), 0.0, 1.0);\n\n    float aa = fwidth(mLinear);\n    float width = min(u_mixing, 0.5);\n    float t = clamp((mLinear - (0.5 - width - aa)) / (2. * width + 2. * aa), 0., 1.);\n    float p = mix(2., 1., clamp((u_mixing - 0.5) * 2., 0., 1.));\n    float m = t < 0.5\n      ? 0.5 * pow(2. * t, p)\n      : 1. - 0.5 * pow(2. * (1. - t), p);\n\n    float quadBlend = clamp((u_mixing - 0.5) * 2., 0., 1.);\n    m = mix(m, m * m, 0.5 * quadBlend);\n    \n    if (i == 1) {\n      outerShape = m;\n    }\n\n    vec4 c = u_colors[i - 1];\n    c.rgb *= c.a;\n    gradient = mix(gradient, c, m);\n  }\n\n  vec3 color = gradient.rgb * outerShape;\n  float opacity = gradient.a * outerShape;\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1.0 - opacity);\n  opacity = opacity + u_colorBack.a * (1.0 - opacity);\n\n  float grainOverlay = valueNoise(rotate(grainUV, 1.) + vec2(3.));\n  grainOverlay = mix(grainOverlay, valueNoise(rotate(grainUV, 2.) + vec2(-1.)), .5);\n  grainOverlay = pow(grainOverlay, 1.3);\n\n  float grainOverlayV = grainOverlay * 2. - 1.;\n  vec3 grainOverlayColor = vec3(step(0., grainOverlayV));\n  float grainOverlayStrength = u_grainOverlay * abs(grainOverlayV);\n  grainOverlayStrength = pow(grainOverlayStrength, .8);\n  color = mix(color, grainOverlayColor, .35 * grainOverlayStrength);\n\n  opacity += .5 * grainOverlayStrength;\n  opacity = clamp(opacity, 0., 1.);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface StaticRadialGradientUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n  u_radius: number;\n  u_focalDistance: number;\n  u_focalAngle: number;\n  u_falloff: number;\n  u_mixing: number;\n  u_distortion: number;\n  u_distortionShift: number;\n  u_distortionFreq: number;\n  u_grainMixer: number;\n  u_grainOverlay: number;\n}\n\nexport interface StaticRadialGradientParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colors?: string[];\n  radius?: number;\n  focalDistance?: number;\n  focalAngle?: number;\n  falloff?: number;\n  mixing?: number;\n  distortion?: number;\n  distortionShift?: number;\n  distortionFreq?: number;\n  grainMixer?: number;\n  grainOverlay?: number;\n}\n", "import type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { rotation2, declarePI, fiberNoise, textureRandomizerR } from '../shader-utils.js';\n\n/**\n * A static texture built from multiple noise layers, usable for realistic paper and cardboard surfaces.\n * Can be used as an image filter or as a standalone texture.\n *\n * Fragment shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_image (sampler2D): Optional source image texture\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n * - u_colorFront (vec4): Foreground color in RGBA\n * - u_colorBack (vec4): Background color in RGBA\n * - u_contrast (float): Blending behavior, sharper vs smoother color transitions (0 to 1)\n * - u_roughness (float): Pixel noise, related to canvas and not scalable (0 to 1)\n * - u_fiber (float): Curly-shaped noise intensity (0 to 1)\n * - u_fiberSize (float): Curly-shaped noise scale (0 to 1)\n * - u_crumples (float): Cell-based crumple pattern intensity (0 to 1)\n * - u_crumpleSize (float): Cell-based crumple pattern scale (0 to 1)\n * - u_folds (float): Depth of the folds (0 to 1)\n * - u_foldCount (float): Number of folds (1 to 15)\n * - u_fade (float): Big-scale noise mask applied to the pattern (0 to 1)\n * - u_drops (float): Visibility of speckle pattern (0 to 1)\n * - u_seed (float): Seed applied to folds, crumples and dots (0 to 1000)\n * - u_noiseTexture (sampler2D): Pre-computed randomizer source texture\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_imageUV (vec2): UV coordinates for sampling the source image, with fit, scale, rotation, and offset applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n *\n */\n\n// language=GLSL\nexport const paperTextureFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\nuniform vec4 u_colorFront;\nuniform vec4 u_colorBack;\n\nuniform sampler2D u_image;\nuniform float u_imageAspectRatio;\n\nuniform float u_contrast;\nuniform float u_roughness;\nuniform float u_fiber;\nuniform float u_fiberSize;\nuniform float u_crumples;\nuniform float u_crumpleSize;\nuniform float u_folds;\nuniform float u_foldCount;\nuniform float u_drops;\nuniform float u_seed;\nuniform float u_fade;\n\nuniform sampler2D u_noiseTexture;\n\nin vec2 v_imageUV;\n\nout vec4 fragColor;\n\nfloat getUvFrame(vec2 uv) {\n  float aax = 2. * fwidth(uv.x);\n  float aay = 2. * fwidth(uv.y);\n\n  float left   = smoothstep(0., aax, uv.x);\n  float right = 1. - smoothstep(1. - aax, 1., uv.x);\n  float bottom = smoothstep(0., aay, uv.y);\n  float top = 1. - smoothstep(1. - aay, 1., uv.y);\n\n  return left * right * bottom * top;\n}\n\n${ declarePI }\n${ rotation2 }\n${ textureRandomizerR }\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = randomR(i);\n  float b = randomR(i + vec2(1.0, 0.0));\n  float c = randomR(i + vec2(0.0, 1.0));\n  float d = randomR(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\nfloat fbm(vec2 n) {\n  float total = 0.0, amplitude = .4;\n  for (int i = 0; i < 3; i++) {\n    total += valueNoise(n) * amplitude;\n    n *= 1.99;\n    amplitude *= 0.65;\n  }\n  return total;\n}\n\n\nfloat randomG(vec2 p) {\n  vec2 uv = floor(p) / 50. + .5;\n  return texture(u_noiseTexture, fract(uv)).g;\n}\nfloat roughness(vec2 p) {\n  p *= .1;\n  float o = 0.;\n  for (float i = 0.; ++i < 4.; p *= 2.1) {\n    vec4 w = vec4(floor(p), ceil(p));\n    vec2 f = fract(p);\n    o += mix(\n    mix(randomG(w.xy), randomG(w.xw), f.y),\n    mix(randomG(w.zy), randomG(w.zw), f.y),\n    f.x);\n    o += .2 / exp(2. * abs(sin(.2 * p.x + .5 * p.y)));\n  }\n  return o / 3.;\n}\n\n${ fiberNoise }\n\nvec2 randomGB(vec2 p) {\n  vec2 uv = floor(p) / 50. + .5;\n  return texture(u_noiseTexture, fract(uv)).gb;\n}\nfloat crumpledNoise(vec2 t, float pw) {\n  vec2 p = floor(t);\n  float wsum = 0.;\n  float cl = 0.;\n  for (int y = -1; y < 2; y += 1) {\n    for (int x = -1; x < 2; x += 1) {\n      vec2 b = vec2(float(x), float(y));\n      vec2 q = b + p;\n      vec2 q2 = q - floor(q / 8.) * 8.;\n      vec2 c = q + randomGB(q2);\n      vec2 r = c - t;\n      float w = pow(smoothstep(0., 1., 1. - abs(r.x)), pw) * pow(smoothstep(0., 1., 1. - abs(r.y)), pw);\n      cl += (.5 + .5 * sin((q2.x + q2.y * 5.) * 8.)) * w;\n      wsum += w;\n    }\n  }\n  return pow(wsum != 0.0 ? cl / wsum : 0.0, .5) * 2.;\n}\nfloat crumplesShape(vec2 uv) {\n  return crumpledNoise(uv * .25, 16.) * crumpledNoise(uv * .5, 2.);\n}\n\n\nvec2 folds(vec2 uv) {\n  vec3 pp = vec3(0.);\n  float l = 9.;\n  for (float i = 0.; i < 15.; i++) {\n    if (i >= u_foldCount) break;\n    vec2 rand = randomGB(vec2(i, i * u_seed));\n    float an = rand.x * TWO_PI;\n    vec2 p = vec2(cos(an), sin(an)) * rand.y;\n    float dist = distance(uv, p);\n    l = min(l, dist);\n\n    if (l == dist) {\n      pp.xy = (uv - p.xy);\n      pp.z = dist;\n    }\n  }\n  return mix(pp.xy, vec2(0.), pow(pp.z, .25));\n}\n\nfloat drops(vec2 uv) {\n  vec2 iDropsUV = floor(uv);\n  vec2 fDropsUV = fract(uv);\n  float dropsMinDist = 1.;\n  for (int j = -1; j <= 1; j++) {\n    for (int i = -1; i <= 1; i++) {\n      vec2 neighbor = vec2(float(i), float(j));\n      vec2 offset = randomGB(iDropsUV + neighbor);\n      offset = .5 + .5 * sin(10. * u_seed + TWO_PI * offset);\n      vec2 pos = neighbor + offset - fDropsUV;\n      float dist = length(pos);\n      dropsMinDist = min(dropsMinDist, dropsMinDist*dist);\n    }\n  }\n  return 1. - smoothstep(.05, .09, pow(dropsMinDist, .5));\n}\n\nfloat lst(float edge0, float edge1, float x) {\n  return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nvoid main() {\n\n  vec2 imageUV = v_imageUV;\n  vec2 patternUV = v_imageUV - .5;\n  patternUV = 5. * (patternUV * vec2(u_imageAspectRatio, 1.));\n\n  vec2 roughnessUv = 1.5 * (gl_FragCoord.xy - .5 * u_resolution) / u_pixelRatio;\n  float roughness = roughness(roughnessUv + vec2(1., 0.)) - roughness(roughnessUv - vec2(1., 0.));\n\n  vec2 crumplesUV = fract(patternUV * .02 / u_crumpleSize - u_seed) * 32.;\n  float crumples = u_crumples * (crumplesShape(crumplesUV + vec2(.05, 0.)) - crumplesShape(crumplesUV));\n\n  vec2 fiberUV = 2. / u_fiberSize * patternUV;\n  float fiber = fiberNoise(fiberUV, vec2(0.));\n  fiber = .5 * u_fiber * (fiber - 1.);\n\n  vec2 normal = vec2(0.);\n  vec2 normalImage = vec2(0.);\n\n  vec2 foldsUV = patternUV * .12;\n  foldsUV = rotate(foldsUV, 4. * u_seed);\n  vec2 w = folds(foldsUV);\n  foldsUV = rotate(foldsUV + .007 * cos(u_seed), .01 * sin(u_seed));\n  vec2 w2 = folds(foldsUV);\n\n  float drops = u_drops * drops(patternUV * 2.);\n\n  float fade = u_fade * fbm(.17 * patternUV + 10. * u_seed);\n  fade = clamp(8. * fade * fade * fade, 0., 1.);\n\n  w = mix(w, vec2(0.), fade);\n  w2 = mix(w2, vec2(0.), fade);\n  crumples = mix(crumples, 0., fade);\n  drops = mix(drops, 0., fade);\n  fiber *= mix(1., .5, fade);\n  roughness *= mix(1., .5, fade);\n\n  normal.xy += u_folds * min(5. * u_contrast, 1.) * 4. * max(vec2(0.), w + w2);\n  normalImage.xy += u_folds * 2. * w;\n\n  normal.xy += crumples;\n  normalImage.xy += 1.5 * crumples;\n\n  normal.xy += 3. * drops;\n  normalImage.xy += .2 * drops;\n\n  normal.xy += u_roughness * 1.5 * roughness;\n  normal.xy += fiber;\n\n  normalImage += u_roughness * .75 * roughness;\n  normalImage += .2 * fiber;\n\n  vec3 lightPos = vec3(1., 2., 1.);\n  float res = dot(normalize(vec3(normal, 9.5 - 9. * pow(u_contrast, .1))), normalize(lightPos));\n\n  vec3 fgColor = u_colorFront.rgb * u_colorFront.a;\n  float fgOpacity = u_colorFront.a;\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  float bgOpacity = u_colorBack.a;\n\n  imageUV += .02 * normalImage;\n  float frame = getUvFrame(imageUV);\n  vec4 image = texture(u_image, imageUV);\n  image.rgb += .6 * pow(u_contrast, .4) * (res - .7);\n\n  frame *= image.a;\n\n  vec3 color = fgColor * res;\n  float opacity = fgOpacity * res;\n\n  color += bgColor * (1. - opacity);\n  opacity += bgOpacity * (1. - opacity);\n  opacity = mix(opacity, 1., frame);\n\n  color -= .007 * drops;\n\n  color.rgb = mix(color, image.rgb, frame);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface PaperTextureUniforms extends ShaderSizingUniforms {\n  u_image: HTMLImageElement | string | undefined;\n  u_noiseTexture?: HTMLImageElement;\n  u_colorFront: [number, number, number, number];\n  u_colorBack: [number, number, number, number];\n  u_contrast: number;\n  u_roughness: number;\n  u_fiber: number;\n  u_fiberSize: number;\n  u_crumples: number;\n  u_foldCount: number;\n  u_folds: number;\n  u_fade: number;\n  u_crumpleSize: number;\n  u_drops: number;\n  u_seed: number;\n}\n\nexport interface PaperTextureParams extends ShaderSizingParams, ShaderMotionParams {\n  image?: HTMLImageElement | string;\n  colorFront?: string;\n  colorBack?: string;\n  contrast?: number;\n  roughness?: number;\n  fiber?: number;\n  fiberSize?: number;\n  crumples?: number;\n  foldCount?: number;\n  folds?: number;\n  fade?: number;\n  crumpleSize?: number;\n  drops?: number;\n  seed?: number;\n}\n", "import type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, rotation2, simplexNoise } from '../shader-utils.js';\n\n/**\n * Water-like surface distortion with natural caustic realism. Works as an image filter or standalone animated texture.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_image (sampler2D): Optional source image texture\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colorHighlight (vec4): Highlight color in RGBA\n * - u_highlights (float): Coloring added over image/background following caustic shape (0 to 1)\n * - u_layering (float): Power of 2nd layer of caustic distortion (0 to 1)\n * - u_edges (float): Caustic distortion power on the image edges (0 to 1)\n * - u_waves (float): Additional distortion based on simplex noise, independent from caustic (0 to 1)\n * - u_caustic (float): Power of caustic distortion (0 to 1)\n * - u_size (float): Pattern scale relative to the image (0.01 to 7)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_imageUV (vec2): UV coordinates for sampling the source image, with fit, scale, rotation, and offset applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n *\n */\n\n// language=GLSL\nexport const waterFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colorHighlight;\n\nuniform sampler2D u_image;\nuniform float u_imageAspectRatio;\n\nuniform float u_size;\nuniform float u_highlights;\nuniform float u_layering;\nuniform float u_edges;\nuniform float u_caustic;\nuniform float u_waves;\n\nin vec2 v_imageUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ rotation2 }\n${ simplexNoise }\n\nfloat getUvFrame(vec2 uv) {\n  float aax = 2. * fwidth(uv.x);\n  float aay = 2. * fwidth(uv.y);\n\n  float left   = smoothstep(0., aax, uv.x);\n  float right = 1.0 - smoothstep(1. - aax, 1., uv.x);\n  float bottom = smoothstep(0., aay, uv.y);\n  float top = 1.0 - smoothstep(1. - aay, 1., uv.y);\n\n  return left * right * bottom * top;\n}\n\nmat2 rotate2D(float r) {\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat getCausticNoise(vec2 uv, float t, float scale) {\n  vec2 n = vec2(.1);\n  vec2 N = vec2(.1);\n  mat2 m = rotate2D(.5);\n  for (int j = 0; j < 6; j++) {\n    uv *= m;\n    n *= m;\n    vec2 q = uv * scale + float(j) + n + (.5 + .5 * float(j)) * (mod(float(j), 2.) - 1.) * t;\n    n += sin(q);\n    N += cos(q) / scale;\n    scale *= 1.1;\n  }\n  return (N.x + N.y + 1.);\n}\n\nvoid main() {\n  vec2 imageUV = v_imageUV;\n  vec2 patternUV = v_imageUV - .5;\n  patternUV = (patternUV * vec2(u_imageAspectRatio, 1.));\n  patternUV /= (.01 + .09 * u_size);\n\n  float t = u_time;\n\n  float wavesNoise = snoise((.3 + .1 * sin(t)) * .1 * patternUV + vec2(0., .4 * t));\n\n  float causticNoise = getCausticNoise(patternUV + u_waves * vec2(1., -1.) * wavesNoise, 2. * t, 1.5);\n\n  causticNoise += u_layering * getCausticNoise(patternUV + 2. * u_waves * vec2(1., -1.) * wavesNoise, 1.5 * t, 2.);\n  causticNoise = causticNoise * causticNoise;\n\n  float edgesDistortion = smoothstep(0., .1, imageUV.x);\n  edgesDistortion *= smoothstep(0., .1, imageUV.y);\n  edgesDistortion *= (smoothstep(1., 1.1, imageUV.x) + (1.0 - smoothstep(.8, .95, imageUV.x)));\n  edgesDistortion *= (1.0 - smoothstep(.9, 1., imageUV.y));\n  edgesDistortion = mix(edgesDistortion, 1., u_edges);\n\n  float causticNoiseDistortion = .02 * causticNoise * edgesDistortion;\n\n  float wavesDistortion = .1 * u_waves * wavesNoise;\n\n  imageUV += vec2(wavesDistortion, -wavesDistortion);\n  imageUV += (u_caustic * causticNoiseDistortion);\n\n  float frame = getUvFrame(imageUV);\n\n  vec4 image = texture(u_image, imageUV);\n  vec4 backColor = u_colorBack;\n  backColor.rgb *= backColor.a;\n\n  vec3 color = mix(backColor.rgb, image.rgb, image.a * frame);\n  float opacity = backColor.a + image.a * frame;\n\n  causticNoise = max(-.2, causticNoise);\n\n  float hightlight = .025 * u_highlights * causticNoise;\n  hightlight *= u_colorHighlight.a;\n  color = mix(color, u_colorHighlight.rgb, .05 * u_highlights * causticNoise);\n  opacity += hightlight;\n\n  color += hightlight * (.5 + .5 * wavesNoise);\n  opacity += hightlight * (.5 + .5 * wavesNoise);\n\n  opacity = clamp(opacity, 0., 1.);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface WaterUniforms extends ShaderSizingUniforms {\n  u_image: HTMLImageElement | string | undefined;\n  u_colorBack: [number, number, number, number];\n  u_colorHighlight: [number, number, number, number];\n  u_highlights: number;\n  u_layering: number;\n  u_edges: number;\n  u_caustic: number;\n  u_waves: number;\n  u_size: number;\n}\n\nexport interface WaterParams extends ShaderSizingParams, ShaderMotionParams {\n  image?: HTMLImageElement | string;\n  colorBack?: string;\n  colorHighlight?: string;\n  highlights?: number;\n  layering?: number;\n  edges?: number;\n  caustic?: number;\n  waves?: number;\n  size?: number;\n}\n", "import type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, rotation2, proceduralHash21 } from '../shader-utils.js';\n\n/**\n * Fluted glass image filter that transforms an image into streaked, ribbed distortions,\n * giving a mix of clarity and obscurity.\n *\n * Fragment shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_image (sampler2D): Source image texture\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colorShadow (vec4): Shadows color in RGBA\n * - u_colorHighlight (vec4): Highlights color in RGBA\n * - u_shadows (float): Color gradient added over image and background, following distortion shape (0 to 1)\n * - u_highlights (float): Thin strokes along distortion shape, useful for antialiasing on small grid (0 to 1)\n * - u_size (float): Size of the distortion shape grid (0 to 1)\n * - u_shape (float): Grid shape (1 = lines, 2 = linesIrregular, 3 = wave, 4 = zigzag, 5 = pattern)\n * - u_angle (float): Direction of the grid relative to the image in degrees (0 to 180)\n * - u_distortionShape (float): Shape of distortion (1 = prism, 2 = lens, 3 = contour, 4 = cascade, 5 = flat)\n * - u_distortion (float): Power of distortion applied within each stripe (0 to 1)\n * - u_shift (float): Texture shift in direction opposite to the grid (-1 to 1)\n * - u_stretch (float): Extra distortion along the grid lines (0 to 1)\n * - u_blur (float): One-directional blur over the image and extra blur around edges (0 to 1)\n * - u_edges (float): Glass distortion and softness on the image edges (0 to 1)\n * - u_marginLeft (float): Distance from the left edge to the effect (0 to 1)\n * - u_marginRight (float): Distance from the right edge to the effect (0 to 1)\n * - u_marginTop (float): Distance from the top edge to the effect (0 to 1)\n * - u_marginBottom (float): Distance from the bottom edge to the effect (0 to 1)\n * - u_grainMixer (float): Strength of grain distortion applied to shape edges (0 to 1)\n * - u_grainOverlay (float): Post-processing black/white grain overlay (0 to 1)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_imageUV (vec2): Image UV coordinates with global sizing (rotation, scale, offset, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n *\n */\n\n// language=GLSL\nexport const flutedGlassFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\nuniform float u_rotation;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colorShadow;\nuniform vec4 u_colorHighlight;\n\nuniform sampler2D u_image;\nuniform float u_imageAspectRatio;\n\nuniform float u_size;\nuniform float u_shadows;\nuniform float u_angle;\nuniform float u_stretch;\nuniform float u_shape;\nuniform float u_distortion;\nuniform float u_highlights;\nuniform float u_distortionShape;\nuniform float u_shift;\nuniform float u_blur;\nuniform float u_edges;\nuniform float u_marginLeft;\nuniform float u_marginRight;\nuniform float u_marginTop;\nuniform float u_marginBottom;\nuniform float u_grainMixer;\nuniform float u_grainOverlay;\n\nin vec2 v_imageUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ rotation2 }\n${ proceduralHash21 }\n\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = hash21(i);\n  float b = hash21(i + vec2(1.0, 0.0));\n  float c = hash21(i + vec2(0.0, 1.0));\n  float d = hash21(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat getUvFrame(vec2 uv, float softness) {\n  float aax = 2. * fwidth(uv.x);\n  float aay = 2. * fwidth(uv.y);\n  float left   = smoothstep(0., aax + softness, uv.x);\n  float right  = 1. - smoothstep(1. - softness - aax, 1., uv.x);\n  float bottom = smoothstep(0., aay + softness, uv.y);\n  float top    = 1. - smoothstep(1. - softness - aay, 1., uv.y);\n  return left * right * bottom * top;\n}\n\nconst int MAX_RADIUS = 50;\nvec4 samplePremultiplied(sampler2D tex, vec2 uv) {\n  vec4 c = texture(tex, uv);\n  c.rgb *= c.a;\n  return c;\n}\nvec4 getBlur(sampler2D tex, vec2 uv, vec2 texelSize, vec2 dir, float sigma) {\n  if (sigma <= .5) return texture(tex, uv);\n  int radius = int(min(float(MAX_RADIUS), ceil(3.0 * sigma)));\n\n  float twoSigma2 = 2.0 * sigma * sigma;\n  float gaussianNorm = 1.0 / sqrt(TWO_PI * sigma * sigma);\n\n  vec4 sum = samplePremultiplied(tex, uv) * gaussianNorm;\n  float weightSum = gaussianNorm;\n\n  for (int i = 1; i <= MAX_RADIUS; i++) {\n    if (i > radius) break;\n\n    float x = float(i);\n    float w = exp(-(x * x) / twoSigma2) * gaussianNorm;\n\n    vec2 offset = dir * texelSize * x;\n    vec4 s1 = samplePremultiplied(tex, uv + offset);\n    vec4 s2 = samplePremultiplied(tex, uv - offset);\n\n    sum += (s1 + s2) * w;\n    weightSum += 2.0 * w;\n  }\n\n  vec4 result = sum / weightSum;\n  if (result.a > 0.) {\n    result.rgb /= result.a;\n  }\n\n  return result;\n}\n\nvec2 rotateAspect(vec2 p, float a, float aspect) {\n  p.x *= aspect;\n  p = rotate(p, a);\n  p.x /= aspect;\n  return p;\n}\n\nfloat smoothFract(float x) {\n  float f = fract(x);\n  float w = fwidth(x);\n\n  float edge = abs(f - 0.5) - 0.5;\n  float band = smoothstep(-w, w, edge);\n\n  return mix(f, 1.0 - f, band);\n}\n\nvoid main() {\n\n  float patternRotation = -u_angle * PI / 180.;\n  float patternSize = mix(200., 5., u_size);\n\n  vec2 uv = v_imageUV;\n\n  vec2 uvMask = gl_FragCoord.xy / u_resolution.xy;\n  vec2 sw = vec2(.005);\n  vec4 margins = vec4(u_marginLeft, u_marginTop, u_marginRight, u_marginBottom);\n  float mask =\n  smoothstep(margins[0], margins[0] + sw.x, uvMask.x + sw.x) *\n  smoothstep(margins[2], margins[2] + sw.x, 1.0 - uvMask.x + sw.x) *\n  smoothstep(margins[1], margins[1] + sw.y, uvMask.y + sw.y) *\n  smoothstep(margins[3], margins[3] + sw.y, 1.0 - uvMask.y + sw.y);\n  float maskOuter =\n  smoothstep(margins[0] - sw.x, margins[0], uvMask.x + sw.x) *\n  smoothstep(margins[2] - sw.x, margins[2], 1.0 - uvMask.x + sw.x) *\n  smoothstep(margins[1] - sw.y, margins[1], uvMask.y + sw.y) *\n  smoothstep(margins[3] - sw.y, margins[3], 1.0 - uvMask.y + sw.y);\n  float maskStroke = maskOuter - mask;\n  float maskInner =\n  smoothstep(margins[0] - 2. * sw.x, margins[0], uvMask.x) *\n  smoothstep(margins[2] - 2. * sw.x, margins[2], 1.0 - uvMask.x) *\n  smoothstep(margins[1] - 2. * sw.y, margins[1], uvMask.y) *\n  smoothstep(margins[3] - 2. * sw.y, margins[3], 1.0 - uvMask.y);\n  float maskStrokeInner = maskInner - mask;\n\n  uv -= .5;\n  uv *= patternSize;\n  uv = rotateAspect(uv, patternRotation, u_imageAspectRatio);\n\n  float curve = 0.;\n  float patternY = uv.y / u_imageAspectRatio;\n  if (u_shape > 4.5) {\n    // pattern\n    curve = .5 + .5 * sin(.5 * PI * uv.x) * cos(.5 * PI * patternY);\n  } else if (u_shape > 3.5) {\n    // zigzag\n    curve = 10. * abs(fract(.1 * patternY) - .5);\n  } else if (u_shape > 2.5) {\n    // wave\n    curve = 4. * sin(.23 * patternY);\n  } else if (u_shape > 1.5) {\n    // lines irregular\n    curve = .5 + .5 * sin(.5 * uv.x) * sin(1.7 * uv.x);\n  } else {\n    // lines\n  }\n\n  vec2 UvToFract = uv + curve;\n  vec2 fractOrigUV = fract(uv);\n  vec2 floorOrigUV = floor(uv);\n\n  float x = smoothFract(UvToFract.x);\n  float xNonSmooth = fract(UvToFract.x) + .0001;\n\n  float highlightsWidth = 2. * max(.001, fwidth(UvToFract.x));\n  highlightsWidth += 2. * maskStrokeInner;\n  float highlights = smoothstep(0., highlightsWidth, xNonSmooth);\n  highlights *= smoothstep(1., 1. - highlightsWidth, xNonSmooth);\n  highlights = 1. - highlights;\n  highlights *= u_highlights;\n  highlights = clamp(highlights, 0., 1.);\n  highlights *= mask;\n\n  float shadows = pow(x, 1.3);\n  float distortion = 0.;\n  float fadeX = 1.;\n  float frameFade = 0.;\n\n  float aa = fwidth(xNonSmooth);\n  aa = max(aa, fwidth(uv.x));\n  aa = max(aa, fwidth(UvToFract.x));\n  aa = max(aa, .0001);\n\n  if (u_distortionShape == 1.) {\n    distortion = -pow(1.5 * x, 3.);\n    distortion += (.5 - u_shift);\n\n    frameFade = pow(1.5 * x, 3.);\n    aa = max(.2, aa);\n    aa += mix(.2, 0., u_size);\n    fadeX = smoothstep(0., aa, xNonSmooth) * smoothstep(1., 1. - aa, xNonSmooth);\n    distortion = mix(.5, distortion, fadeX);\n  } else if (u_distortionShape == 2.) {\n    distortion = 2. * pow(x, 2.);\n    distortion -= (.5 + u_shift);\n\n    frameFade = pow(abs(x - .5), 4.);\n    aa = max(.2, aa);\n    aa += mix(.2, 0., u_size);\n    fadeX = smoothstep(0., aa, xNonSmooth) * smoothstep(1., 1. - aa, xNonSmooth);\n    distortion = mix(.5, distortion, fadeX);\n    frameFade = mix(1., frameFade, .5 * fadeX);\n  } else if (u_distortionShape == 3.) {\n    distortion = pow(2. * (xNonSmooth - .5), 6.);\n    distortion -= .25;\n    distortion -= u_shift;\n\n    frameFade = 1. - 2. * pow(abs(x - .4), 2.);\n    aa = .15;\n    aa += mix(.1, 0., u_size);\n    fadeX = smoothstep(0., aa, xNonSmooth) * smoothstep(1., 1. - aa, xNonSmooth);\n    frameFade = mix(1., frameFade, fadeX);\n\n  } else if (u_distortionShape == 4.) {\n    x = xNonSmooth;\n    distortion = sin((x + .25) * TWO_PI);\n    shadows = .5 + .5 * asin(distortion) / (.5 * PI);\n    distortion *= .5;\n    distortion -= u_shift;\n    frameFade = .5 + .5 * sin(x * TWO_PI);\n  } else if (u_distortionShape == 5.) {\n    distortion -= pow(abs(x), .2) * x;\n    distortion += .33;\n    distortion -= 3. * u_shift;\n    distortion *= .33;\n\n    frameFade = .3 * (smoothstep(.0, 1., x));\n    shadows = pow(x, 2.5);\n\n    aa = max(.1, aa);\n    aa += mix(.1, 0., u_size);\n    fadeX = smoothstep(0., aa, xNonSmooth) * smoothstep(1., 1. - aa, xNonSmooth);\n    distortion *= fadeX;\n  }\n\n  vec2 dudx = dFdx(v_imageUV);\n  vec2 dudy = dFdy(v_imageUV);\n  vec2 grainUV = v_imageUV - .5;\n  grainUV *= (.8 / vec2(length(dudx), length(dudy)));\n  grainUV += .5;\n  float grain = valueNoise(grainUV);\n  grain = smoothstep(.4, .7, grain);\n  grain *= u_grainMixer;\n  distortion = mix(distortion, 0., grain);\n\n  shadows = min(shadows, 1.);\n  shadows += maskStrokeInner;\n  shadows *= mask;\n  shadows = min(shadows, 1.);\n  shadows *= pow(u_shadows, 2.);\n  shadows = clamp(shadows, 0., 1.);\n\n  distortion *= 3. * u_distortion;\n  frameFade *= u_distortion;\n\n  fractOrigUV.x += distortion;\n  floorOrigUV = rotateAspect(floorOrigUV, -patternRotation, u_imageAspectRatio);\n  fractOrigUV = rotateAspect(fractOrigUV, -patternRotation, u_imageAspectRatio);\n\n  uv = (floorOrigUV + fractOrigUV) / patternSize;\n  uv += pow(maskStroke, 4.);\n\n  uv += vec2(.5);\n\n  uv = mix(v_imageUV, uv, smoothstep(0., .7, mask));\n  float blur = mix(0., 50., u_blur);\n  blur = mix(0., blur, smoothstep(.5, 1., mask));\n\n  float edgeDistortion = mix(.0, .04, u_edges);\n  edgeDistortion += .06 * frameFade * u_edges;\n  edgeDistortion *= mask;\n  float frame = getUvFrame(uv, edgeDistortion);\n\n  float stretch = 1. - smoothstep(0., .5, xNonSmooth) * smoothstep(1., 1. - .5, xNonSmooth);\n  stretch = pow(stretch, 2.);\n  stretch *= mask;\n  stretch *= getUvFrame(uv, .1 + .05 * mask * frameFade);\n  uv.y = mix(uv.y, .5, u_stretch * stretch);\n\n  vec4 image = getBlur(u_image, uv, 1. / u_resolution / u_pixelRatio, vec2(0., 1.), blur);\n  image.rgb *= image.a;\n  vec4 backColor = u_colorBack;\n  backColor.rgb *= backColor.a;\n  vec4 highlightColor = u_colorHighlight;\n  highlightColor.rgb *= highlightColor.a;\n  vec4 shadowColor = u_colorShadow;\n\n  vec3 color = highlightColor.rgb * highlights;\n  float opacity = highlightColor.a * highlights;\n\n  shadows = mix(shadows * shadowColor.a, 0., highlights);\n  color = mix(color, shadowColor.rgb * shadowColor.a, .5 * shadows);\n  color += .5 * pow(shadows, .5) * shadowColor.rgb;\n  opacity += shadows;\n  color = clamp(color, vec3(0.), vec3(1.));\n  opacity = clamp(opacity, 0., 1.);\n\n  color += image.rgb * (1. - opacity) * frame;\n  opacity += image.a * (1. - opacity) * frame;\n\n  color += backColor.rgb * (1. - opacity);\n  opacity += backColor.a * (1. - opacity);\n\n  float grainOverlay = valueNoise(rotate(grainUV, 1.) + vec2(3.));\n  grainOverlay = mix(grainOverlay, valueNoise(rotate(grainUV, 2.) + vec2(-1.)), .5);\n  grainOverlay = pow(grainOverlay, 1.3);\n\n  float grainOverlayV = grainOverlay * 2. - 1.;\n  vec3 grainOverlayColor = vec3(step(0., grainOverlayV));\n  float grainOverlayStrength = u_grainOverlay * abs(grainOverlayV);\n  grainOverlayStrength = pow(grainOverlayStrength, .8);\n  grainOverlayStrength *= mask;\n  color = mix(color, grainOverlayColor, .35 * grainOverlayStrength);\n\n  opacity += .5 * grainOverlayStrength;\n  opacity = clamp(opacity, 0., 1.);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface FlutedGlassUniforms extends ShaderSizingUniforms {\n  u_image: HTMLImageElement | string | undefined;\n  u_colorBack: [number, number, number, number];\n  u_colorShadow: [number, number, number, number];\n  u_colorHighlight: [number, number, number, number];\n  u_shadows: number;\n  u_size: number;\n  u_angle: number;\n  u_distortion: number;\n  u_shift: number;\n  u_blur: number;\n  u_edges: number;\n  u_marginLeft: number;\n  u_marginRight: number;\n  u_marginTop: number;\n  u_marginBottom: number;\n  u_stretch: number;\n  u_distortionShape: (typeof GlassDistortionShapes)[GlassDistortionShape];\n  u_highlights: number;\n  u_shape: (typeof GlassGridShapes)[GlassGridShape];\n  u_grainMixer: number;\n  u_grainOverlay: number;\n  u_noiseTexture?: HTMLImageElement;\n}\n\nexport interface FlutedGlassParams extends ShaderSizingParams, ShaderMotionParams {\n  image?: HTMLImageElement | string;\n  colorBack?: string;\n  colorShadow?: string;\n  colorHighlight?: string;\n  shadows?: number;\n  size?: number;\n  angle?: number;\n  distortion?: number;\n  shift?: number;\n  blur?: number;\n  edges?: number;\n  margin?: number;\n  marginLeft?: number;\n  marginRight?: number;\n  marginTop?: number;\n  marginBottom?: number;\n  stretch?: number;\n  distortionShape?: GlassDistortionShape;\n  highlights?: number;\n  shape?: GlassGridShape;\n  grainMixer?: number;\n  grainOverlay?: number;\n}\n\nexport const GlassGridShapes = {\n  lines: 1,\n  linesIrregular: 2,\n  wave: 3,\n  zigzag: 4,\n  pattern: 5,\n} as const;\n\nexport const GlassDistortionShapes = {\n  prism: 1,\n  lens: 2,\n  contour: 3,\n  cascade: 4,\n  flat: 5,\n} as const;\n\nexport type GlassDistortionShape = keyof typeof GlassDistortionShapes;\nexport type GlassGridShape = keyof typeof GlassGridShapes;\n", "import type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { proceduralHash21, declarePI } from '../shader-utils.js';\n\n/**\n * A dithering image filter with support for 4 dithering modes and multiple color palettes\n * (2-color, 3-color, and multicolor options, using either predefined colors or colors sampled\n * from the original image).\n *\n * SIZING NOTE: This shader performs sizing in the fragment shader (not vertex shader) to keep\n * u_pxSize in consistent actual pixels. The pixel grid is computed from gl_FragCoord before any\n * transforms, so scaling/rotating only affects the underlying image.\n * No vertex shader outputs (v_imageUV, v_objectUV, etc.) are used.\n *\n * Fragment shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n * - u_image (sampler2D): Source image texture\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n * - u_colorFront (vec4): Foreground color in RGBA\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colorHighlight (vec4): Secondary foreground color in RGBA (set same as colorFront for classic 2-color dithering)\n * - u_originalColors (bool): Use the original colors of the image instead of the color palette\n * - u_inverted (bool): Inverts the image luminance, doesn't affect the color scheme; not effective at zero contrast\n * - u_type (float): Dithering type (1 = random, 2 = 2x2 Bayer, 3 = 4x4 Bayer, 4 = 8x8 Bayer)\n * - u_pxSize (float): Pixel size of dithering grid (0.5 to 20)\n * - u_colorSteps (float): Number of colors to use, applies to both color modes (1 to 7)\n *\n */\n\n// language=GLSL\nexport const imageDitheringFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform vec4 u_colorFront;\nuniform vec4 u_colorBack;\nuniform vec4 u_colorHighlight;\n\nuniform sampler2D u_image;\nuniform float u_imageAspectRatio;\n\nuniform float u_type;\nuniform float u_pxSize;\nuniform bool u_originalColors;\nuniform bool u_inverted;\nuniform float u_colorSteps;\n\nout vec4 fragColor;\n\n\n${ proceduralHash21 }\n${ declarePI }\n\nfloat getUvFrame(vec2 uv, vec2 pad) {\n  float aa = 0.0001;\n\n  float left   = smoothstep(-pad.x, -pad.x + aa, uv.x);\n  float right  = smoothstep(1.0 + pad.x, 1.0 + pad.x - aa, uv.x);\n  float bottom = smoothstep(-pad.y, -pad.y + aa, uv.y);\n  float top    = smoothstep(1.0 + pad.y, 1.0 + pad.y - aa, uv.y);\n\n  return left * right * bottom * top;\n}\n\nvec2 getImageUV(vec2 uv) {\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  float r = u_rotation * PI / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n  vec2 imageBoxSize;\n  if (u_fit == 1.) { // contain\n    imageBoxSize.x = min(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else if (u_fit == 2.) { // cover\n    imageBoxSize.x = max(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else {\n    imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n  }\n  imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n  vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n  vec2 imageUV = uv;\n  imageUV *= imageBoxScale;\n  imageUV += boxOrigin * (imageBoxScale - 1.);\n  imageUV += graphicOffset;\n  imageUV /= u_scale;\n  imageUV.x *= u_imageAspectRatio;\n  imageUV = graphicRotation * imageUV;\n  imageUV.x /= u_imageAspectRatio;\n\n  imageUV += .5;\n  imageUV.y = 1. - imageUV.y;\n\n  return imageUV;\n}\n\nconst int bayer2x2[4] = int[4](0, 2, 3, 1);\nconst int bayer4x4[16] = int[16](\n0, 8, 2, 10,\n12, 4, 14, 6,\n3, 11, 1, 9,\n15, 7, 13, 5\n);\n\nconst int bayer8x8[64] = int[64](\n0, 32, 8, 40, 2, 34, 10, 42,\n48, 16, 56, 24, 50, 18, 58, 26,\n12, 44, 4, 36, 14, 46, 6, 38,\n60, 28, 52, 20, 62, 30, 54, 22,\n3, 35, 11, 43, 1, 33, 9, 41,\n51, 19, 59, 27, 49, 17, 57, 25,\n15, 47, 7, 39, 13, 45, 5, 37,\n63, 31, 55, 23, 61, 29, 53, 21\n);\n\nfloat getBayerValue(vec2 uv, int size) {\n  ivec2 pos = ivec2(fract(uv / float(size)) * float(size));\n  int index = pos.y * size + pos.x;\n\n  if (size == 2) {\n    return float(bayer2x2[index]) / 4.0;\n  } else if (size == 4) {\n    return float(bayer4x4[index]) / 16.0;\n  } else if (size == 8) {\n    return float(bayer8x8[index]) / 64.0;\n  }\n  return 0.0;\n}\n\n\nvoid main() {\n\n  float pxSize = u_pxSize * u_pixelRatio;\n  vec2 pxSizeUV = gl_FragCoord.xy - .5 * u_resolution;\n  pxSizeUV /= pxSize;\n  vec2 canvasPixelizedUV = (floor(pxSizeUV) + .5) * pxSize;\n  vec2 normalizedUV = canvasPixelizedUV / u_resolution;\n\n  vec2 imageUV = getImageUV(normalizedUV);\n  vec2 ditheringNoiseUV = canvasPixelizedUV;\n  vec4 image = texture(u_image, imageUV);\n  float frame = getUvFrame(imageUV, pxSize / u_resolution);\n\n  int type = int(floor(u_type));\n  float dithering = 0.0;\n\n  float lum = dot(vec3(.2126, .7152, .0722), image.rgb);\n  lum = u_inverted ? (1. - lum) : lum;\n\n  switch (type) {\n    case 1: {\n      dithering = step(hash21(ditheringNoiseUV), lum);\n    } break;\n    case 2:\n    dithering = getBayerValue(pxSizeUV, 2);\n    break;\n    case 3:\n    dithering = getBayerValue(pxSizeUV, 4);\n    break;\n    default :\n    dithering = getBayerValue(pxSizeUV, 8);\n    break;\n  }\n\n  float colorSteps = max(floor(u_colorSteps), 1.);\n  vec3 color = vec3(0.0);\n  float opacity = 1.;\n\n  dithering -= .5;\n  float brightness = clamp(lum + dithering / colorSteps, 0.0, 1.0);\n  brightness = mix(0.0, brightness, frame);\n  brightness = mix(0.0, brightness, image.a);\n  float quantLum = floor(brightness * colorSteps + 0.5) / colorSteps;\n  quantLum = mix(0.0, quantLum, frame);\n\n  if (u_originalColors == true) {\n    vec3 normColor = image.rgb / max(lum, 0.001);\n    color = normColor * quantLum;\n\n    float quantAlpha = floor(image.a * colorSteps + 0.5) / colorSteps;\n    opacity = mix(quantLum, 1., quantAlpha);\n  } else {\n    vec3 fgColor = u_colorFront.rgb * u_colorFront.a;\n    float fgOpacity = u_colorFront.a;\n    vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n    float bgOpacity = u_colorBack.a;\n    vec3 hlColor = u_colorHighlight.rgb * u_colorHighlight.a;\n    float hlOpacity = u_colorHighlight.a;\n\n    fgColor = mix(fgColor, hlColor, step(1.02 - .02 * u_colorSteps, brightness));\n    fgOpacity = mix(fgOpacity, hlOpacity, step(1.02 - .02 * u_colorSteps, brightness));\n\n    color = fgColor * quantLum;\n    opacity = fgOpacity * quantLum;\n    color += bgColor * (1.0 - opacity);\n    opacity += bgOpacity * (1.0 - opacity);\n  }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface ImageDitheringUniforms extends ShaderSizingUniforms {\n  u_image: HTMLImageElement | string;\n  u_colorFront: [number, number, number, number];\n  u_colorBack: [number, number, number, number];\n  u_colorHighlight: [number, number, number, number];\n  u_type: (typeof DitheringTypes)[DitheringType];\n  u_pxSize: number;\n  u_colorSteps: number;\n  u_originalColors: boolean;\n  u_inverted: boolean;\n}\n\nexport interface ImageDitheringParams extends ShaderSizingParams, ShaderMotionParams {\n  image: HTMLImageElement | string;\n  colorFront?: string;\n  colorBack?: string;\n  colorHighlight?: string;\n  type?: DitheringType;\n  size?: number;\n  colorSteps?: number;\n  originalColors?: boolean;\n  inverted?: boolean;\n}\n\nexport const DitheringTypes = {\n  'random': 1,\n  '2x2': 2,\n  '4x4': 3,\n  '8x8': 4,\n} as const;\n\nexport type DitheringType = keyof typeof DitheringTypes;\n", "import type { vec4 } from '../types.js';\nimport type { ShaderMotionParams } from '../shader-mount.js';\nimport type { ShaderSizingParams, ShaderSizingUniforms } from '../shader-sizing.js';\n\nexport const heatmapMeta = {\n  maxColorCount: 10,\n} as const;\n\n/**\n * A glowing gradient of colors flowing through an input shape.\n * The effect creates a smoothly animated wave of intensity across the image.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_image (sampler2D): Pre-processed source image texture (R = contour, G = outer blur, B = inner blur)\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colors (vec4[]): Up to 10 heatmap colors in RGBA\n * - u_colorsCount (float): Number of active colors\n * - u_contour (float): Heat intensity near the edges of the input shape (0 to 1)\n * - u_angle (float): Direction of the heatwaves in degrees (0 to 360)\n * - u_noise (float): Grain applied across the entire graphic (0 to 1)\n * - u_innerGlow (float): Size of the heated area inside the input shape (0 to 1)\n * - u_outerGlow (float): Size of the heated area outside the input shape (0 to 1)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_imageUV (vec2): UV coordinates for sampling the source image, with fit, scale, rotation, and offset applied\n * - v_objectUV (vec2): Object box UV coordinates with global sizing (scale, rotation, offsets, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n *\n */\n\n// language=GLSL\nexport const heatmapFragmentShader: string = `#version 300 es\nprecision highp float;\n\nin mediump vec2 v_imageUV;\nin mediump vec2 v_objectUV;\nout vec4 fragColor;\n\nuniform sampler2D u_image;\nuniform float u_time;\nuniform mediump float u_imageAspectRatio;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colors[${ heatmapMeta.maxColorCount }];\nuniform float u_colorsCount;\n\nuniform float u_angle;\nuniform float u_noise;\nuniform float u_innerGlow;\nuniform float u_outerGlow;\nuniform float u_contour;\n\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n\nfloat getImgFrame(vec2 uv, float th) {\n  float frame = 1.;\n  frame *= smoothstep(0., th, uv.y);\n  frame *= 1. - smoothstep(1. - th, 1., uv.y);\n  frame *= smoothstep(0., th, uv.x);\n  frame *= 1. - smoothstep(1. - th, 1., uv.x);\n  return frame;\n}\n\nfloat circle(vec2 uv, vec2 c, vec2 r) {\n  return 1. - smoothstep(r[0], r[1], length(uv - c));\n}\n\nfloat lst(float edge0, float edge1, float x) {\n  return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nfloat sst(float edge0, float edge1, float x) {\n  return smoothstep(edge0, edge1, x);\n}\n\nfloat shadowShape(vec2 uv, float t, float contour) {\n  vec2 scaledUV = uv;\n\n  // base shape tranjectory\n  float posY = mix(-1., 2., t);\n\n  // scaleX when it's moving down\n  scaledUV.y -= .5;\n  float mainCircleScale = sst(0., .8, posY) * lst(1.4, .9, posY);\n  scaledUV *= vec2(1., 1. + 1.5 * mainCircleScale);\n  scaledUV.y += .5;\n\n  // base shape\n  float innerR = .4;\n  float outerR = 1. - .3 * (sst(.1, .2, t) * (1. - sst(.2, .5, t)));\n  float s = circle(scaledUV, vec2(.5, posY - .2), vec2(innerR, outerR));\n  float shapeSizing = sst(.2, .3, t) * sst(.6, .3, t);\n  s = pow(s, 1.4);\n  s *= 1.2;\n\n  // flat gradient to take over the shadow shape\n  float topFlattener = 0.;\n  {\n    float pos = posY - uv.y;\n    float edge = 1.2;\n    topFlattener = lst(-.4, 0., pos) * (1. - sst(.0, edge, pos));\n    topFlattener = pow(topFlattener, 3.);\n    float topFlattenerMixer = (1. - sst(.0, .3, pos));\n    s = mix(topFlattener, s, topFlattenerMixer);\n  }\n\n  // apple right circle\n  {\n    float visibility = sst(.6, .7, t) * (1. - sst(.8, .9, t));\n    float angle = -2. -t * TWO_PI;\n    float rightCircle = circle(uv, vec2(.95 - .2 * cos(angle), .4 - .1 * sin(angle)), vec2(.15, .3));\n    rightCircle *= visibility;\n    s = mix(s, 0., rightCircle);\n  }\n\n  // apple top circle\n  {\n    float topCircle = circle(uv, vec2(.5, .19), vec2(.05, .25));\n    topCircle += 2. * contour * circle(uv, vec2(.5, .19), vec2(.2, .5));\n    float visibility = .55 * sst(.2, .3, t) * (1. - sst(.3, .45, t));\n    topCircle *= visibility;\n    s = mix(s, 0., topCircle);\n  }\n\n  float leafMask = circle(uv, vec2(.53, .13), vec2(.08, .19));\n  leafMask = mix(leafMask, 0., 1. - sst(.4, .54, uv.x));\n  leafMask = mix(0., leafMask, sst(.0, .2, uv.y));\n  leafMask *= (sst(.5, 1.1, posY) * sst(1.5, 1.3, posY));\n  s += leafMask;\n\n  // apple bottom circle\n  {\n    float visibility = sst(.0, .4, t) * (1. - sst(.6, .8, t));\n    s = mix(s, 0., visibility * circle(uv, vec2(.52, .92), vec2(.09, .25)));\n  }\n\n  // random balls that are invisible if apple logo is selected\n  {\n    float pos = sst(.0, .6, t) * (1. - sst(.6, 1., t));\n    s = mix(s, .5, circle(uv, vec2(.0, 1.2 - .5 * pos), vec2(.1, .3)));\n    s = mix(s, .0, circle(uv, vec2(1., .5 + .5 * pos), vec2(.1, .3)));\n\n    s = mix(s, 1., circle(uv, vec2(.95, .2 + .2 * sst(.3, .4, t) * sst(.7, .5, t)), vec2(.07, .22)));\n    s = mix(s, 1., circle(uv, vec2(.95, .2 + .2 * sst(.3, .4, t) * (1. - sst(.5, .7, t))), vec2(.07, .22)));\n    s /= max(1e-4, sst(1., .85, uv.y));\n  }\n\n  s = clamp(0., 1., s);\n  return s;\n}\n\nfloat blurEdge3x3(sampler2D tex, vec2 uv, vec2 dudx, vec2 dudy, float radius, float centerSample) {\n  vec2 texel = 1.0 / vec2(textureSize(tex, 0));\n  vec2 r = radius * texel;\n\n  float w1 = 1.0, w2 = 2.0, w4 = 4.0;\n  float norm = 16.0;\n  float sum = w4 * centerSample;\n\n  sum += w2 * textureGrad(tex, uv + vec2(0.0, -r.y), dudx, dudy).g;\n  sum += w2 * textureGrad(tex, uv + vec2(0.0, r.y), dudx, dudy).g;\n  sum += w2 * textureGrad(tex, uv + vec2(-r.x, 0.0), dudx, dudy).g;\n  sum += w2 * textureGrad(tex, uv + vec2(r.x, 0.0), dudx, dudy).g;\n\n  sum += w1 * textureGrad(tex, uv + vec2(-r.x, -r.y), dudx, dudy).g;\n  sum += w1 * textureGrad(tex, uv + vec2(r.x, -r.y), dudx, dudy).g;\n  sum += w1 * textureGrad(tex, uv + vec2(-r.x, r.y), dudx, dudy).g;\n  sum += w1 * textureGrad(tex, uv + vec2(r.x, r.y), dudx, dudy).g;\n\n  return sum / norm;\n}\n\nvoid main() {\n  vec2 uv = v_objectUV + .5;\n  uv.y = 1. - uv.y;\n\n  vec2 imgUV = v_imageUV;\n  imgUV -= .5;\n  imgUV *= 0.5714285714285714;\n  imgUV += .5;\n  float imgSoftFrame = getImgFrame(imgUV, .03);\n\n  vec4 img = texture(u_image, imgUV);\n  vec2 dudx = dFdx(imgUV);\n  vec2 dudy = dFdy(imgUV);\n\n  if (img.a == 0.) {\n    fragColor = u_colorBack;\n    return;\n  }\n\n  float t = .1 * u_time;\n  t -= .3;\n\n  float tCopy = t + 1. / 3.;\n  float tCopy2 = t + 2. / 3.;\n\n  t = mod(t, 1.);\n  tCopy = mod(tCopy, 1.);\n  tCopy2 = mod(tCopy2, 1.);\n\n  vec2 animationUV = imgUV - vec2(.5);\n  float angle = -u_angle * PI / 180.;\n  float cosA = cos(angle);\n  float sinA = sin(angle);\n  animationUV = vec2(\n  animationUV.x * cosA - animationUV.y * sinA,\n  animationUV.x * sinA + animationUV.y * cosA\n  ) + vec2(.5);\n\n  float shape = img[0];\n\n  img[1] = blurEdge3x3(u_image, imgUV, dudx, dudy, 8., img[1]);\n\n  float outerBlur = 1. - mix(1., img[1], shape);\n  float innerBlur = mix(img[1], 0., shape);\n  float contour = mix(img[2], 0., shape);\n\n  outerBlur *= imgSoftFrame;\n\n  float shadow = shadowShape(animationUV, t, innerBlur);\n  float shadowCopy = shadowShape(animationUV, tCopy, innerBlur);\n  float shadowCopy2 = shadowShape(animationUV, tCopy2, innerBlur);\n\n  float inner = .8 + .8 * innerBlur;\n  inner = mix(inner, 0., shadow);\n  inner = mix(inner, 0., shadowCopy);\n  inner = mix(inner, 0., shadowCopy2);\n\n  inner *= mix(0., 2., u_innerGlow);\n\n  inner += (u_contour * 2.) * contour;\n  inner = min(1., inner);\n  inner *= (1. - shape);\n\n  float outer = 0.;\n  {\n    t *= 3.;\n    t = mod(t - .1, 1.);\n\n    outer = .9 * pow(outerBlur, .8);\n    float y = mod(animationUV.y - t, 1.);\n    float animatedMask = sst(.3, .65, y) * (1. - sst(.65, 1., y));\n    animatedMask = .5 + animatedMask;\n    outer *= animatedMask;\n    outer *= mix(0., 5., pow(u_outerGlow, 2.));\n    outer *= imgSoftFrame;\n  }\n\n  inner = pow(inner, 1.2);\n  float heat = clamp(inner + outer, 0., 1.);\n\n  heat += (.005 + .35 * u_noise) * (fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453123) - .5);\n\n  float mixer = heat * u_colorsCount;\n  vec4 gradient = u_colors[0];\n  gradient.rgb *= gradient.a;\n  float outerShape = 0.;\n  for (int i = 1; i < ${ heatmapMeta.maxColorCount + 1 }; i++) {\n    if (i > int(u_colorsCount)) break;\n    float m = clamp(mixer - float(i - 1), 0., 1.);\n    if (i == 1) {\n      outerShape = m;\n    }\n    vec4 c = u_colors[i - 1];\n    c.rgb *= c.a;\n    gradient = mix(gradient, c, m);\n  }\n\n  vec3 color = gradient.rgb * outerShape;\n  float opacity = gradient.a * outerShape;\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1.0 - opacity);\n  opacity = opacity + u_colorBack.a * (1.0 - opacity);\n\n  color += .02 * (fract(sin(dot(uv + 1., vec2(12.9898, 78.233))) * 43758.5453123) - .5);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport function toProcessedHeatmap(file: File | string): Promise<{ blob: Blob }> {\n  const canvas = document.createElement('canvas');\n  const canvasSize = 1000;\n\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n    image.crossOrigin = 'anonymous';\n\n    image.addEventListener('load', () => {\n      if (typeof file === 'string' ? file.endsWith('.svg') : file.type === 'image/svg+xml') {\n        // Force SVG to load at a high fidelity size if it's an SVG\n        image.width = canvasSize;\n        image.height = canvasSize;\n      }\n\n      const ratio = image.naturalWidth / image.naturalHeight;\n\n      const maxBlur = Math.floor(canvasSize * 0.15);\n      const padding = Math.ceil(maxBlur * 2.5);\n      let imgWidth = canvasSize;\n      let imgHeight = canvasSize;\n      if (ratio > 1) {\n        imgHeight = Math.floor(canvasSize / ratio);\n      } else {\n        imgWidth = Math.floor(canvasSize * ratio);\n      }\n\n      canvas.width = imgWidth + 2 * padding;\n      canvas.height = imgHeight + 2 * padding;\n\n      const ctx = canvas.getContext('2d', { willReadFrequently: true });\n      if (!ctx) {\n        throw new Error('Failed to get canvas 2d context');\n      }\n\n      // 1) Draw original image once, no filters\n      ctx.fillStyle = 'white';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      ctx.drawImage(image, padding, padding, imgWidth, imgHeight);\n\n      const { width, height } = canvas;\n      const srcImageData = ctx.getImageData(0, 0, width, height);\n      const src = srcImageData.data; // RGBA\n\n      // 2) Build grayscale array (luma)\n      const totalPixels = width * height;\n      const gray = new Uint8ClampedArray(totalPixels);\n      for (let i = 0; i < totalPixels; i++) {\n        const px = i * 4;\n        const r = src[px] ?? 0;\n        const g = src[px + 1] ?? 0;\n        const b = src[px + 2] ?? 0;\n        // Standard luma conversion\n        gray[i] = (0.299 * r + 0.587 * g + 0.114 * b) | 0;\n      }\n\n      // 3) Blur grayscale for each \"filter\" you previously used\n      const bigBlurRadius = maxBlur;\n      const innerBlurRadius = Math.max(1, Math.round(0.12 * maxBlur));\n      const contourRadius = 5;\n\n      const bigBlurGray = multiPassBlurGray(gray, width, height, bigBlurRadius, 3);\n      const innerBlurGray = multiPassBlurGray(gray, width, height, innerBlurRadius, 3);\n      const contourGray = multiPassBlurGray(gray, width, height, contourRadius, 1);\n\n      // 4) Combine into final ImageData\n      const processedImageData = ctx.createImageData(width, height);\n      const dst = processedImageData.data;\n\n      for (let i = 0; i < totalPixels; i++) {\n        const px = i * 4;\n        dst[px] = contourGray[i] ?? 0;\n        dst[px + 1] = bigBlurGray[i] ?? 0;\n        dst[px + 2] = innerBlurGray[i] ?? 0;\n        dst[px + 3] = 255;\n      }\n\n      ctx.putImageData(processedImageData, 0, 0);\n\n      canvas.toBlob((blob) => {\n        if (!blob) {\n          reject(new Error('Failed to create PNG blob'));\n          return;\n        }\n        resolve({ blob });\n      }, 'image/png');\n    });\n\n    image.addEventListener('error', () => {\n      reject(new Error('Failed to load image'));\n    });\n\n    image.src = typeof file === 'string' ? file : URL.createObjectURL(file);\n  });\n}\n\n/**\n * Fast box blur for grayscale images using an integral image.\n * gray: Uint8ClampedArray of length width * height\n * radius: blur radius in pixels\n */\nfunction blurGray(gray: Uint8ClampedArray, width: number, height: number, radius: number): Uint8ClampedArray {\n  if (radius <= 0) {\n    return gray.slice();\n  }\n\n  const out = new Uint8ClampedArray(width * height);\n  const integral = new Uint32Array(width * height);\n\n  // Build integral image\n  for (let y = 0; y < height; y++) {\n    let rowSum = 0;\n    for (let x = 0; x < width; x++) {\n      const idx = y * width + x;\n      const v = gray[idx] ?? 0;\n      rowSum += v;\n      integral[idx] = rowSum + (y > 0 ? (integral[idx - width] ?? 0) : 0);\n    }\n  }\n\n  // Blur using integral image\n  for (let y = 0; y < height; y++) {\n    const y1 = Math.max(0, y - radius);\n    const y2 = Math.min(height - 1, y + radius);\n    for (let x = 0; x < width; x++) {\n      const x1 = Math.max(0, x - radius);\n      const x2 = Math.min(width - 1, x + radius);\n\n      const idxA = y2 * width + x2;\n      const idxB = y2 * width + (x1 - 1);\n      const idxC = (y1 - 1) * width + x2;\n      const idxD = (y1 - 1) * width + (x1 - 1);\n\n      const A = integral[idxA] ?? 0;\n      const B = x1 > 0 ? (integral[idxB] ?? 0) : 0;\n      const C = y1 > 0 ? (integral[idxC] ?? 0) : 0;\n      const D = x1 > 0 && y1 > 0 ? (integral[idxD] ?? 0) : 0;\n\n      const sum = A - B - C + D;\n      const area = (x2 - x1 + 1) * (y2 - y1 + 1);\n      out[y * width + x] = Math.round(sum / area);\n    }\n  }\n\n  return out;\n}\n\nfunction multiPassBlurGray(\n  gray: Uint8ClampedArray,\n  width: number,\n  height: number,\n  radius: number,\n  passes: number\n): Uint8ClampedArray {\n  if (radius <= 0 || passes <= 1) {\n    return blurGray(gray, width, height, radius);\n  }\n\n  let input = gray;\n  let tmp: Uint8ClampedArray = gray;\n\n  for (let p = 0; p < passes; p++) {\n    tmp = blurGray(input, width, height, radius);\n    input = tmp;\n  }\n\n  return tmp;\n}\n\nexport interface HeatmapUniforms extends ShaderSizingUniforms {\n  u_image: HTMLImageElement | string;\n  u_contour: number;\n  u_angle: number;\n  u_noise: number;\n  u_innerGlow: number;\n  u_outerGlow: number;\n  u_colorBack: [number, number, number, number];\n  u_colors: vec4[];\n  u_colorsCount: number;\n}\n\nexport interface HeatmapParams extends ShaderSizingParams, ShaderMotionParams {\n  image: HTMLImageElement | string;\n  contour?: number;\n  angle?: number;\n  noise?: number;\n  innerGlow?: number;\n  outerGlow?: number;\n  colorBack?: string;\n  colors?: string[];\n}\n", "import type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, rotation2, simplexNoise, colorBandingFix } from '../shader-utils.js';\n\n/**\n * Futuristic liquid metal material applied to uploaded logo or abstract shape.\n * Fluid motion imitation applied over user image with animated stripe pattern\n * getting distorted along shape edges.\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_image (sampler2D): Pre-processed source image texture (R = edge gradient, G = opacity)\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n * - u_colorBack (vec4): Background color in RGBA\n * - u_colorTint (vec4): Overlay color in RGBA (color burn blending used)\n * - u_repetition (float): Density of pattern stripes (1 to 10)\n * - u_softness (float): Color transition sharpness, 0 = hard edge, 1 = smooth gradient (0 to 1)\n * - u_shiftRed (float): R-channel dispersion (-1 to 1)\n * - u_shiftBlue (float): B-channel dispersion (-1 to 1)\n * - u_distortion (float): Noise distortion over the stripes pattern (0 to 1)\n * - u_contour (float): Strength of the distortion on the shape edges (0 to 1)\n * - u_angle (float): Direction of pattern animation in degrees (0 to 360)\n * - u_shape (float): Predefined shape when no image provided (0 = none, 1 = circle, 2 = daisy, 3 = diamond, 4 = metaballs)\n * - u_isImage (bool): Whether an image is being used as the effect mask\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_imageUV (vec2): UV coordinates for sampling the source image, with fit, scale, rotation, and offset applied\n * - v_objectUV (vec2): Object box UV coordinates with global sizing (scale, rotation, offsets, etc) applied (used when no image)\n * - v_responsiveUV (vec2): Responsive UV coordinates that adapt to canvas aspect ratio (used for canvas-fill mode)\n * - v_responsiveBoxGivenSize (vec2): TBD\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n *\n */\n\n// language=GLSL\nexport const liquidMetalFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_image;\nuniform float u_imageAspectRatio;\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colorTint;\n\nuniform float u_softness;\nuniform float u_repetition;\nuniform float u_shiftRed;\nuniform float u_shiftBlue;\nuniform float u_distortion;\nuniform float u_contour;\nuniform float u_angle;\n\nuniform float u_shape;\nuniform bool u_isImage;\n\nin vec2 v_objectUV;\nin vec2 v_responsiveUV;\nin vec2 v_responsiveBoxGivenSize;\nin vec2 v_imageUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ rotation2 }\n${ simplexNoise }\n\nfloat getColorChanges(float c1, float c2, float stripe_p, vec3 w, float blur, float bump, float tint) {\n\n  float ch = mix(c2, c1, smoothstep(.0, 2. * blur, stripe_p));\n\n  float border = w[0];\n  ch = mix(ch, c2, smoothstep(border, border + 2. * blur, stripe_p));\n\n  if (u_isImage == true) {\n    bump = smoothstep(.2, .8, bump);\n  }\n  border = w[0] + .4 * (1. - bump) * w[1];\n  ch = mix(ch, c1, smoothstep(border, border + 2. * blur, stripe_p));\n\n  border = w[0] + .5 * (1. - bump) * w[1];\n  ch = mix(ch, c2, smoothstep(border, border + 2. * blur, stripe_p));\n\n  border = w[0] + w[1];\n  ch = mix(ch, c1, smoothstep(border, border + 2. * blur, stripe_p));\n\n  float gradient_t = (stripe_p - w[0] - w[1]) / w[2];\n  float gradient = mix(c1, c2, smoothstep(0., 1., gradient_t));\n  ch = mix(ch, gradient, smoothstep(border, border + .5 * blur, stripe_p));\n\n  // Tint color is applied with color burn blending\n  ch = mix(ch, 1. - min(1., (1. - ch) / max(tint, 0.0001)), u_colorTint.a);\n  return ch;\n}\n\nfloat getImgFrame(vec2 uv, float th) {\n  float frame = 1.;\n  frame *= smoothstep(0., th, uv.y);\n  frame *= 1.0 - smoothstep(1. - th, 1., uv.y);\n  frame *= smoothstep(0., th, uv.x);\n  frame *= 1.0 - smoothstep(1. - th, 1., uv.x);\n  return frame;\n}\n\nfloat blurEdge3x3(sampler2D tex, vec2 uv, vec2 dudx, vec2 dudy, float radius, float centerSample) {\n  vec2 texel = 1.0 / vec2(textureSize(tex, 0));\n  vec2 r = radius * texel;\n\n  float w1 = 1.0, w2 = 2.0, w4 = 4.0;\n  float norm = 16.0;\n  float sum = w4 * centerSample;\n\n  sum += w2 * textureGrad(tex, uv + vec2(0.0, -r.y), dudx, dudy).r;\n  sum += w2 * textureGrad(tex, uv + vec2(0.0, r.y), dudx, dudy).r;\n  sum += w2 * textureGrad(tex, uv + vec2(-r.x, 0.0), dudx, dudy).r;\n  sum += w2 * textureGrad(tex, uv + vec2(r.x, 0.0), dudx, dudy).r;\n\n  sum += w1 * textureGrad(tex, uv + vec2(-r.x, -r.y), dudx, dudy).r;\n  sum += w1 * textureGrad(tex, uv + vec2(r.x, -r.y), dudx, dudy).r;\n  sum += w1 * textureGrad(tex, uv + vec2(-r.x, r.y), dudx, dudy).r;\n  sum += w1 * textureGrad(tex, uv + vec2(r.x, r.y), dudx, dudy).r;\n\n  return sum / norm;\n}\n\nfloat lst(float edge0, float edge1, float x) {\n  return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nvoid main() {\n\n  const float firstFrameOffset = 2.8;\n  float t = .3 * (u_time + firstFrameOffset);\n\n  vec2 uv = v_imageUV;\n  vec2 dudx = dFdx(v_imageUV);\n  vec2 dudy = dFdy(v_imageUV);\n  vec4 img = textureGrad(u_image, uv, dudx, dudy);\n\n  if (u_isImage == false) {\n    uv = v_objectUV + .5;\n    uv.y = 1. - uv.y;\n  }\n\n  float cycleWidth = u_repetition;\n  float edge = 0.;\n  float contOffset = 1.;\n\n  vec2 rotatedUV = uv - vec2(.5);\n  float angle = (-u_angle + 70.) * PI / 180.;\n  float cosA = cos(angle);\n  float sinA = sin(angle);\n  rotatedUV = vec2(\n  rotatedUV.x * cosA - rotatedUV.y * sinA,\n  rotatedUV.x * sinA + rotatedUV.y * cosA\n  ) + vec2(.5);\n\n  if (u_isImage == true) {\n    float edgeRaw = img.r;\n    edge = blurEdge3x3(u_image, uv, dudx, dudy, 6., edgeRaw);\n    edge = pow(edge, 1.6);\n    edge *= mix(0.0, 1.0, smoothstep(0.0, 0.4, u_contour));\n  } else {\n    if (u_shape < 1.) {\n      // full-fill on canvas\n      vec2 borderUV = v_responsiveUV + .5;\n      float ratio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n      vec2 mask = min(borderUV, 1. - borderUV);\n      vec2 pixel_thickness = 250. / v_responsiveBoxGivenSize;\n      float maskX = smoothstep(0.0, pixel_thickness.x, mask.x);\n      float maskY = smoothstep(0.0, pixel_thickness.y, mask.y);\n      maskX = pow(maskX, .25);\n      maskY = pow(maskY, .25);\n      edge = clamp(1. - maskX * maskY, 0., 1.);\n\n      uv = v_responsiveUV;\n      if (ratio > 1.) {\n        uv.y /= ratio;\n      } else {\n        uv.x *= ratio;\n      }\n      uv += .5;\n      uv.y = 1. - uv.y;\n\n      cycleWidth *= 2.;\n      contOffset = 1.5;\n\n    } else if (u_shape < 2.) {\n      // circle\n      vec2 shapeUV = uv - .5;\n      shapeUV *= .67;\n      edge = pow(clamp(3. * length(shapeUV), 0., 1.), 18.);\n    } else if (u_shape < 3.) {\n      // daisy\n      vec2 shapeUV = uv - .5;\n      shapeUV *= 1.68;\n\n      float r = length(shapeUV) * 2.;\n      float a = atan(shapeUV.y, shapeUV.x) + .2;\n      r *= (1. + .05 * sin(3. * a + 2. * t));\n      float f = abs(cos(a * 3.));\n      edge = smoothstep(f, f + .7, r);\n      edge *= edge;\n\n      uv *= .8;\n      cycleWidth *= 1.6;\n\n    } else if (u_shape < 4.) {\n      // diamond\n      vec2 shapeUV = uv - .5;\n      shapeUV = rotate(shapeUV, .25 * PI);\n      shapeUV *= 1.42;\n      shapeUV += .5;\n      vec2 mask = min(shapeUV, 1. - shapeUV);\n      vec2 pixel_thickness = vec2(.15);\n      float maskX = smoothstep(0.0, pixel_thickness.x, mask.x);\n      float maskY = smoothstep(0.0, pixel_thickness.y, mask.y);\n      maskX = pow(maskX, .25);\n      maskY = pow(maskY, .25);\n      edge = clamp(1. - maskX * maskY, 0., 1.);\n    } else if (u_shape < 5.) {\n      // metaballs\n      vec2 shapeUV = uv - .5;\n      shapeUV *= 1.3;\n      edge = 0.;\n      for (int i = 0; i < 5; i++) {\n        float fi = float(i);\n        float speed = 1.5 + 2./3. * sin(fi * 12.345);\n        float angle = -fi * 1.5;\n        vec2 dir1 = vec2(cos(angle), sin(angle));\n        vec2 dir2 = vec2(cos(angle + 1.57), sin(angle + 1.));\n        vec2 traj = .4 * (dir1 * sin(t * speed + fi * 1.23) + dir2 * cos(t * (speed * 0.7) + fi * 2.17));\n        float d = length(shapeUV + traj);\n        edge += pow(1.0 - clamp(d, 0.0, 1.0), 4.0);\n      }\n      edge = 1. - smoothstep(.65, .9, edge);\n      edge = pow(edge, 4.);\n    }\n\n    edge = mix(smoothstep(.9 - 2. * fwidth(edge), .9, edge), edge, smoothstep(0.0, 0.4, u_contour));\n\n  }\n\n  float opacity = 0.;\n  if (u_isImage == true) {\n    opacity = img.g;\n    float frame = getImgFrame(v_imageUV, 0.);\n    opacity *= frame;\n  } else {\n    opacity = 1. - smoothstep(.9 - 2. * fwidth(edge), .9, edge);\n    if (u_shape < 2.) {\n      edge = 1.2 * edge;\n    } else if (u_shape < 5.) {\n      edge = 1.8 * pow(edge, 1.5);\n    }\n  }\n\n  float diagBLtoTR = rotatedUV.x - rotatedUV.y;\n  float diagTLtoBR = rotatedUV.x + rotatedUV.y;\n\n  vec3 color = vec3(0.);\n  vec3 color1 = vec3(.98, 0.98, 1.);\n  vec3 color2 = vec3(.1, .1, .1 + .1 * smoothstep(.7, 1.3, diagTLtoBR));\n\n  vec2 grad_uv = uv - .5;\n\n  float dist = length(grad_uv + vec2(0., .2 * diagBLtoTR));\n  grad_uv = rotate(grad_uv, (.25 - .2 * diagBLtoTR) * PI);\n  float direction = grad_uv.x;\n\n  float bump = pow(1.8 * dist, 1.2);\n  bump = 1. - bump;\n  bump *= pow(uv.y, .3);\n\n\n  float thin_strip_1_ratio = .12 / cycleWidth * (1. - .4 * bump);\n  float thin_strip_2_ratio = .07 / cycleWidth * (1. + .4 * bump);\n  float wide_strip_ratio = (1. - thin_strip_1_ratio - thin_strip_2_ratio);\n\n  float thin_strip_1_width = cycleWidth * thin_strip_1_ratio;\n  float thin_strip_2_width = cycleWidth * thin_strip_2_ratio;\n\n  float noise = snoise(uv - t);\n\n  edge += (1. - edge) * u_distortion * noise;\n\n  direction += diagBLtoTR;\n  float contour = 0.;\n  direction -= 2. * noise * diagBLtoTR * (smoothstep(0., 1., edge) * (1.0 - smoothstep(0., 1., edge)));\n  direction *= mix(1., 1. - edge, smoothstep(.5, 1., u_contour));\n  direction -= 1.7 * edge * smoothstep(.5, 1., u_contour);\n  direction += .2 * pow(u_contour, 4.) * (1.0 - smoothstep(0., 1., edge));\n\n  bump *= clamp(pow(uv.y, .1), .3, 1.);\n  direction *= (.1 + (1.1 - edge) * bump);\n\n  direction *= (.4 + .6 * (1.0 - smoothstep(.5, 1., edge)));\n  direction += .18 * (smoothstep(.1, .2, uv.y) * (1.0 - smoothstep(.2, .4, uv.y)));\n  direction += .03 * (smoothstep(.1, .2, 1. - uv.y) * (1.0 - smoothstep(.2, .4, 1. - uv.y)));\n\n  direction *= (.5 + .5 * pow(uv.y, 2.));\n  direction *= cycleWidth;\n  direction -= t;\n\n\n  float colorDispersion = (1. - bump);\n  colorDispersion = clamp(colorDispersion, 0., 1.);\n  float dispersionRed = colorDispersion;\n  dispersionRed += .03 * bump * noise;\n  dispersionRed += 5. * (smoothstep(-.1, .2, uv.y) * (1.0 - smoothstep(.1, .5, uv.y))) * (smoothstep(.4, .6, bump) * (1.0 - smoothstep(.4, 1., bump)));\n  dispersionRed -= diagBLtoTR;\n\n  float dispersionBlue = colorDispersion;\n  dispersionBlue *= 1.3;\n  dispersionBlue += (smoothstep(0., .4, uv.y) * (1.0 - smoothstep(.1, .8, uv.y))) * (smoothstep(.4, .6, bump) * (1.0 - smoothstep(.4, .8, bump)));\n  dispersionBlue -= .2 * edge;\n\n  dispersionRed *= (u_shiftRed / 20.);\n  dispersionBlue *= (u_shiftBlue / 20.);\n\n  float blur = 0.;\n  float rExtraBlur = 0.;\n  float gExtraBlur = 0.;\n  if (u_isImage == true) {\n    float softness = 0.05 * u_softness;\n    blur = softness + .5 * smoothstep(1., 10., u_repetition) * smoothstep(.0, 1., edge);\n    float smallCanvasT = 1.0 - smoothstep(100., 500., min(u_resolution.x, u_resolution.y));\n    blur += smallCanvasT * smoothstep(.0, 1., edge);\n    rExtraBlur = softness * (0.05 + .1 * (u_shiftRed / 20.) * bump);\n    gExtraBlur = softness * 0.05 / max(0.001, abs(1. - diagBLtoTR));\n  } else {\n    blur = u_softness / 15. + .3 * contour;\n  }\n\n  vec3 w = vec3(thin_strip_1_width, thin_strip_2_width, wide_strip_ratio);\n  w[1] -= .02 * smoothstep(.0, 1., edge + bump);\n  float stripe_r = fract(direction + dispersionRed);\n  float r = getColorChanges(color1.r, color2.r, stripe_r, w, blur + fwidth(stripe_r) + rExtraBlur, bump, u_colorTint.r);\n  float stripe_g = fract(direction);\n  float g = getColorChanges(color1.g, color2.g, stripe_g, w, blur + fwidth(stripe_g) + gExtraBlur, bump, u_colorTint.g);\n  float stripe_b = fract(direction - dispersionBlue);\n  float b = getColorChanges(color1.b, color2.b, stripe_b, w, blur + fwidth(stripe_b), bump, u_colorTint.b);\n\n  color = vec3(r, g, b);\n  color *= opacity;\n\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  color = color + bgColor * (1. - opacity);\n  opacity = opacity + u_colorBack.a * (1. - opacity);\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\n// Configuration for Poisson solver\nexport const POISSON_CONFIG_OPTIMIZED = {\n  measurePerformance: false, // Set to true to see performance metrics\n  workingSize: 512, // Size to solve Poisson at (will upscale to original size)\n  iterations: 40, // SOR converges ~2-20x faster than standard Gauss-Seidel\n};\n\n// Precomputed pixel data for sparse processing\ninterface SparsePixelData {\n  interiorPixels: Uint32Array; // Indices of interior pixels\n  boundaryPixels: Uint32Array; // Indices of boundary pixels\n  pixelCount: number;\n  // Neighbor indices for each interior pixel (4 neighbors per pixel)\n  // Layout: [east, west, north, south] for each pixel\n  neighborIndices: Int32Array;\n}\n\nexport function toProcessedLiquidMetal(file: File | string): Promise<{ imageData: ImageData; pngBlob: Blob }> {\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const isBlob = typeof file === 'string' && file.startsWith('blob:');\n\n  return new Promise((resolve, reject) => {\n    if (!file || !ctx) {\n      reject(new Error('Invalid file or canvas context'));\n      return;\n    }\n\n    const blobContentTypePromise = isBlob && fetch(file).then((res) => res.headers.get('Content-Type'));\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    const totalStartTime = performance.now();\n\n    img.onload = async () => {\n      // Force SVG to load at a high fidelity size if it's an SVG\n      let isSVG;\n\n      const blobContentType = await blobContentTypePromise;\n\n      if (blobContentType) {\n        isSVG = blobContentType === 'image/svg+xml';\n      } else if (typeof file === 'string') {\n        isSVG = file.endsWith('.svg') || file.startsWith('data:image/svg+xml');\n      } else {\n        isSVG = file.type === 'image/svg+xml';\n      }\n\n      let originalWidth = img.width || img.naturalWidth;\n      let originalHeight = img.height || img.naturalHeight;\n\n      if (isSVG) {\n        // Scale SVG to max dimension while preserving aspect ratio\n        const svgMaxSize = 4096;\n        const aspectRatio = originalWidth / originalHeight;\n\n        if (originalWidth > originalHeight) {\n          originalWidth = svgMaxSize;\n          originalHeight = svgMaxSize / aspectRatio;\n        } else {\n          originalHeight = svgMaxSize;\n          originalWidth = svgMaxSize * aspectRatio;\n        }\n\n        img.width = originalWidth;\n        img.height = originalHeight;\n      }\n\n      // Always scale to working resolution for consistency\n      const minDimension = Math.min(originalWidth, originalHeight);\n      const targetSize = POISSON_CONFIG_OPTIMIZED.workingSize;\n\n      // Calculate scale to fit within workingSize\n      const scaleFactor = targetSize / minDimension;\n      const width = Math.round(originalWidth * scaleFactor);\n      const height = Math.round(originalHeight * scaleFactor);\n\n      if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n        console.log(`[Processing Mode]`);\n        console.log(`  Original: ${originalWidth}\u00D7${originalHeight}`);\n        console.log(`  Working: ${width}\u00D7${height} (${(scaleFactor * 100).toFixed(1)}% scale)`);\n        if (scaleFactor < 1) {\n          console.log(`  Speedup: ~${Math.round(1 / (scaleFactor * scaleFactor))}\u00D7`);\n        }\n      }\n\n      canvas.width = originalWidth;\n      canvas.height = originalHeight;\n\n      // Use a smaller canvas for shape detection and Poisson solving\n      const shapeCanvas = document.createElement('canvas');\n      shapeCanvas.width = width;\n      shapeCanvas.height = height;\n\n      const shapeCtx = shapeCanvas.getContext('2d')!;\n      shapeCtx.drawImage(img, 0, 0, width, height);\n\n      // 1) Build optimized masks using TypedArrays\n      const startMask = performance.now();\n\n      const shapeImageData = shapeCtx.getImageData(0, 0, width, height);\n      const data = shapeImageData.data;\n\n      // Use Uint8Array for masks (1 byte per pixel vs 8+ bytes for boolean array)\n      const shapeMask = new Uint8Array(width * height);\n      const boundaryMask = new Uint8Array(width * height);\n\n      // First pass: identify shape pixels\n      let shapePixelCount = 0;\n      for (let i = 0, idx = 0; i < data.length; i += 4, idx++) {\n        const a = data[i + 3];\n        const isShape = a === 0 ? 0 : 1;\n        shapeMask[idx] = isShape;\n        shapePixelCount += isShape;\n      }\n\n      // 2) Optimized boundary detection using sparse approach\n      // Only check shape pixels, not all pixels\n      const boundaryIndices: number[] = [];\n      const interiorIndices: number[] = [];\n\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const idx = y * width + x;\n          if (!shapeMask[idx]) continue;\n\n          // Check if pixel is on boundary (optimized: early exit)\n          let isBoundary = false;\n\n          // Check 4-connected neighbors first (most common case)\n          if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {\n            isBoundary = true;\n          } else {\n            // Check all 8 neighbors (including diagonals) for comprehensive boundary detection\n            isBoundary =\n              !shapeMask[idx - 1] || // left\n              !shapeMask[idx + 1] || // right\n              !shapeMask[idx - width] || // top\n              !shapeMask[idx + width] || // bottom\n              !shapeMask[idx - width - 1] || // top-left\n              !shapeMask[idx - width + 1] || // top-right\n              !shapeMask[idx + width - 1] || // bottom-left\n              !shapeMask[idx + width + 1]; // bottom-right\n          }\n\n          if (isBoundary) {\n            boundaryMask[idx] = 1;\n            boundaryIndices.push(idx);\n          } else {\n            interiorIndices.push(idx);\n          }\n        }\n      }\n\n      if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n        console.log(`[Mask Building] Time: ${(performance.now() - startMask).toFixed(2)}ms`);\n        console.log(\n          `  Shape pixels: ${shapePixelCount} / ${width * height} (${((shapePixelCount / (width * height)) * 100).toFixed(1)}%)`\n        );\n        console.log(`  Interior pixels: ${interiorIndices.length}`);\n        console.log(`  Boundary pixels: ${boundaryIndices.length}`);\n      }\n\n      // 3) Precompute sparse data structure for solver\n      const sparseData = buildSparseData(\n        shapeMask,\n        boundaryMask,\n        new Uint32Array(interiorIndices),\n        new Uint32Array(boundaryIndices),\n        width,\n        height\n      );\n\n      // 4) Solve Poisson equation with optimized sparse solver\n      const startSolve = performance.now();\n      const u = solvePoissonSparse(sparseData, shapeMask, boundaryMask, width, height);\n\n      if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n        console.log(`[Poisson Solve] Time: ${(performance.now() - startSolve).toFixed(2)}ms`);\n      }\n\n      // 5) Generate output image\n      let maxVal = 0;\n      let finalImageData: ImageData;\n\n      // Only check shape pixels for max value\n      for (let i = 0; i < interiorIndices.length; i++) {\n        const idx = interiorIndices[i]!;\n        if (u[idx]! > maxVal) maxVal = u[idx]!;\n      }\n\n      // Create gradient image at working resolution\n      const tempCanvas = document.createElement('canvas');\n      tempCanvas.width = width;\n      tempCanvas.height = height;\n      const tempCtx = tempCanvas.getContext('2d')!;\n\n      const tempImg = tempCtx.createImageData(width, height);\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const idx = y * width + x;\n          const px = idx * 4;\n\n          if (!shapeMask[idx]) {\n            tempImg.data[px] = 255;\n            tempImg.data[px + 1] = 255;\n            tempImg.data[px + 2] = 255;\n            tempImg.data[px + 3] = 0; // Alpha = 0 for background\n          } else {\n            const poissonRatio = u[idx]! / maxVal;\n            const gray = 255 * (1 - poissonRatio);\n            tempImg.data[px] = gray;\n            tempImg.data[px + 1] = gray;\n            tempImg.data[px + 2] = gray;\n            tempImg.data[px + 3] = 255; // Alpha = 255 for shape\n          }\n        }\n      }\n      tempCtx.putImageData(tempImg, 0, 0);\n\n      // Upscale to original resolution with smooth interpolation\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n      ctx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, originalWidth, originalHeight);\n\n      // Now get the upscaled image data for final output\n      const outImg = ctx.getImageData(0, 0, originalWidth, originalHeight);\n\n      // Re-apply edges from original resolution with anti-aliasing\n      // This ensures edges are pixel-perfect while gradient is smooth\n      const originalCanvas = document.createElement('canvas');\n      originalCanvas.width = originalWidth;\n      originalCanvas.height = originalHeight;\n      const originalCtx = originalCanvas.getContext('2d')!;\n      // originalCtx.fillStyle = \"white\";\n      // originalCtx.fillRect(0, 0, originalWidth, originalHeight);\n      originalCtx.drawImage(img, 0, 0, originalWidth, originalHeight);\n      const originalData = originalCtx.getImageData(0, 0, originalWidth, originalHeight);\n\n      // Process each pixel: Red channel = gradient, Alpha channel = original alpha\n      for (let i = 0; i < outImg.data.length; i += 4) {\n        const a = originalData.data[i + 3]!;\n        // Use only alpha to determine background vs shape\n        const upscaledAlpha = outImg.data[i + 3]!;\n        if (a === 0) {\n          // Background pixel\n          outImg.data[i] = 255;\n          outImg.data[i + 1] = 0;\n        } else {\n          // Red channel carries the gradient\n          // Check if upscale missed this pixel by looking at alpha channel\n          // If upscaled alpha is 0, the low-res version thought this was background\n          outImg.data[i] = upscaledAlpha === 0 ? 0 : outImg.data[i]!; // gradient or 0\n          outImg.data[i + 1] = a; // original alpha\n        }\n\n        // Unused channels fixed\n        outImg.data[i + 2] = 255;\n        outImg.data[i + 3] = 255;\n      }\n\n      ctx.putImageData(outImg, 0, 0);\n      finalImageData = outImg;\n      canvas.toBlob((blob) => {\n        if (!blob) {\n          reject(new Error('Failed to create PNG blob'));\n          return;\n        }\n\n        if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n          const totalTime = performance.now() - totalStartTime;\n          console.log(`[Total Processing Time] ${totalTime.toFixed(2)}ms`);\n          if (scaleFactor < 1) {\n            const estimatedFullResTime = totalTime * Math.pow((originalWidth * originalHeight) / (width * height), 1.5);\n            console.log(`[Estimated time at full resolution] ~${estimatedFullResTime.toFixed(0)}ms`);\n            console.log(\n              `[Time saved] ~${(estimatedFullResTime - totalTime).toFixed(0)}ms (${Math.round(estimatedFullResTime / totalTime)}\u00D7 faster)`\n            );\n          }\n        }\n\n        resolve({\n          imageData: finalImageData,\n          pngBlob: blob,\n        });\n      }, 'image/png');\n    };\n\n    img.onerror = () => reject(new Error('Failed to load image'));\n    img.src = typeof file === 'string' ? file : URL.createObjectURL(file);\n  });\n}\n\nfunction buildSparseData(\n  shapeMask: Uint8Array,\n  boundaryMask: Uint8Array,\n  interiorPixels: Uint32Array,\n  boundaryPixels: Uint32Array,\n  width: number,\n  height: number\n): SparsePixelData {\n  const pixelCount = interiorPixels.length;\n\n  // Build neighbor indices for sparse processing\n  // For each interior pixel, store indices of its 4 neighbors\n  // Use -1 for out-of-bounds or non-shape neighbors\n  const neighborIndices = new Int32Array(pixelCount * 4);\n\n  for (let i = 0; i < pixelCount; i++) {\n    const idx = interiorPixels[i]!;\n    const x = idx % width;\n    const y = Math.floor(idx / width);\n\n    // East neighbor\n    neighborIndices[i * 4 + 0] = x < width - 1 && shapeMask[idx + 1] ? idx + 1 : -1;\n    // West neighbor\n    neighborIndices[i * 4 + 1] = x > 0 && shapeMask[idx - 1] ? idx - 1 : -1;\n    // North neighbor\n    neighborIndices[i * 4 + 2] = y > 0 && shapeMask[idx - width] ? idx - width : -1;\n    // South neighbor\n    neighborIndices[i * 4 + 3] = y < height - 1 && shapeMask[idx + width] ? idx + width : -1;\n  }\n\n  return {\n    interiorPixels,\n    boundaryPixels,\n    pixelCount,\n    neighborIndices,\n  };\n}\n\nfunction solvePoissonSparse(\n  sparseData: SparsePixelData,\n  shapeMask: Uint8Array,\n  boundaryMask: Uint8Array,\n  width: number,\n  height: number\n): Float32Array {\n  // This controls how smooth the falloff gradient will be and extend into the shape\n  const ITERATIONS = POISSON_CONFIG_OPTIMIZED.iterations;\n\n  // Keep C constant - only iterations control gradient spread\n  const C = 0.01;\n\n  const u = new Float32Array(width * height);\n  const { interiorPixels, neighborIndices, pixelCount } = sparseData;\n\n  // Performance tracking\n  const startTime = performance.now();\n\n  // Red-Black SOR for better symmetry with fewer iterations\n  // omega between 1.8-1.95 typically gives best convergence for Poisson\n  const omega = 1.9;\n\n  // Pre-classify pixels as red or black for efficient processing\n  const redPixels: number[] = [];\n  const blackPixels: number[] = [];\n\n  for (let i = 0; i < pixelCount; i++) {\n    const idx = interiorPixels[i]!;\n    const x = idx % width;\n    const y = Math.floor(idx / width);\n\n    if ((x + y) % 2 === 0) {\n      redPixels.push(i);\n    } else {\n      blackPixels.push(i);\n    }\n  }\n\n  for (let iter = 0; iter < ITERATIONS; iter++) {\n    // Red pass: update red pixels\n    for (const i of redPixels) {\n      const idx = interiorPixels[i]!;\n\n      // Get precomputed neighbor indices\n      const eastIdx = neighborIndices[i * 4 + 0]!;\n      const westIdx = neighborIndices[i * 4 + 1]!;\n      const northIdx = neighborIndices[i * 4 + 2]!;\n      const southIdx = neighborIndices[i * 4 + 3]!;\n\n      // Sum neighbors (use 0 for out-of-bounds)\n      let sumN = 0;\n      if (eastIdx >= 0) sumN += u[eastIdx]!;\n      if (westIdx >= 0) sumN += u[westIdx]!;\n      if (northIdx >= 0) sumN += u[northIdx]!;\n      if (southIdx >= 0) sumN += u[southIdx]!;\n\n      // SOR update: blend new value with old value\n      const newValue = (C + sumN) / 4;\n      u[idx] = omega * newValue + (1 - omega) * u[idx]!;\n    }\n\n    // Black pass: update black pixels\n    for (const i of blackPixels) {\n      const idx = interiorPixels[i]!;\n\n      // Get precomputed neighbor indices\n      const eastIdx = neighborIndices[i * 4 + 0]!;\n      const westIdx = neighborIndices[i * 4 + 1]!;\n      const northIdx = neighborIndices[i * 4 + 2]!;\n      const southIdx = neighborIndices[i * 4 + 3]!;\n\n      // Sum neighbors (use 0 for out-of-bounds)\n      let sumN = 0;\n      if (eastIdx >= 0) sumN += u[eastIdx]!;\n      if (westIdx >= 0) sumN += u[westIdx]!;\n      if (northIdx >= 0) sumN += u[northIdx]!;\n      if (southIdx >= 0) sumN += u[southIdx]!;\n\n      // SOR update: blend new value with old value\n      const newValue = (C + sumN) / 4;\n      u[idx] = omega * newValue + (1 - omega) * u[idx]!;\n    }\n  }\n\n  if (POISSON_CONFIG_OPTIMIZED.measurePerformance) {\n    const elapsed = performance.now() - startTime;\n\n    console.log(`[Optimized Poisson Solver (SOR \u03C9=${omega})]`);\n    console.log(`  Working size: ${width}\u00D7${height}`);\n    console.log(`  Iterations: ${ITERATIONS}`);\n    console.log(`  Time: ${elapsed.toFixed(2)}ms`);\n    console.log(`  Interior pixels processed: ${pixelCount}`);\n    console.log(`  Speed: ${((ITERATIONS * pixelCount) / (elapsed * 1000)).toFixed(2)} Mpixels/sec`);\n  }\n\n  return u;\n}\n\nexport interface LiquidMetalUniforms extends ShaderSizingUniforms {\n  u_colorBack: [number, number, number, number];\n  u_colorTint: [number, number, number, number];\n  u_image: HTMLImageElement | string | undefined;\n  u_repetition: number;\n  u_shiftRed: number;\n  u_shiftBlue: number;\n  u_contour: number;\n  u_softness: number;\n  u_distortion: number;\n  u_angle: number;\n  u_shape: (typeof LiquidMetalShapes)[LiquidMetalShape];\n  u_isImage: boolean;\n}\n\nexport interface LiquidMetalParams extends ShaderSizingParams, ShaderMotionParams {\n  colorBack?: string;\n  colorTint?: string;\n  image?: HTMLImageElement | string | undefined;\n  repetition?: number;\n  shiftRed?: number;\n  shiftBlue?: number;\n  contour?: number;\n  softness?: number;\n  distortion?: number;\n  angle?: number;\n  shape?: LiquidMetalShape;\n}\n\nexport const LiquidMetalShapes = {\n  none: 0,\n  circle: 1,\n  daisy: 2,\n  diamond: 3,\n  metaballs: 4,\n} as const;\n\nexport type LiquidMetalShape = keyof typeof LiquidMetalShapes;\n", "import type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, rotation2, proceduralHash21 } from '../shader-utils.js';\n\n/**\n * A halftone-dot image filter featuring customizable grids, color palettes, and dot styles.\n *\n * Fragment shader uniforms:\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_time (float): Animation time\n * - u_image (sampler2D): Source image texture\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n * - u_colorFront (vec4): Foreground color in RGBA\n * - u_colorBack (vec4): Background color in RGBA\n * - u_originalColors (bool): Use sampled image's original colors instead of colorFront\n * - u_type (float): Dot style (0 = classic, 1 = gooey, 2 = holes, 3 = soft)\n * - u_inverted (bool): Inverts the image luminance, doesn't affect the color scheme; not effective at zero contrast\n * - u_grid (float): Grid type (0 = square, 1 = hex)\n * - u_size (float): Grid size relative to the image box (0 to 1)\n * - u_radius (float): Maximum dot size relative to grid cell (0 to 2)\n * - u_contrast (float): Contrast applied to the sampled image (0 to 1)\n * - u_grainMixer (float): Strength of grain distortion applied to shape edges (0 to 1)\n * - u_grainOverlay (float): Post-processing black/white grain overlay (0 to 1)\n * - u_grainSize (float): Scale applied to both grain distortion and grain overlay (0 to 1)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_imageUV (vec2): Image UV coordinates with global sizing (rotation, scale, offset, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n *\n */\n\n// language=GLSL\nexport const halftoneDotsFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_rotation;\n\nuniform float u_time;\n\nuniform vec4 u_colorFront;\nuniform vec4 u_colorBack;\nuniform float u_radius;\nuniform float u_contrast;\n\nuniform sampler2D u_image;\nuniform float u_imageAspectRatio;\n\nuniform float u_size;\nuniform float u_grainMixer;\nuniform float u_grainOverlay;\nuniform float u_grainSize;\nuniform float u_grid;\nuniform bool u_originalColors;\nuniform bool u_inverted;\nuniform float u_type;\n\nin vec2 v_imageUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ rotation2 }\n${ proceduralHash21 }\n\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = hash21(i);\n  float b = hash21(i + vec2(1.0, 0.0));\n  float c = hash21(i + vec2(0.0, 1.0));\n  float d = hash21(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat lst(float edge0, float edge1, float x) {\n  return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nfloat sst(float edge0, float edge1, float x) {\n  return smoothstep(edge0, edge1, x);\n}\n\nfloat getCircle(vec2 uv, float r, float baseR) {\n  r = mix(.25 * baseR, 0., r);\n  float d = length(uv - .5);\n  float aa = fwidth(d);\n  return 1. - smoothstep(r - aa, r + aa, d);\n}\n\nfloat getCell(vec2 uv) {\n  float insideX = step(0.0, uv.x) * (1.0 - step(1.0, uv.x));\n  float insideY = step(0.0, uv.y) * (1.0 - step(1.0, uv.y));\n  return insideX * insideY;\n}\n\nfloat getCircleWithHole(vec2 uv, float r, float baseR) {\n  float cell = getCell(uv);\n\n  r = mix(.75 * baseR, 0., r);\n  float rMod = mod(r, .5);\n\n  float d = length(uv - .5);\n  float aa = fwidth(d);\n  float circle = 1. - smoothstep(rMod - aa, rMod + aa, d);\n  if (r < .5) {\n    return circle;\n  } else {\n    return cell - circle;\n  }\n}\n\nfloat getGooeyBall(vec2 uv, float r, float baseR) {\n  float d = length(uv - .5);\n  float sizeRadius = .3;\n  if (u_grid == 1.) {\n    sizeRadius = .42;\n  }\n  sizeRadius = mix(sizeRadius * baseR, 0., r);\n  d = 1. - sst(0., sizeRadius, d);\n\n  d = pow(d, 2. + baseR);\n  return d;\n}\n\nfloat getSoftBall(vec2 uv, float r, float baseR) {\n  float d = length(uv - .5);\n  float sizeRadius = clamp(baseR, 0., 1.);\n  sizeRadius = mix(.5 * sizeRadius, 0., r);\n  d = 1. - lst(0., sizeRadius, d);\n  float powRadius = 1. - lst(0., 2., baseR);\n  d = pow(d, 4. + 3. * powRadius);\n  return d;\n}\n\nfloat getUvFrame(vec2 uv, vec2 pad) {\n  float aa = 0.0001;\n\n  float left   = smoothstep(-pad.x, -pad.x + aa, uv.x);\n  float right  = smoothstep(1.0 + pad.x, 1.0 + pad.x - aa, uv.x);\n  float bottom = smoothstep(-pad.y, -pad.y + aa, uv.y);\n  float top    = smoothstep(1.0 + pad.y, 1.0 + pad.y - aa, uv.y);\n\n  return left * right * bottom * top;\n}\n\nfloat sigmoid(float x, float k) {\n  return 1.0 / (1.0 + exp(-k * (x - 0.5)));\n}\n\nfloat getLumAtPx(vec2 uv, float contrast) {\n  vec4 tex = texture(u_image, uv);\n  vec3 color = vec3(\n  sigmoid(tex.r, contrast),\n  sigmoid(tex.g, contrast),\n  sigmoid(tex.b, contrast)\n  );\n  float lum = dot(vec3(0.2126, 0.7152, 0.0722), color);\n  lum = mix(1., lum, tex.a);\n  lum = u_inverted ? (1. - lum) : lum;\n  return lum;\n}\n\nfloat getLumBall(vec2 p, vec2 pad, vec2 inCellOffset, float contrast, float baseR, float stepSize, out vec4 ballColor) {\n  p += inCellOffset;\n  vec2 uv_i = floor(p);\n  vec2 uv_f = fract(p);\n  vec2 samplingUV = (uv_i + .5 - inCellOffset) * pad + vec2(.5);\n  float outOfFrame = getUvFrame(samplingUV, pad * stepSize);\n\n  float lum = getLumAtPx(samplingUV, contrast);\n  ballColor = texture(u_image, samplingUV);\n  ballColor.rgb *= ballColor.a;\n  ballColor *= outOfFrame;\n\n  float ball = 0.;\n  if (u_type == 0.) {\n    // classic\n    ball = getCircle(uv_f, lum, baseR);\n  } else if (u_type == 1.) {\n    // gooey\n    ball = getGooeyBall(uv_f, lum, baseR);\n  } else if (u_type == 2.) {\n    // holes\n    ball = getCircleWithHole(uv_f, lum, baseR);\n  } else if (u_type == 3.) {\n    // soft\n    ball = getSoftBall(uv_f, lum, baseR);\n  }\n\n  return ball * outOfFrame;\n}\n\n\nvoid main() {\n\n  float stepMultiplier = 1.;\n  if (u_type == 0.) {\n    // classic\n    stepMultiplier = 2.;\n  } else if (u_type == 1. || u_type == 3.) {\n    // gooey & soft\n    stepMultiplier = 6.;\n  }\n\n  float cellsPerSide = mix(300., 7., pow(u_size, .7));\n  cellsPerSide /= stepMultiplier;\n  float cellSizeY = 1. / cellsPerSide;\n  vec2 pad = cellSizeY * vec2(1. / u_imageAspectRatio, 1.);\n  if (u_type == 1. && u_grid == 1.) {\n    // gooey diagonal grid works differently\n    pad *= .7;\n  }\n\n  vec2 uv = v_imageUV;\n  uv -= vec2(.5);\n  uv /= pad;\n\n  float contrast = mix(0., 15., pow(u_contrast, 1.5));\n  float baseRadius = u_radius;\n  if (u_originalColors == true) {\n    contrast = mix(.1, 4., pow(u_contrast, 2.));\n    baseRadius = 2. * pow(.5 * u_radius, .3);\n  }\n\n  float totalShape = 0.;\n  vec3 totalColor = vec3(0.);\n  float totalOpacity = 0.;\n\n  vec4 ballColor;\n  float shape;\n  float stepSize = 1. / stepMultiplier;\n  for (float x = -0.5; x < 0.5; x += stepSize) {\n    for (float y = -0.5; y < 0.5; y += stepSize) {\n      vec2 offset = vec2(x, y);\n\n      if (u_grid == 1.) {\n        float rowIndex = floor((y + .5) / stepSize);\n        float colIndex = floor((x + .5) / stepSize);\n        if (stepSize == 1.) {\n          rowIndex = floor(uv.y + y + 1.);\n          if (u_type == 1.) {\n            colIndex = floor(uv.x + x + 1.);\n          }\n        }\n        if (u_type == 1.) {\n          if (mod(rowIndex + colIndex, 2.) == 1.) {\n            continue;\n          }\n        } else {\n          if (mod(rowIndex, 2.) == 1.) {\n            offset.x += .5 * stepSize;\n          }\n        }\n      }\n\n      shape = getLumBall(uv, pad, offset, contrast, baseRadius, stepSize, ballColor);\n      totalColor   += ballColor.rgb * shape;\n      totalShape   += shape;\n      totalOpacity += shape;\n    }\n  }\n\n  const float eps = 1e-4;\n\n  totalColor /= max(totalShape, eps);\n  totalOpacity /= max(totalShape, eps);\n\n  float finalShape = 0.;\n  if (u_type == 0.) {\n    finalShape = min(1., totalShape);\n  } else if (u_type == 1.) {\n    float aa = fwidth(totalShape);\n    float th = .5;\n    finalShape = smoothstep(th - aa, th + aa, totalShape);\n  } else if (u_type == 2.) {\n    finalShape = min(1., totalShape);\n  } else if (u_type == 3.) {\n    finalShape = totalShape;\n  }\n\n  vec2 grainSize = mix(2000., 200., u_grainSize) * vec2(1., 1. / u_imageAspectRatio);\n  vec2 grainUV = v_imageUV - .5;\n  grainUV *= grainSize;\n  grainUV += .5;\n  float grain = valueNoise(grainUV);\n  grain = smoothstep(.55, .7 + .2 * u_grainMixer, grain);\n  grain *= u_grainMixer;\n  finalShape = mix(finalShape, 0., grain);\n\n  vec3 color = vec3(0.);\n  float opacity = 0.;\n\n  if (u_originalColors == true) {\n    color = totalColor * finalShape;\n    opacity = totalOpacity * finalShape;\n\n    vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n    color = color + bgColor * (1. - opacity);\n    opacity = opacity + u_colorBack.a * (1. - opacity);\n  } else {\n    vec3 fgColor = u_colorFront.rgb * u_colorFront.a;\n    float fgOpacity = u_colorFront.a;\n    vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n    float bgOpacity = u_colorBack.a;\n\n    color = fgColor * finalShape;\n    opacity = fgOpacity * finalShape;\n    color += bgColor * (1. - opacity);\n    opacity += bgOpacity * (1. - opacity);\n  }\n\n  float grainOverlay = valueNoise(rotate(grainUV, 1.) + vec2(3.));\n  grainOverlay = mix(grainOverlay, valueNoise(rotate(grainUV, 2.) + vec2(-1.)), .5);\n  grainOverlay = pow(grainOverlay, 1.3);\n\n  float grainOverlayV = grainOverlay * 2. - 1.;\n  vec3 grainOverlayColor = vec3(step(0., grainOverlayV));\n  float grainOverlayStrength = u_grainOverlay * abs(grainOverlayV);\n  grainOverlayStrength = pow(grainOverlayStrength, .8);\n  color = mix(color, grainOverlayColor, .5 * grainOverlayStrength);\n\n  opacity += .5 * grainOverlayStrength;\n  opacity = clamp(opacity, 0., 1.);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface HalftoneDotsUniforms extends ShaderSizingUniforms {\n  u_image: HTMLImageElement | string | undefined;\n  u_colorFront: [number, number, number, number];\n  u_colorBack: [number, number, number, number];\n  u_size: number;\n  u_grid: (typeof HalftoneDotsGrids)[HalftoneDotsGrid];\n  u_radius: number;\n  u_contrast: number;\n  u_originalColors: boolean;\n  u_inverted: boolean;\n  u_grainMixer: number;\n  u_grainOverlay: number;\n  u_grainSize: number;\n  u_type: (typeof HalftoneDotsTypes)[HalftoneDotsType];\n}\n\nexport interface HalftoneDotsParams extends ShaderSizingParams, ShaderMotionParams {\n  image?: HTMLImageElement | string;\n  colorFront?: string;\n  colorBack?: string;\n  size?: number;\n  grid?: HalftoneDotsGrid;\n  radius?: number;\n  contrast?: number;\n  originalColors?: boolean;\n  inverted?: boolean;\n  grainMixer?: number;\n  grainOverlay?: number;\n  grainSize?: number;\n  type?: HalftoneDotsType;\n}\n\nexport const HalftoneDotsTypes = {\n  classic: 0,\n  gooey: 1,\n  holes: 2,\n  soft: 3,\n} as const;\n\nexport type HalftoneDotsType = keyof typeof HalftoneDotsTypes;\n\nexport const HalftoneDotsGrids = {\n  square: 0,\n  hex: 1,\n} as const;\n\nexport type HalftoneDotsGrid = keyof typeof HalftoneDotsGrids;\n", "import type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI } from '../shader-utils.js';\n\n/**\n * CMYK halftone printing effect applied to images with customizable dot patterns\n * and ink colors for each channel (Cyan, Magenta, Yellow, Black).\n *\n * Fragment shader uniforms:\n * - u_image (sampler2D): Source image texture\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n * - u_colorBack (vec4): Background (paper) color in RGBA\n * - u_colorC (vec4): Cyan ink color in RGBA\n * - u_colorM (vec4): Magenta ink color in RGBA\n * - u_colorY (vec4): Yellow ink color in RGBA\n * - u_colorK (vec4): Black ink color in RGBA\n * - u_size (float): Halftone cell size (0 to 1)\n * - u_minDot (float): Minimum dot thickness (0 to 1)\n * - u_contrast (float): Image contrast adjustment (0 to 2)\n * - u_softness (float): Edge softness of dots (0 to 1)\n * - u_grainSize (float): Size of grain overlay texture (0 to 1)\n * - u_grainMixer (float): Strength of grain affecting dot size (0 to 1)\n * - u_grainOverlay (float): Strength of grain overlay on final output (0 to 1)\n * - u_gridNoise (float): Strength of smooth noise applied to both dot positions and color sampling (0 to 1)\n * - u_floodC (float): Flat cyan dot size adjustment applied uniformly (-1 to 1)\n * - u_floodM (float): Flat magenta dot size adjustment applied uniformly (-1 to 1)\n * - u_floodY (float): Flat yellow dot size adjustment applied uniformly (-1 to 1)\n * - u_floodK (float): Flat black dot size adjustment applied uniformly (-1 to 1)\n * - u_gainC (float): Proportional cyan dot size gain (enhances existing dots, -1 to 1)\n * - u_gainM (float): Proportional magenta dot size gain (enhances existing dots, -1 to 1)\n * - u_gainY (float): Proportional yellow dot size gain (enhances existing dots, -1 to 1)\n * - u_gainK (float): Proportional black dot size gain (enhances existing dots, -1 to 1)\n * - u_type (float): Dot shape style (0 = dots, 1 = ink, 2 = sharp)\n * - u_noiseTexture (sampler2D): Pre-computed randomizer source texture\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_imageUV (vec2): UV coordinates for sampling the source image, with fit, scale, rotation, and offset applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n * - u_imageAspectRatio (float): Aspect ratio of the source image\n *\n */\n\n// language=GLSL\nexport const halftoneCmykFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_image;\nuniform float u_imageAspectRatio;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colorC;\nuniform vec4 u_colorM;\nuniform vec4 u_colorY;\nuniform vec4 u_colorK;\nuniform float u_size;\nuniform float u_minDot;\nuniform float u_contrast;\nuniform float u_grainSize;\nuniform float u_grainMixer;\nuniform float u_grainOverlay;\nuniform float u_gridNoise;\nuniform float u_softness;\nuniform float u_floodC;\nuniform float u_floodM;\nuniform float u_floodY;\nuniform float u_floodK;\nuniform float u_gainC;\nuniform float u_gainM;\nuniform float u_gainY;\nuniform float u_gainK;\nuniform float u_type;\nuniform sampler2D u_noiseTexture;\n\nin vec2 v_imageUV;\nout vec4 fragColor;\n\nconst float shiftC = -.5;\nconst float shiftM = -.25;\nconst float shiftY = .2;\nconst float shiftK = 0.;\n\n// Precomputed sin/cos for rotation angles (15\u00B0, 75\u00B0, 0\u00B0, 45\u00B0)\nconst float cosC = 0.9659258;  const float sinC = 0.2588190;   // 15\u00B0\nconst float cosM = 0.2588190;  const float sinM = 0.9659258;   // 75\u00B0\nconst float cosY = 1.0;        const float sinY = 0.0;         // 0\u00B0\nconst float cosK = 0.7071068;  const float sinK = 0.7071068;   // 45\u00B0\n\n${ declarePI }\n\nvec2 randomRG(vec2 p) {\n  vec2 uv = floor(p) / 100. + .5;\n  return texture(u_noiseTexture, fract(uv)).rg;\n}\nvec3 hash23(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * vec3(0.3183099, 0.3678794, 0.3141592)) + 0.1;\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract(vec3(p3.x * p3.y, p3.y * p3.z, p3.z * p3.x));\n}\n\nfloat sst(float edge0, float edge1, float x) {\n  return smoothstep(edge0, edge1, x);\n}\n\nvec3 valueNoise3(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  vec3 a = hash23(i);\n  vec3 b = hash23(i + vec2(1.0, 0.0));\n  vec3 c = hash23(i + vec2(0.0, 1.0));\n  vec3 d = hash23(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  vec3 x1 = mix(a, b, u.x);\n  vec3 x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat getUvFrame(vec2 uv, vec2 pad) {\n  float left   = smoothstep(-pad.x, 0., uv.x);\n  float right  = smoothstep(1. + pad.x, 1., uv.x);\n  float bottom = smoothstep(-pad.y, 0., uv.y);\n  float top    = smoothstep(1. + pad.y, 1., uv.y);\n\n  return left * right * bottom * top;\n}\n\nvec4 RGBAtoCMYK(vec4 rgba) {\n  float k = 1. - max(max(rgba.r, rgba.g), rgba.b);\n  float denom = 1. - k;\n  vec3 cmy = vec3(0.);\n  if (denom > 1e-5) {\n    cmy = (1. - rgba.rgb - vec3(k)) / denom;\n  }\n  return vec4(cmy, k) * rgba.a;\n}\n\nvec3 applyContrast(vec3 rgb) {\n  return clamp((rgb - 0.5) * u_contrast + 0.5, 0.0, 1.0);\n}\n\n// Single-component CMYK extractors with contrast built-in, alpha-aware\nfloat getCyan(vec4 rgba) {\n  vec3 c = clamp((rgba.rgb - 0.5) * u_contrast + 0.5, 0.0, 1.0);\n  float maxRGB = max(max(c.r, c.g), c.b);\n  return (maxRGB > 1e-5 ? (maxRGB - c.r) / maxRGB : 0.) * rgba.a;\n}\nfloat getMagenta(vec4 rgba) {\n  vec3 c = clamp((rgba.rgb - 0.5) * u_contrast + 0.5, 0.0, 1.0);\n  float maxRGB = max(max(c.r, c.g), c.b);\n  return (maxRGB > 1e-5 ? (maxRGB - c.g) / maxRGB : 0.) * rgba.a;\n}\nfloat getYellow(vec4 rgba) {\n  vec3 c = clamp((rgba.rgb - 0.5) * u_contrast + 0.5, 0.0, 1.0);\n  float maxRGB = max(max(c.r, c.g), c.b);\n  return (maxRGB > 1e-5 ? (maxRGB - c.b) / maxRGB : 0.) * rgba.a;\n}\nfloat getBlack(vec4 rgba) {\n  vec3 c = clamp((rgba.rgb - 0.5) * u_contrast + 0.5, 0.0, 1.0);\n  return (1. - max(max(c.r, c.g), c.b)) * rgba.a;\n}\n\nvec2 cellCenterPos(vec2 uv, vec2 cellOffset, float channelIdx) {\n  vec2 cellCenter = floor(uv) + .5 + cellOffset;\n  return cellCenter + (randomRG(cellCenter + channelIdx * 50.) - .5) * u_gridNoise;\n}\n\nvec2 gridToImageUV(vec2 cellCenter, float cosA, float sinA, float shift, vec2 pad) {\n  vec2 uvGrid = mat2(cosA, -sinA, sinA, cosA) * (cellCenter - shift);\n  return uvGrid * pad + 0.5;\n}\n\nvoid colorMask(vec2 pos, vec2 cellCenter, float rad, float transparency, float grain, float channelAddon, float channelgain, float generalComp, bool isJoined, inout float outMask) {\n  float dist = length(pos - cellCenter);\n\n  float radius = rad;\n  radius *= (1. + generalComp);\n  radius += (.15 + channelgain * radius);\n  radius = max(0., radius);\n  radius = mix(0., radius, transparency);\n  radius += channelAddon;\n  radius *= (1. - grain);\n\n  float mask = 1. - sst(0., radius, dist);\n  if (isJoined) {\n    // ink or sharp (joined)\n    mask = pow(mask, 1.2);\n  } else {\n    // dots (separate)\n    mask = sst(.5 - .5 * u_softness, .51 + .49 * u_softness, mask);\n  }\n\n  mask *= mix(1., mix(.5, 1., 1.5 * radius), u_softness);\n  outMask += mask;\n}\n\nvec3 applyInk(vec3 paper, vec3 inkColor, float cov) {\n  vec3 inkEffect = mix(vec3(1.0), inkColor, clamp(cov, 0.0, 1.0));\n  return paper * inkEffect;\n}\n\nvoid main() {\n  vec2 uv = v_imageUV;\n\n  float cellsPerSide = mix(400.0, 7.0, pow(u_size, 0.7));\n  float cellSizeY = 1.0 / cellsPerSide;\n  vec2 pad = cellSizeY * vec2(1.0 / u_imageAspectRatio, 1.0);\n  vec2 uvGrid = (uv - .5) / pad;\n  float insideImageBox = getUvFrame(uv, pad);\n\n  float generalComp = .1 * u_softness + .1 * u_gridNoise + .1 * (1. - step(0.5, u_type)) * (1.5 - u_softness);\n\n  vec2 uvC = mat2(cosC, sinC, -sinC, cosC) * uvGrid + shiftC;\n  vec2 uvM = mat2(cosM, sinM, -sinM, cosM) * uvGrid + shiftM;\n  vec2 uvY = mat2(cosY, sinY, -sinY, cosY) * uvGrid + shiftY;\n  vec2 uvK = mat2(cosK, sinK, -sinK, cosK) * uvGrid + shiftK;\n\n  vec2 grainSize = mix(2000., 200., u_grainSize) * vec2(1., 1. / u_imageAspectRatio);\n  vec2 grainUV = (v_imageUV - .5) * grainSize + .5;\n  vec3 noiseValues = valueNoise3(grainUV);\n  float grain = sst(.55, 1., noiseValues.r);\n  grain *= u_grainMixer;\n\n  vec4 outMask = vec4(0.);\n  bool isJoined = u_type > 0.5;\n\n  if (u_type < 1.5) {\n    // dots or ink: per-cell color sampling\n    for (int dy = -1; dy <= 1; dy++) {\n      for (int dx = -1; dx <= 1; dx++) {\n        vec2 cellOffset = vec2(float(dx), float(dy));\n\n        vec2 cellCenterC = cellCenterPos(uvC, cellOffset, 0.);\n        vec4 texC = texture(u_image, gridToImageUV(cellCenterC, cosC, sinC, shiftC, pad));\n        colorMask(uvC, cellCenterC, getCyan(texC), insideImageBox * texC.a, grain, u_floodC, u_gainC, generalComp, isJoined, outMask[0]);\n\n        vec2 cellCenterM = cellCenterPos(uvM, cellOffset, 1.);\n        vec4 texM = texture(u_image, gridToImageUV(cellCenterM, cosM, sinM, shiftM, pad));\n        colorMask(uvM, cellCenterM, getMagenta(texM), insideImageBox * texM.a, grain, u_floodM, u_gainM, generalComp, isJoined, outMask[1]);\n\n        vec2 cellCenterY = cellCenterPos(uvY, cellOffset, 2.);\n        vec4 texY = texture(u_image, gridToImageUV(cellCenterY, cosY, sinY, shiftY, pad));\n        colorMask(uvY, cellCenterY, getYellow(texY), insideImageBox * texY.a, grain, u_floodY, u_gainY, generalComp, isJoined, outMask[2]);\n\n        vec2 cellCenterK = cellCenterPos(uvK, cellOffset, 3.);\n        vec4 texK = texture(u_image, gridToImageUV(cellCenterK, cosK, sinK, shiftK, pad));\n        colorMask(uvK, cellCenterK, getBlack(texK), insideImageBox * texK.a, grain, u_floodK, u_gainK, generalComp, isJoined, outMask[3]);\n      }\n    }\n  } else {\n    // sharp: direct px color sampling\n    vec4 tex = texture(u_image, uv);\n    tex.rgb = applyContrast(tex.rgb);\n    insideImageBox *= tex.a;\n    vec4 cmykOriginal = RGBAtoCMYK(tex);\n    for (int dy = -1; dy <= 1; dy++) {\n      for (int dx = -1; dx <= 1; dx++) {\n        vec2 cellOffset = vec2(float(dx), float(dy));\n\n        colorMask(uvC, cellCenterPos(uvC, cellOffset, 0.), cmykOriginal.x, insideImageBox, grain, u_floodC, u_gainC, generalComp, isJoined, outMask[0]);\n        colorMask(uvM, cellCenterPos(uvM, cellOffset, 1.), cmykOriginal.y, insideImageBox, grain, u_floodM, u_gainM, generalComp, isJoined, outMask[1]);\n        colorMask(uvY, cellCenterPos(uvY, cellOffset, 2.), cmykOriginal.z, insideImageBox, grain, u_floodY, u_gainY, generalComp, isJoined, outMask[2]);\n        colorMask(uvK, cellCenterPos(uvK, cellOffset, 3.), cmykOriginal.w, insideImageBox, grain, u_floodK, u_gainK, generalComp, isJoined, outMask[3]);\n      }\n    }\n  }\n\n  float shape;\n\n  float C = outMask[0];\n  float M = outMask[1];\n  float Y = outMask[2];\n  float K = outMask[3];\n\n  if (isJoined) {\n    // ink or sharp: apply threshold for joined dots\n    float th = .5;\n    float sLeft = th * u_softness;\n    float sRight = (1. - th) * u_softness + .01;\n    C = smoothstep(th - sLeft - fwidth(C), th + sRight, C);\n    M = smoothstep(th - sLeft - fwidth(M), th + sRight, M);\n    Y = smoothstep(th - sLeft - fwidth(Y), th + sRight, Y);\n    K = smoothstep(th - sLeft - fwidth(K), th + sRight, K);\n  }\n\n  C *= u_colorC.a;\n  M *= u_colorM.a;\n  Y *= u_colorY.a;\n  K *= u_colorK.a;\n\n  vec3 ink = vec3(1.);\n  ink = applyInk(ink, u_colorK.rgb, K);\n  ink = applyInk(ink, u_colorC.rgb, C);\n  ink = applyInk(ink, u_colorM.rgb, M);\n  ink = applyInk(ink, u_colorY.rgb, Y);\n\n  shape = clamp(max(max(C, M), max(Y, K)), 0., 1.);\n\n  vec3 color = u_colorBack.rgb * u_colorBack.a;\n\n  float opacity = u_colorBack.a;\n  color = mix(color, ink, shape);\n  opacity += shape;\n  opacity = clamp(opacity, 0., 1.);\n\n  float grainOverlay = mix(noiseValues.g, noiseValues.b, .5);\n  grainOverlay = pow(grainOverlay, 1.3);\n\n  float grainOverlayV = grainOverlay * 2. - 1.;\n  vec3 grainOverlayColor = vec3(step(0., grainOverlayV));\n  float grainOverlayStrength = u_grainOverlay * abs(grainOverlayV);\n  grainOverlayStrength = pow(grainOverlayStrength, .8);\n  color = mix(color, grainOverlayColor, .5 * grainOverlayStrength);\n\n  opacity += .5 * grainOverlayStrength;\n  opacity = clamp(opacity, 0., 1.);\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface HalftoneCmykUniforms extends ShaderSizingUniforms {\n  u_image: HTMLImageElement | string | undefined;\n  u_noiseTexture?: HTMLImageElement;\n  u_colorBack: [number, number, number, number];\n  u_colorC: [number, number, number, number];\n  u_colorM: [number, number, number, number];\n  u_colorY: [number, number, number, number];\n  u_colorK: [number, number, number, number];\n  u_size: number;\n  u_contrast: number;\n  u_softness: number;\n  u_grainSize: number;\n  u_grainMixer: number;\n  u_grainOverlay: number;\n  u_gridNoise: number;\n  u_floodC: number;\n  u_floodM: number;\n  u_floodY: number;\n  u_floodK: number;\n  u_gainC: number;\n  u_gainM: number;\n  u_gainY: number;\n  u_gainK: number;\n  u_type: (typeof HalftoneCmykTypes)[HalftoneCmykType];\n}\n\nexport interface HalftoneCmykParams extends ShaderSizingParams, ShaderMotionParams {\n  image?: HTMLImageElement | string;\n  colorBack?: string;\n  colorC?: string;\n  colorM?: string;\n  colorY?: string;\n  colorK?: string;\n  size?: number;\n  contrast?: number;\n  softness?: number;\n  grainSize?: number;\n  grainMixer?: number;\n  grainOverlay?: number;\n  gridNoise?: number;\n  floodC?: number;\n  floodM?: number;\n  floodY?: number;\n  floodK?: number;\n  gainC?: number;\n  gainM?: number;\n  gainY?: number;\n  gainK?: number;\n  type?: HalftoneCmykType;\n}\n\nexport const HalftoneCmykTypes = {\n  dots: 0,\n  ink: 1,\n  sharp: 2,\n} as const;\n\nexport type HalftoneCmykType = keyof typeof HalftoneCmykTypes;\n\n", "/**  Convert color string from HSL, RGB, or hex to 0-to-1-range-RGBA array */\nexport function getShaderColorFromString(\n  colorString: string | [number, number, number] | [number, number, number, number] | undefined\n): [number, number, number, number] {\n  // If the color string is already an array of 3 or 4 numbers, return it (with alpha=1 if needed)\n  if (Array.isArray(colorString)) {\n    if (colorString.length === 4) return colorString as [number, number, number, number];\n    if (colorString.length === 3) return [...colorString, 1];\n    return fallbackColor;\n  }\n\n  // If the color string is not a string, return the fallback\n  if (typeof colorString !== 'string') {\n    return fallbackColor;\n  }\n\n  let r: number,\n    g: number,\n    b: number,\n    a = 1;\n  if (colorString.startsWith('#')) {\n    [r, g, b, a] = hexToRgba(colorString);\n  } else if (colorString.startsWith('rgb')) {\n    [r, g, b, a] = parseRgba(colorString);\n  } else if (colorString.startsWith('hsl')) {\n    [r, g, b, a] = hslaToRgba(parseHsla(colorString));\n  } else {\n    console.error('Unsupported color format', colorString);\n    return fallbackColor;\n  }\n\n  return [clamp(r, 0, 1), clamp(g, 0, 1), clamp(b, 0, 1), clamp(a, 0, 1)];\n}\n\n/** Convert hex to RGBA (0 to 1 range) */\nfunction hexToRgba(hex: string): [number, number, number, number] {\n  // Remove # if present\n  hex = hex.replace(/^#/, '');\n\n  // Expand three-letter hex to six-letter\n  if (hex.length === 3) {\n    hex = hex\n      .split('')\n      .map((char) => char + char)\n      .join('');\n  }\n  // Expand six-letter hex to eight-letter (add full opacity if no alpha)\n  if (hex.length === 6) {\n    hex = hex + 'ff';\n  }\n\n  // Parse the components\n  const r = parseInt(hex.slice(0, 2), 16) / 255;\n  const g = parseInt(hex.slice(2, 4), 16) / 255;\n  const b = parseInt(hex.slice(4, 6), 16) / 255;\n  const a = parseInt(hex.slice(6, 8), 16) / 255;\n\n  return [r, g, b, a];\n}\n\n/** Parse RGBA string to RGBA (0 to 1 range) */\nfunction parseRgba(rgba: string): [number, number, number, number] {\n  // Match both rgb and rgba patterns\n  const match = rgba.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n\n  return [\n    parseInt(match[1] ?? '0') / 255,\n    parseInt(match[2] ?? '0') / 255,\n    parseInt(match[3] ?? '0') / 255,\n    match[4] === undefined ? 1 : parseFloat(match[4]),\n  ];\n}\n\n/** Parse HSLA string */\nfunction parseHsla(hsla: string): [number, number, number, number] {\n  const match = hsla.match(/^hsla?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n\n  return [\n    parseInt(match[1] ?? '0'),\n    parseInt(match[2] ?? '0'),\n    parseInt(match[3] ?? '0'),\n    match[4] === undefined ? 1 : parseFloat(match[4]),\n  ];\n}\n\n/** Convert HSLA to RGBA (0 to 1 range) */\nfunction hslaToRgba(hsla: [number, number, number, number]): [number, number, number, number] {\n  const [h, s, l, a] = hsla;\n  const hDecimal = h / 360;\n  const sDecimal = s / 100;\n  const lDecimal = l / 100;\n  let r, g, b;\n\n  if (s === 0) {\n    r = g = b = lDecimal; // achromatic\n  } else {\n    const hue2rgb = (p: number, q: number, t: number) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    };\n\n    const q = lDecimal < 0.5 ? lDecimal * (1 + sDecimal) : lDecimal + sDecimal - lDecimal * sDecimal;\n    const p = 2 * lDecimal - q;\n    r = hue2rgb(p, q, hDecimal + 1 / 3);\n    g = hue2rgb(p, q, hDecimal);\n    b = hue2rgb(p, q, hDecimal - 1 / 3);\n  }\n\n  return [r, g, b, a];\n}\n\nexport const clamp = (n: number, min: number, max: number): number => Math.min(Math.max(n, min), max);\n\nconst fallbackColor = [0, 0, 0, 1] as [0, 0, 0, 1];\n", "export function getShaderNoiseTexture(): HTMLImageElement | undefined {\n  if (typeof window === 'undefined') {\n    return undefined;\n  }\n\n  const img = new Image();\n  img.src = noiseSrc;\n  return img;\n}\n\nconst noiseSrc =\n  'data:image/png;base64,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';\n", "export function getEmptyPixel(): HTMLImageElement | undefined {\n  if (typeof window === 'undefined') {\n    console.warn('Paper Shaders: can\u2019t create an image on the server');\n    return undefined;\n  }\n\n  const img = new Image();\n  img.src = emptyPixel;\n  return img;\n}\n\nconst emptyPixel = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n", "import * as React from 'react';\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\n */\nexport function useMergeRefs<Instance>(refs: Array<React.Ref<Instance> | undefined>): null | React.Ref<Instance> {\n  const cleanupRef = React.useRef<void | (() => void)>(undefined);\n\n  const refEffect = React.useCallback((instance: Instance | null) => {\n    const cleanups = refs.map((ref) => {\n      if (ref == null) {\n        return;\n      }\n\n      if (typeof ref === 'function') {\n        const refCallback = ref;\n        const refCleanup: void | (() => void) = refCallback(instance);\n        return typeof refCleanup === 'function'\n          ? refCleanup\n          : () => {\n              refCallback(null);\n            };\n      }\n\n      (ref as React.RefObject<Instance | null>).current = instance;\n      return () => {\n        (ref as React.RefObject<Instance | null>).current = null;\n      };\n    });\n\n    return () => {\n      cleanups.forEach((refCleanup) => refCleanup?.());\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n\n  return React.useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null;\n    }\n\n    return (value) => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        (cleanupRef as React.RefObject<void | (() => void)>).current = undefined;\n      }\n\n      if (value != null) {\n        (cleanupRef as React.RefObject<void | (() => void)>).current = refEffect(value);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n", "/**\n * Resize the image to at least 1024px on the shorter side.\n * Makes sure that vector images are converted to bitmaps at an acceptable resolution.\n */\nexport function setMinImageSize(img: HTMLImageElement): void {\n  if (img.naturalWidth < 1024 && img.naturalHeight < 1024) {\n    if (img.naturalWidth < 1 || img.naturalHeight < 1) {\n      // Skip weird sizes\n      return;\n    }\n\n    const aspect = img.naturalWidth / img.naturalHeight;\n    img.width = Math.round(aspect > 1 ? 1024 * aspect : 1024);\n    img.height = Math.round(aspect > 1 ? 1024 : 1024 / aspect);\n  }\n}\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  meshGradientFragmentShader,\n  ShaderFitOptions,\n  type MeshGradientParams,\n  type MeshGradientUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface MeshGradientProps extends ShaderComponentProps, MeshGradientParams {}\n\ntype MeshGradientPreset = ShaderPreset<MeshGradientParams>;\n\nexport const defaultPreset: MeshGradientPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: ['#e0eaff', '#241d9a', '#f75092', '#9f50d3'],\n    distortion: 0.8,\n    swirl: 0.1,\n    grainMixer: 0,\n    grainOverlay: 0,\n  },\n};\n\nexport const purplePreset: MeshGradientPreset = {\n  name: 'Purple',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0.6,\n    frame: 0,\n    colors: ['#aaa7d7', '#3c2b8e'],\n    distortion: 1,\n    swirl: 1,\n    grainMixer: 0,\n    grainOverlay: 0,\n  },\n};\n\nexport const beachPreset: MeshGradientPreset = {\n  name: 'Beach',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0.1,\n    frame: 0,\n    colors: ['#bcecf6', '#00aaff', '#00f7ff', '#ffd447'],\n    distortion: 0.8,\n    swirl: 0.35,\n    grainMixer: 0,\n    grainOverlay: 0,\n  },\n};\n\nexport const inkPreset: MeshGradientPreset = {\n  name: 'Ink',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: ['#ffffff', '#000000'],\n    distortion: 1,\n    swirl: 0.2,\n    rotation: 90,\n    grainMixer: 0,\n    grainOverlay: 0,\n  },\n};\n\nexport const meshGradientPresets: MeshGradientPreset[] = [defaultPreset, inkPreset, purplePreset, beachPreset];\n\nexport const MeshGradient: React.FC<MeshGradientProps> = memo(function MeshGradientImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  distortion = defaultPreset.params.distortion,\n  swirl = defaultPreset.params.swirl,\n  grainMixer = defaultPreset.params.grainMixer,\n  grainOverlay = defaultPreset.params.grainOverlay,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: MeshGradientProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_distortion: distortion,\n    u_swirl: swirl,\n    u_grainMixer: grainMixer,\n    u_grainOverlay: grainOverlay,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies MeshGradientUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={meshGradientFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "interface PropsWithColors {\n  colors?: string[];\n  [key: string]: unknown;\n}\n\nexport function colorPropsAreEqual(prevProps: PropsWithColors, nextProps: PropsWithColors): boolean {\n  for (const key in prevProps) {\n    if (key === 'colors') {\n      const prevIsArray = Array.isArray(prevProps.colors);\n      const nextIsArray = Array.isArray(nextProps.colors);\n\n      if (!prevIsArray || !nextIsArray) {\n        if (Object.is(prevProps.colors, nextProps.colors) === false) {\n          return false;\n        }\n\n        continue;\n      }\n\n      if (prevProps.colors?.length !== nextProps.colors?.length) {\n        return false;\n      }\n\n      if (!prevProps.colors?.every((color, index) => color === nextProps.colors?.[index])) {\n        return false;\n      }\n\n      continue;\n    }\n\n    if (Object.is(prevProps[key], nextProps[key]) === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  getShaderNoiseTexture,\n  smokeRingFragmentShader,\n  ShaderFitOptions,\n  type ShaderPreset,\n  type SmokeRingParams,\n  type SmokeRingUniforms,\n} from '@paper-design/shaders';\n\nexport interface SmokeRingProps extends ShaderComponentProps, SmokeRingParams {}\n\ntype SmokeRingPreset = ShaderPreset<SmokeRingParams>;\n\nexport const defaultPreset: SmokeRingPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0.5,\n    frame: 0,\n    colorBack: '#000000',\n    colors: ['#ffffff'],\n    noiseScale: 3,\n    noiseIterations: 8,\n    radius: 0.25,\n    thickness: 0.65,\n    innerShape: 0.7,\n    scale: 0.8,\n  },\n};\n\nexport const solarPreset: SmokeRingPreset = {\n  name: 'Solar',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: '#000000',\n    colors: ['#ffffff', '#ffca0a', '#fc6203', '#fc620366'],\n    noiseScale: 2,\n    noiseIterations: 3,\n    radius: 0.4,\n    thickness: 0.8,\n    innerShape: 4,\n    scale: 2,\n    offsetY: 1,\n  },\n};\n\nexport const linePreset: SmokeRingPreset = {\n  name: 'Line',\n  params: {\n    ...defaultObjectSizing,\n    frame: 0,\n    colorBack: '#000000',\n    colors: ['#4540a4', '#1fe8ff'],\n    noiseScale: 1.1,\n    noiseIterations: 2,\n    radius: 0.38,\n    thickness: 0.01,\n    innerShape: 0.88,\n    speed: 4,\n  },\n};\n\nexport const cloudPreset: SmokeRingPreset = {\n  name: 'Cloud',\n  params: {\n    ...defaultObjectSizing,\n    frame: 0,\n    colorBack: '#81ADEC',\n    colors: ['#ffffff'],\n    noiseScale: 3,\n    noiseIterations: 10,\n    radius: 0.5,\n    thickness: 0.65,\n    innerShape: 0.85,\n    speed: 0.5,\n    scale: 2.5,\n  },\n};\n\nexport const smokeRingPresets: SmokeRingPreset[] = [defaultPreset, linePreset, solarPreset, cloudPreset];\n\nexport const SmokeRing: React.FC<SmokeRingProps> = memo(function SmokeRingImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colors = defaultPreset.params.colors,\n  noiseScale = defaultPreset.params.noiseScale,\n  thickness = defaultPreset.params.thickness,\n  radius = defaultPreset.params.radius,\n  innerShape = defaultPreset.params.innerShape,\n  noiseIterations = defaultPreset.params.noiseIterations,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: SmokeRingProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_noiseScale: noiseScale,\n    u_thickness: thickness,\n    u_radius: radius,\n    u_innerShape: innerShape,\n    u_noiseIterations: noiseIterations,\n    u_noiseTexture: getShaderNoiseTexture(),\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies SmokeRingUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={smokeRingFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultPatternSizing,\n  getShaderColorFromString,\n  neuroNoiseFragmentShader,\n  ShaderFitOptions,\n  type NeuroNoiseParams,\n  type NeuroNoiseUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface NeuroNoiseProps extends ShaderComponentProps, NeuroNoiseParams {}\n\ntype NeuroNoisePreset = ShaderPreset<NeuroNoiseParams>;\n\nexport const defaultPreset: NeuroNoisePreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colorFront: '#ffffff',\n    colorMid: '#47a6ff',\n    colorBack: '#000000',\n    brightness: 0.05,\n    contrast: 0.3,\n  },\n};\n\nexport const sensationPreset: NeuroNoisePreset = {\n  name: 'Sensation',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colorFront: '#00c8ff',\n    colorMid: '#fbff00',\n    colorBack: '#8b42ff',\n    brightness: 0.19,\n    contrast: 0.12,\n    scale: 3,\n  },\n};\n\nexport const bloodstreamPreset: NeuroNoisePreset = {\n  name: 'Bloodstream',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colorFront: '#ff0000',\n    colorMid: '#ff0000',\n    colorBack: '#ffffff',\n    brightness: 0.24,\n    contrast: 0.17,\n    scale: 0.7,\n  },\n};\n\nexport const ghostPreset: NeuroNoisePreset = {\n  name: 'Ghost',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colorFront: '#ffffff',\n    colorMid: '#000000',\n    colorBack: '#ffffff',\n    brightness: 0.0,\n    contrast: 1.0,\n    scale: 0.55,\n  },\n};\n\nexport const neuroNoisePresets: NeuroNoisePreset[] = [\n  defaultPreset,\n  sensationPreset,\n  bloodstreamPreset,\n  ghostPreset,\n] as const;\n\nexport const NeuroNoise: React.FC<NeuroNoiseProps> = memo(function NeuroNoiseImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorFront = defaultPreset.params.colorFront,\n  colorMid = defaultPreset.params.colorMid,\n  colorBack = defaultPreset.params.colorBack,\n  brightness = defaultPreset.params.brightness,\n  contrast = defaultPreset.params.contrast,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: NeuroNoiseProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorFront: getShaderColorFromString(colorFront),\n    u_colorMid: getShaderColorFromString(colorMid),\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_brightness: brightness,\n    u_contrast: contrast,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies NeuroNoiseUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={neuroNoiseFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  getShaderColorFromString,\n  getShaderNoiseTexture,\n  dotOrbitFragmentShader,\n  ShaderFitOptions,\n  type DotOrbitParams,\n  type DotOrbitUniforms,\n  type ShaderPreset,\n  defaultPatternSizing,\n} from '@paper-design/shaders';\n\nexport interface DotOrbitProps extends ShaderComponentProps, DotOrbitParams {}\n\ntype DotOrbitPreset = ShaderPreset<DotOrbitParams>;\n\nexport const defaultPreset: DotOrbitPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1.5,\n    frame: 0,\n    colorBack: '#000000',\n    colors: ['#ffc96b', '#ff6200', '#ff2f00', '#421100', '#1a0000'],\n    size: 1,\n    sizeRange: 0,\n    spreading: 1,\n    stepsPerColor: 4,\n  },\n};\n\nexport const shinePreset: DotOrbitPreset = {\n  name: 'Shine',\n  params: {\n    ...defaultPatternSizing,\n    speed: 0.1,\n    frame: 0,\n    colors: ['#ffffff', '#006aff', '#fff675'],\n    colorBack: '#000000',\n    stepsPerColor: 4,\n    size: 0.3,\n    sizeRange: 0.2,\n    spreading: 1,\n    scale: 0.4,\n  },\n};\n\nexport const bubblesPreset: DotOrbitPreset = {\n  name: 'Bubbles',\n  params: {\n    ...defaultPatternSizing,\n    speed: 0.4,\n    frame: 0,\n    colors: ['#D0D2D5'],\n    colorBack: '#989CA4',\n    stepsPerColor: 2,\n    size: 0.9,\n    sizeRange: 0.7,\n    spreading: 1.0,\n    scale: 1.64,\n  },\n};\n\nexport const hallucinatoryPreset: DotOrbitPreset = {\n  name: 'Hallucinatory',\n  params: {\n    ...defaultPatternSizing,\n    speed: 5,\n    frame: 0,\n    colors: ['#000000'],\n    colorBack: '#ffe500',\n    stepsPerColor: 2,\n    size: 0.65,\n    sizeRange: 0,\n    spreading: 0.3,\n    scale: 0.5,\n  },\n};\n\nexport const dotOrbitPresets: DotOrbitPreset[] = [defaultPreset, bubblesPreset, shinePreset, hallucinatoryPreset];\n\nexport const DotOrbit: React.FC<DotOrbitProps> = memo(function DotOrbitImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colors = defaultPreset.params.colors,\n  size = defaultPreset.params.size,\n  sizeRange = defaultPreset.params.sizeRange,\n  spreading = defaultPreset.params.spreading,\n  stepsPerColor = defaultPreset.params.stepsPerColor,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: DotOrbitProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_size: size,\n    u_sizeRange: sizeRange,\n    u_spreading: spreading,\n    u_stepsPerColor: stepsPerColor,\n    u_noiseTexture: getShaderNoiseTexture(),\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies DotOrbitUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={dotOrbitFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  getShaderColorFromString,\n  dotGridFragmentShader,\n  DotGridShapes,\n  ShaderFitOptions,\n  type DotGridParams,\n  type DotGridUniforms,\n  type ShaderPreset,\n  defaultPatternSizing,\n} from '@paper-design/shaders';\n\nexport interface DotGridProps extends ShaderComponentProps, DotGridParams {}\n\ntype DotGridPreset = ShaderPreset<DotGridParams>;\n\nexport const defaultPreset: DotGridPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#000000',\n    colorFill: '#ffffff',\n    colorStroke: '#ffaa00',\n    size: 2,\n    gapX: 32,\n    gapY: 32,\n    strokeWidth: 0,\n    sizeRange: 0,\n    opacityRange: 0,\n    shape: 'circle',\n  },\n};\n\nconst trianglesPreset: DotGridPreset = {\n  name: 'Triangles',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#ffffff',\n    colorFill: '#ffffff',\n    colorStroke: '#808080',\n    size: 5,\n    gapX: 32,\n    gapY: 32,\n    strokeWidth: 1,\n    sizeRange: 0,\n    opacityRange: 0,\n    shape: 'triangle',\n  },\n};\n\nconst treeLinePreset: DotGridPreset = {\n  name: 'Tree line',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#f4fce7',\n    colorFill: '#052e19',\n    colorStroke: '#000000',\n    size: 8,\n    gapX: 20,\n    gapY: 90,\n    strokeWidth: 0,\n    sizeRange: 1,\n    opacityRange: 0.6,\n    shape: 'circle',\n  },\n};\n\nconst wallpaperPreset: DotGridPreset = {\n  name: 'Wallpaper',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#204030',\n    colorFill: '#000000',\n    colorStroke: '#bd955b',\n    size: 9,\n    gapX: 32,\n    gapY: 32,\n    strokeWidth: 1,\n    sizeRange: 0,\n    opacityRange: 0,\n    shape: 'diamond',\n  },\n};\n\nexport const dotGridPresets: DotGridPreset[] = [defaultPreset, trianglesPreset, treeLinePreset, wallpaperPreset];\n\nexport const DotGrid: React.FC<DotGridProps> = memo(function DotGridImpl({\n  // Own props\n  colorBack = defaultPreset.params.colorBack,\n  colorFill = defaultPreset.params.colorFill,\n  colorStroke = defaultPreset.params.colorStroke,\n  size = defaultPreset.params.size,\n  gapX = defaultPreset.params.gapX,\n  gapY = defaultPreset.params.gapY,\n  strokeWidth = defaultPreset.params.strokeWidth,\n  sizeRange = defaultPreset.params.sizeRange,\n  opacityRange = defaultPreset.params.opacityRange,\n  shape = defaultPreset.params.shape,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n\n  // Other props\n  maxPixelCount = 6016 * 3384, // Higher max resolution for this shader\n  ...props\n}: DotGridProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colorFill: getShaderColorFromString(colorFill),\n    u_colorStroke: getShaderColorFromString(colorStroke),\n    u_dotSize: size,\n    u_gapX: gapX,\n    u_gapY: gapY,\n    u_strokeWidth: strokeWidth,\n    u_sizeRange: sizeRange,\n    u_opacityRange: opacityRange,\n    u_shape: DotGridShapes[shape],\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies DotGridUniforms;\n\n  return (\n    <ShaderMount {...props} maxPixelCount={maxPixelCount} fragmentShader={dotGridFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  getShaderColorFromString,\n  simplexNoiseFragmentShader,\n  ShaderFitOptions,\n  type SimplexNoiseUniforms,\n  type SimplexNoiseParams,\n  type ShaderPreset,\n  defaultPatternSizing,\n} from '@paper-design/shaders';\n\nexport interface SimplexNoiseProps extends ShaderComponentProps, SimplexNoiseParams {}\n\ntype SimplexNoisePreset = ShaderPreset<SimplexNoiseParams>;\n\nexport const defaultPreset: SimplexNoisePreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.6,\n    speed: 0.5,\n    frame: 0,\n    colors: ['#4449CF', '#FFD1E0', '#F94446', '#FFD36B', '#FFFFFF'],\n    stepsPerColor: 2,\n    softness: 0,\n  },\n};\n\nexport const bubblegumPreset: SimplexNoisePreset = {\n  name: 'Bubblegum',\n  params: {\n    ...defaultPatternSizing,\n    speed: 2,\n    frame: 0,\n    colors: ['#ffffff', '#ff9e9e', '#5f57ff', '#00f7ff'],\n    stepsPerColor: 1,\n    softness: 1.0,\n    scale: 1.6,\n  },\n};\n\nexport const spotsPreset: SimplexNoisePreset = {\n  name: 'Spots',\n  params: {\n    ...defaultPatternSizing,\n    speed: 0.6,\n    frame: 0,\n    colors: ['#ff7b00', '#f9ffeb', '#320d82'],\n    stepsPerColor: 1,\n    softness: 0.0,\n    scale: 1.0,\n  },\n};\n\nexport const firstContactPreset: SimplexNoisePreset = {\n  name: 'First contact',\n  params: {\n    ...defaultPatternSizing,\n    speed: 2,\n    frame: 0,\n    colors: ['#e8cce6', '#120d22', '#442c44', '#e6baba', '#fff5f5'],\n    stepsPerColor: 2,\n    softness: 0.0,\n    scale: 0.2,\n  },\n};\n\nexport const simplexNoisePresets: SimplexNoisePreset[] = [\n  defaultPreset,\n  spotsPreset,\n  firstContactPreset,\n  bubblegumPreset,\n];\n\nexport const SimplexNoise: React.FC<SimplexNoiseProps> = memo(function SimplexNoiseImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  stepsPerColor = defaultPreset.params.stepsPerColor,\n  softness = defaultPreset.params.softness,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: SimplexNoiseProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_stepsPerColor: stepsPerColor,\n    u_softness: softness,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies SimplexNoiseUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={simplexNoiseFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  getShaderNoiseTexture,\n  metaballsFragmentShader,\n  ShaderFitOptions,\n  type MetaballsParams,\n  type MetaballsUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface MetaballsProps extends ShaderComponentProps, MetaballsParams {}\n\ntype MetaballsPreset = ShaderPreset<MetaballsParams>;\n\nexport const defaultPreset: MetaballsPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    scale: 1,\n    speed: 1,\n    frame: 0,\n    colorBack: '#000000',\n    colors: ['#6e33cc', '#ff5500', '#ffc105', '#ffc800', '#f585ff'],\n    count: 10,\n    size: 0.83,\n  },\n};\n\nexport const inkDropsPreset: MetaballsPreset = {\n  name: 'Ink Drops',\n  params: {\n    ...defaultObjectSizing,\n    scale: 1,\n    speed: 2,\n    frame: 0,\n    colorBack: '#ffffff00',\n    colors: ['#000000'],\n    count: 18,\n    size: 0.1,\n  },\n};\n\nexport const backgroundPreset: MetaballsPreset = {\n  name: 'Background',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0.5,\n    frame: 0,\n    colors: ['#ae00ff', '#00ff95', '#ffc105'],\n    colorBack: '#2a273f',\n    count: 13,\n    size: 0.81,\n    scale: 4.0,\n    rotation: 0,\n    offsetX: -0.3,\n  },\n};\n\nexport const solarPreset: MetaballsPreset = {\n  name: 'Solar',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: ['#ffc800', '#ff5500', '#ffc105'],\n    colorBack: '#102f84',\n    count: 7,\n    size: 0.75,\n    scale: 1,\n  },\n};\n\nexport const metaballsPresets: MetaballsPreset[] = [defaultPreset, inkDropsPreset, solarPreset, backgroundPreset];\n\nexport const Metaballs: React.FC<MetaballsProps> = memo(function MetaballsImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colors = defaultPreset.params.colors,\n  size = defaultPreset.params.size,\n  count = defaultPreset.params.count,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: MetaballsProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_size: size,\n    u_count: count,\n    u_noiseTexture: getShaderNoiseTexture(),\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies MetaballsUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={metaballsFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultPatternSizing,\n  getShaderColorFromString,\n  wavesFragmentShader,\n  ShaderFitOptions,\n  type WavesParams,\n  type WavesUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface WavesProps extends ShaderComponentProps, WavesParams {}\n\ntype WavesPreset = ShaderPreset<WavesParams>;\n\nexport const defaultPreset: WavesPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.6,\n    colorFront: '#ffbb00',\n    colorBack: '#000000',\n    shape: 0,\n    frequency: 0.5,\n    amplitude: 0.5,\n    spacing: 1.2,\n    proportion: 0.1,\n    softness: 0,\n  },\n};\n\nexport const groovyPreset: WavesPreset = {\n  name: 'Groovy',\n  params: {\n    ...defaultPatternSizing,\n    scale: 5,\n    rotation: 90,\n    colorFront: '#fcfcee',\n    colorBack: '#ff896b',\n    shape: 3,\n    frequency: 0.2,\n    amplitude: 0.25,\n    spacing: 1.17,\n    proportion: 0.57,\n    softness: 0,\n  },\n};\n\nexport const tangledUpPreset: WavesPreset = {\n  name: 'Tangled up',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.5,\n    rotation: 0,\n    colorFront: '#133a41',\n    colorBack: '#c2d8b6',\n    shape: 2.07,\n    frequency: 0.44,\n    amplitude: 0.57,\n    spacing: 1.05,\n    proportion: 0.75,\n    softness: 0,\n  },\n};\n\nexport const waveRidePreset: WavesPreset = {\n  name: 'Ride the wave',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1.7,\n    rotation: 0,\n    colorFront: '#fdffe6',\n    colorBack: '#1f1f1f',\n    shape: 2.25,\n    frequency: 0.2,\n    amplitude: 1,\n    spacing: 1.25,\n    proportion: 1,\n    softness: 0,\n  },\n};\n\nexport const wavesPresets: WavesPreset[] = [defaultPreset, groovyPreset, tangledUpPreset, waveRidePreset];\n\nexport const Waves: React.FC<WavesProps> = memo(function WavesImpl({\n  // Own props\n  colorFront = defaultPreset.params.colorFront,\n  colorBack = defaultPreset.params.colorBack,\n  shape = defaultPreset.params.shape,\n  frequency = defaultPreset.params.frequency,\n  amplitude = defaultPreset.params.amplitude,\n  spacing = defaultPreset.params.spacing,\n  proportion = defaultPreset.params.proportion,\n  softness = defaultPreset.params.softness,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n\n  // Other props\n  maxPixelCount = 6016 * 3384, // Higher max resolution for this shader\n  ...props\n}: WavesProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorFront: getShaderColorFromString(colorFront),\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_shape: shape,\n    u_frequency: frequency,\n    u_amplitude: amplitude,\n    u_spacing: spacing,\n    u_proportion: proportion,\n    u_softness: softness,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies WavesUniforms;\n\n  return <ShaderMount {...props} fragmentShader={wavesFragmentShader} uniforms={uniforms} />;\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultPatternSizing,\n  getShaderColorFromString,\n  perlinNoiseFragmentShader,\n  ShaderFitOptions,\n  type PerlinNoiseParams,\n  type PerlinNoiseUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface PerlinNoiseProps extends ShaderComponentProps, PerlinNoiseParams {}\n\ntype PerlinNoisePreset = ShaderPreset<PerlinNoiseParams>;\n\nexport const defaultPreset: PerlinNoisePreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    speed: 0.5,\n    frame: 0,\n    colorBack: '#632ad5',\n    colorFront: '#fccff7',\n    proportion: 0.35,\n    softness: 0.1,\n    octaveCount: 1,\n    persistence: 1,\n    lacunarity: 1.5,\n  },\n};\n\nexport const nintendoWaterPreset: PerlinNoisePreset = {\n  name: 'Nintendo Water',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1 / 0.2,\n    speed: 0.4,\n    frame: 0,\n    colorBack: '#2d69d4',\n    colorFront: '#d1eefc',\n    proportion: 0.42,\n    softness: 0,\n    octaveCount: 2,\n    persistence: 0.55,\n    lacunarity: 1.8,\n  },\n};\n\nexport const mossPreset: PerlinNoisePreset = {\n  name: 'Moss',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1 / 0.15,\n    speed: 0.02,\n    frame: 0,\n    colorBack: '#05ff4a',\n    colorFront: '#262626',\n    proportion: 0.65,\n    softness: 0.35,\n    octaveCount: 6,\n    persistence: 1,\n    lacunarity: 2.55,\n  },\n};\n\nexport const wormsPreset: PerlinNoisePreset = {\n  name: 'Worms',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.9,\n    speed: 0,\n    frame: 0,\n    colorBack: '#ffffff00',\n    colorFront: '#595959',\n    proportion: 0.5,\n    softness: 0,\n    octaveCount: 1,\n    persistence: 1,\n    lacunarity: 1.5,\n  },\n};\n\nexport const perlinNoisePresets: PerlinNoisePreset[] = [defaultPreset, nintendoWaterPreset, mossPreset, wormsPreset];\n\nexport const PerlinNoise: React.FC<PerlinNoiseProps> = memo(function PerlinNoiseImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorFront = defaultPreset.params.colorFront,\n  colorBack = defaultPreset.params.colorBack,\n  proportion = defaultPreset.params.proportion,\n  softness = defaultPreset.params.softness,\n  octaveCount = defaultPreset.params.octaveCount,\n  persistence = defaultPreset.params.persistence,\n  lacunarity,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  ...props\n}: PerlinNoiseProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colorFront: getShaderColorFromString(colorFront),\n    u_proportion: proportion,\n    u_softness: softness ?? defaultPreset.params.softness,\n    u_octaveCount: octaveCount ?? defaultPreset.params.octaveCount,\n    u_persistence: persistence ?? defaultPreset.params.persistence,\n    u_lacunarity: lacunarity ?? defaultPreset.params.lacunarity,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies PerlinNoiseUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={perlinNoiseFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultPatternSizing,\n  getShaderColorFromString,\n  getShaderNoiseTexture,\n  voronoiFragmentShader,\n  ShaderFitOptions,\n  type VoronoiParams,\n  type VoronoiUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface VoronoiProps extends ShaderComponentProps, VoronoiParams {}\n\ntype VoronoiPreset = ShaderPreset<VoronoiParams>;\n\nexport const defaultPreset: VoronoiPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    speed: 0.5,\n    frame: 0,\n    colors: ['#ff8247', '#ffe53d'],\n    stepsPerColor: 3,\n    colorGlow: '#ffffff',\n    colorGap: '#2e0000',\n    distortion: 0.4,\n    gap: 0.04,\n    glow: 0,\n    scale: 0.5,\n  },\n};\n\nexport const cellsPreset: VoronoiPreset = {\n  name: 'Cells',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.5,\n    speed: 0.5,\n    frame: 0,\n    colors: ['#ffffff'],\n    stepsPerColor: 1,\n    colorGlow: '#ffffff',\n    colorGap: '#000000',\n    distortion: 0.5,\n    gap: 0.03,\n    glow: 0.8,\n  },\n};\n\nexport const bubblesPreset: VoronoiPreset = {\n  name: 'Bubbles',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.75,\n    speed: 0.5,\n    frame: 0,\n    colors: ['#83c9fb'],\n    stepsPerColor: 1,\n    colorGlow: '#ffffff',\n    colorGap: '#ffffff',\n    distortion: 0.4,\n    gap: 0,\n    glow: 1,\n  },\n};\n\nexport const lightsPreset: VoronoiPreset = {\n  name: 'Lights',\n  params: {\n    ...defaultPatternSizing,\n    scale: 3.3,\n    speed: 0.5,\n    frame: 0,\n    colors: ['#fffffffc', '#bbff00', '#00ffff'],\n    colorGlow: '#ff00d0',\n    colorGap: '#ff00d0',\n    stepsPerColor: 2,\n    distortion: 0.38,\n    gap: 0.0,\n    glow: 1.0,\n  },\n};\n\nexport const voronoiPresets: VoronoiPreset[] = [defaultPreset, lightsPreset, cellsPreset, bubblesPreset];\n\nexport const Voronoi: React.FC<VoronoiProps> = memo(function VoronoiImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  stepsPerColor = defaultPreset.params.stepsPerColor,\n  colorGlow = defaultPreset.params.colorGlow,\n  colorGap = defaultPreset.params.colorGap,\n  distortion = defaultPreset.params.distortion,\n  gap = defaultPreset.params.gap,\n  glow = defaultPreset.params.glow,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: VoronoiProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_stepsPerColor: stepsPerColor,\n    u_colorGlow: getShaderColorFromString(colorGlow),\n    u_colorGap: getShaderColorFromString(colorGap),\n    u_distortion: distortion,\n    u_gap: gap,\n    u_glow: glow,\n    u_noiseTexture: getShaderNoiseTexture(),\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies VoronoiUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={voronoiFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultPatternSizing,\n  getShaderColorFromString,\n  getShaderNoiseTexture,\n  warpFragmentShader,\n  ShaderFitOptions,\n  type WarpParams,\n  type WarpUniforms,\n  type ShaderPreset,\n  WarpPatterns,\n} from '@paper-design/shaders';\n\nexport interface WarpProps extends ShaderComponentProps, WarpParams {}\n\ntype WarpPreset = ShaderPreset<WarpParams>;\n\nexport const defaultPreset: WarpPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    rotation: 0,\n    speed: 1,\n    frame: 0,\n    colors: ['#121212', '#9470ff', '#121212', '#8838ff'],\n    proportion: 0.45,\n    softness: 1,\n    distortion: 0.25,\n    swirl: 0.8,\n    swirlIterations: 10,\n    shapeScale: 0.1,\n    shape: 'checks',\n  },\n};\n\nexport const presetCauldron: WarpPreset = {\n  name: 'Cauldron Pot',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.9,\n    rotation: 160,\n    speed: 10,\n    frame: 0,\n    colors: ['#a7e58b', '#324472', '#0a180d'],\n    proportion: 0.64,\n    softness: 1.5,\n    distortion: 0.2,\n    swirl: 0.86,\n    swirlIterations: 7,\n    shapeScale: 0.6,\n    shape: 'edge',\n  },\n};\n\nexport const presetInk: WarpPreset = {\n  name: 'Live Ink',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1.2,\n    rotation: 44,\n    offsetY: -0.3,\n    speed: 2.5,\n    frame: 0,\n    colors: ['#111314', '#9faeab', '#f3fee7', '#f3fee7'],\n    proportion: 0.05,\n    softness: 0,\n    distortion: 0.25,\n    swirl: 0.8,\n    swirlIterations: 10,\n    shapeScale: 0.28,\n    shape: 'checks',\n  },\n};\n\nexport const presetKelp: WarpPreset = {\n  name: 'Kelp',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.8,\n    rotation: 50,\n    speed: 20,\n    frame: 0,\n    colors: ['#dbff8f', '#404f3e', '#091316'],\n    proportion: 0.67,\n    softness: 0,\n    distortion: 0,\n    swirl: 0.2,\n    swirlIterations: 3,\n    shapeScale: 1,\n    shape: 'stripes',\n  },\n};\n\nexport const presetNectar: WarpPreset = {\n  name: 'Nectar',\n  params: {\n    ...defaultPatternSizing,\n    scale: 2,\n    offsetY: 0.6,\n    rotation: 0,\n    speed: 4.2,\n    frame: 0,\n    colors: ['#151310', '#d3a86b', '#f0edea'],\n    proportion: 0.24,\n    softness: 1,\n    distortion: 0.21,\n    swirl: 0.57,\n    swirlIterations: 10,\n    shapeScale: 0.75,\n    shape: 'edge',\n  },\n};\n\nexport const presetPassion: WarpPreset = {\n  name: 'Passion',\n  params: {\n    ...defaultPatternSizing,\n    scale: 2.5,\n    rotation: 1.35,\n    speed: 3,\n    frame: 0,\n    colors: ['#3b1515', '#954751', '#ffc085'],\n    proportion: 0.5,\n    softness: 1,\n    distortion: 0.09,\n    swirl: 0.9,\n    swirlIterations: 6,\n    shapeScale: 0.25,\n    shape: 'checks',\n  },\n};\n\nexport const warpPresets: WarpPreset[] = [\n  defaultPreset,\n  presetCauldron,\n  presetInk,\n  presetKelp,\n  presetNectar,\n  presetPassion,\n];\n\nexport const Warp: React.FC<WarpProps> = memo(function WarpImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  proportion = defaultPreset.params.proportion,\n  softness = defaultPreset.params.softness,\n  distortion = defaultPreset.params.distortion,\n  swirl = defaultPreset.params.swirl,\n  swirlIterations = defaultPreset.params.swirlIterations,\n  shapeScale = defaultPreset.params.shapeScale,\n  shape = defaultPreset.params.shape,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: WarpProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_proportion: proportion,\n    u_softness: softness,\n    u_distortion: distortion,\n    u_swirl: swirl,\n    u_swirlIterations: swirlIterations,\n    u_shapeScale: shapeScale,\n    u_shape: WarpPatterns[shape],\n    u_noiseTexture: getShaderNoiseTexture(),\n\n    // Sizing uniforms\n    u_scale: scale,\n    u_rotation: rotation,\n    u_fit: ShaderFitOptions[fit],\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies WarpUniforms;\n\n  return <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={warpFragmentShader} uniforms={uniforms} />;\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultObjectSizing,\n  getShaderNoiseTexture,\n  getShaderColorFromString,\n  godRaysFragmentShader,\n  ShaderFitOptions,\n  type GodRaysParams,\n  type GodRaysUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface GodRaysProps extends ShaderComponentProps, GodRaysParams {}\n\ntype GodRaysPreset = ShaderPreset<GodRaysParams>;\n\nexport const defaultPreset: GodRaysPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    offsetX: 0,\n    offsetY: -0.55,\n    colorBack: '#000000',\n    colorBloom: '#0000ff',\n    colors: ['#a600ff6e', '#6200fff0', '#ffffff', '#33fff5'],\n    density: 0.3,\n    spotty: 0.3,\n    midIntensity: 0.4,\n    midSize: 0.2,\n    intensity: 0.8,\n    bloom: 0.4,\n    speed: 0.75,\n    frame: 0,\n  },\n};\n\nexport const warpPreset: GodRaysPreset = {\n  name: 'Warp',\n  params: {\n    ...defaultObjectSizing,\n    colorBack: '#000000',\n    colorBloom: '#222288',\n    colors: ['#ff47d4', '#ff8c00', '#ffffff'],\n    density: 0.45,\n    spotty: 0.15,\n    midIntensity: 0.4,\n    midSize: 0.33,\n    intensity: 0.79,\n    bloom: 0.4,\n    speed: 2,\n    frame: 0,\n  },\n};\n\nexport const linearPreset: GodRaysPreset = {\n  name: 'Linear',\n  params: {\n    ...defaultObjectSizing,\n    offsetX: 0.2,\n    offsetY: -0.8,\n    colorBack: '#000000',\n    colorBloom: '#eeeeee',\n    colors: ['#ffffff1f', '#ffffff3d', '#ffffff29'],\n    density: 0.41,\n    spotty: 0.25,\n    midSize: 0.1,\n    midIntensity: 0.75,\n    intensity: 0.79,\n    bloom: 1,\n    speed: 0.5,\n    frame: 0,\n  },\n};\n\nexport const etherPreset: GodRaysPreset = {\n  name: 'Ether',\n  params: {\n    ...defaultObjectSizing,\n    offsetX: -0.6,\n    colorBack: '#090f1d',\n    colorBloom: '#ffffff',\n    colors: ['#148effa6', '#c4dffebe', '#232a47'],\n    density: 0.03,\n    spotty: 0.77,\n    midSize: 0.1,\n    midIntensity: 0.6,\n    intensity: 0.6,\n    bloom: 0.6,\n    speed: 1,\n    frame: 0,\n  },\n};\n\nexport const godRaysPresets: GodRaysPreset[] = [defaultPreset, warpPreset, linearPreset, etherPreset];\n\nexport const GodRays: React.FC<GodRaysProps> = memo(function GodRaysImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBloom = defaultPreset.params.colorBloom,\n  colorBack = defaultPreset.params.colorBack,\n  colors = defaultPreset.params.colors,\n  density = defaultPreset.params.density,\n  spotty = defaultPreset.params.spotty,\n  midIntensity = defaultPreset.params.midIntensity,\n  midSize = defaultPreset.params.midSize,\n  intensity = defaultPreset.params.intensity,\n  bloom = defaultPreset.params.bloom,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: GodRaysProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBloom: getShaderColorFromString(colorBloom),\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_density: density,\n    u_spotty: spotty,\n    u_midIntensity: midIntensity,\n    u_midSize: midSize,\n    u_intensity: intensity,\n    u_bloom: bloom,\n    u_noiseTexture: getShaderNoiseTexture(),\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies GodRaysUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={godRaysFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultPatternSizing,\n  getShaderColorFromString,\n  ShaderFitOptions,\n  spiralFragmentShader,\n  type ShaderPreset,\n  type SpiralParams,\n  type SpiralUniforms,\n} from '@paper-design/shaders';\n\nexport interface SpiralProps extends ShaderComponentProps, SpiralParams {}\n\ntype SpiralPreset = ShaderPreset<SpiralParams>;\n\nexport const defaultPreset: SpiralPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1,\n    colorBack: '#001429',\n    colorFront: '#79D1FF',\n    density: 1,\n    distortion: 0,\n    strokeWidth: 0.5,\n    strokeTaper: 0,\n    strokeCap: 0,\n    noise: 0,\n    noiseFrequency: 0,\n    softness: 0,\n    speed: 1,\n    frame: 0,\n  },\n};\n\nexport const dropletPreset: SpiralPreset = {\n  name: 'Droplet',\n  params: {\n    ...defaultPatternSizing,\n    colorBack: '#effafe',\n    colorFront: '#bf40a0',\n    density: 0.9,\n    distortion: 0,\n    strokeWidth: 0.75,\n    strokeTaper: 0.18,\n    strokeCap: 1,\n    noise: 0.74,\n    noiseFrequency: 0.33,\n    softness: 0.02,\n    speed: 1,\n    frame: 0,\n  },\n};\n\nexport const junglePreset: SpiralPreset = {\n  name: 'Jungle',\n  params: {\n    ...defaultPatternSizing,\n    scale: 1.3,\n    density: 0.5,\n    colorBack: '#a0ef2a',\n    colorFront: '#288b18',\n    distortion: 0,\n    strokeWidth: 0.5,\n    strokeTaper: 0,\n    strokeCap: 0,\n    noise: 1,\n    noiseFrequency: 0.25,\n    softness: 0,\n    speed: 0.75,\n    frame: 0,\n  },\n};\n\nexport const swirlPreset: SpiralPreset = {\n  name: 'Swirl',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.45,\n    colorBack: '#b3e6d9',\n    colorFront: '#1a2b4d',\n    density: 0.2,\n    distortion: 0,\n    strokeWidth: 0.5,\n    strokeTaper: 0,\n    strokeCap: 0,\n    noise: 0,\n    noiseFrequency: 0.3,\n    softness: 0.5,\n    speed: 1,\n    frame: 0,\n  },\n};\n\nexport const spiralPresets: SpiralPreset[] = [defaultPreset, junglePreset, dropletPreset, swirlPreset];\n\nexport const Spiral: React.FC<SpiralProps> = memo(function SpiralImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colorFront = defaultPreset.params.colorFront,\n  density = defaultPreset.params.density,\n  distortion = defaultPreset.params.distortion,\n  strokeWidth = defaultPreset.params.strokeWidth,\n  strokeTaper = defaultPreset.params.strokeTaper,\n  strokeCap = defaultPreset.params.strokeCap,\n  noiseFrequency = defaultPreset.params.noiseFrequency,\n  noise = defaultPreset.params.noise,\n  softness = defaultPreset.params.softness,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: SpiralProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colorFront: getShaderColorFromString(colorFront),\n    u_density: density,\n    u_distortion: distortion,\n    u_strokeWidth: strokeWidth,\n    u_strokeTaper: strokeTaper,\n    u_strokeCap: strokeCap,\n    u_noiseFrequency: noiseFrequency,\n    u_noise: noise,\n    u_softness: softness,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies SpiralUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={spiralFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  ShaderFitOptions,\n  swirlFragmentShader,\n  type ShaderPreset,\n  type SwirlParams,\n  type SwirlUniforms,\n} from '@paper-design/shaders';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\n\nexport interface SwirlProps extends ShaderComponentProps, SwirlParams {}\n\ntype SwirlPreset = ShaderPreset<SwirlParams>;\n\nexport const defaultPreset: SwirlPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0.32,\n    frame: 0,\n    colorBack: '#330000',\n    colors: ['#ffd1d1', '#ff8a8a', '#660000'],\n    bandCount: 4,\n    twist: 0.1,\n    center: 0.2,\n    proportion: 0.5,\n    softness: 0,\n    noiseFrequency: 0.4,\n    noise: 0.2,\n  },\n};\n\nexport const openingPreset: SwirlPreset = {\n  name: 'Opening',\n  params: {\n    ...defaultObjectSizing,\n    offsetX: -0.4,\n    offsetY: 1,\n    speed: 0.5,\n    frame: 0,\n    colorBack: '#ff8b61',\n    colors: ['#fefff0', '#ffd8bd', '#ff8b61'],\n    bandCount: 2,\n    twist: 0.3,\n    center: 0.2,\n    proportion: 0.5,\n    softness: 0,\n    noiseFrequency: 0,\n    noise: 0,\n    scale: 1,\n  },\n} as const;\n\nexport const jamesBondPreset: SwirlPreset = {\n  name: '007',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: '#E9E7DA',\n    colors: ['#000000'],\n    bandCount: 5,\n    twist: 0.3,\n    center: 0,\n    proportion: 0,\n    softness: 0,\n    noiseFrequency: 0.5,\n    noise: 0,\n  },\n} as const;\n\nexport const candyPreset: SwirlPreset = {\n  name: 'Candy',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: '#ffcd66',\n    colors: ['#6bbceb', '#d7b3ff', '#ff9fff'],\n    bandCount: 2,\n    twist: 0.15,\n    center: 0.2,\n    proportion: 0.5,\n    softness: 1,\n    noiseFrequency: 0.5,\n    noise: 0,\n  },\n} as const;\n\nexport const swirlPresets: SwirlPreset[] = [defaultPreset, jamesBondPreset, openingPreset, candyPreset];\n\nexport const Swirl: React.FC<SwirlProps> = memo(function SwirlImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colors = defaultPreset.params.colors,\n  bandCount = defaultPreset.params.bandCount,\n  twist = defaultPreset.params.twist,\n  center = defaultPreset.params.center,\n  proportion = defaultPreset.params.proportion,\n  softness = defaultPreset.params.softness,\n  noiseFrequency = defaultPreset.params.noiseFrequency,\n  noise = defaultPreset.params.noise,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: SwirlProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_bandCount: bandCount,\n    u_twist: twist,\n    u_center: center,\n    u_proportion: proportion,\n    u_softness: softness,\n    u_noiseFrequency: noiseFrequency,\n    u_noise: noise,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies SwirlUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={swirlFragmentShader} uniforms={uniforms} />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport {\n  getShaderColorFromString,\n  ditheringFragmentShader,\n  ShaderFitOptions,\n  type DitheringUniforms,\n  type DitheringParams,\n  type ShaderPreset,\n  defaultPatternSizing,\n  defaultObjectSizing,\n  DitheringTypes,\n} from '@paper-design/shaders';\nimport { DitheringShapes } from '@paper-design/shaders';\n\nexport interface DitheringProps extends ShaderComponentProps, DitheringParams {\n  /** @deprecated use `size` instead */\n  pxSize?: number;\n}\n\ntype DitheringPreset = ShaderPreset<DitheringParams>;\n\nexport const defaultPreset: DitheringPreset = {\n  name: 'Default',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    scale: 0.6,\n    colorBack: '#000000',\n    colorFront: '#00b2ff',\n    shape: 'sphere',\n    type: '4x4',\n    size: 2,\n  },\n} as const;\n\nexport const sinePreset: DitheringPreset = {\n  name: 'Sine Wave',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: '#730d54',\n    colorFront: '#00becc',\n    shape: 'wave',\n    type: '4x4',\n    size: 11,\n    scale: 1.2,\n  },\n} as const;\n\nexport const bugsPreset: DitheringPreset = {\n  name: 'Bugs',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: '#000000',\n    colorFront: '#008000',\n    shape: 'dots',\n    type: 'random',\n    size: 9,\n  },\n} as const;\n\nexport const ripplePreset: DitheringPreset = {\n  name: 'Ripple',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: '#603520',\n    colorFront: '#c67953',\n    shape: 'ripple',\n    type: '2x2',\n    size: 3,\n  },\n} as const;\n\nexport const swirlPreset: DitheringPreset = {\n  name: 'Swirl',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: '#00000000',\n    colorFront: '#47a8e1',\n    shape: 'swirl',\n    type: '8x8',\n    size: 2,\n  },\n} as const;\n\nexport const warpPreset: DitheringPreset = {\n  name: 'Warp',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: '#301c2a',\n    colorFront: '#56ae6c',\n    shape: 'warp',\n    type: '4x4',\n    size: 2.5,\n  },\n} as const;\n\nexport const ditheringPresets: DitheringPreset[] = [\n  defaultPreset,\n  warpPreset,\n  sinePreset,\n  ripplePreset,\n  bugsPreset,\n  swirlPreset,\n];\n\nexport const Dithering: React.FC<DitheringProps> = memo(function DitheringImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colorFront = defaultPreset.params.colorFront,\n  shape = defaultPreset.params.shape,\n  type = defaultPreset.params.type,\n  pxSize,\n  size = pxSize === undefined ? defaultPreset.params.size : pxSize,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colorFront: getShaderColorFromString(colorFront),\n    u_shape: DitheringShapes[shape],\n    u_type: DitheringTypes[type],\n    u_pxSize: size,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies DitheringUniforms;\n\n  return (\n    <ShaderMount {...props} speed={speed} frame={frame} fragmentShader={ditheringFragmentShader} uniforms={uniforms} />\n  );\n});\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport {\n  getShaderColorFromString,\n  getShaderNoiseTexture,\n  grainGradientFragmentShader,\n  ShaderFitOptions,\n  type GrainGradientUniforms,\n  type GrainGradientParams,\n  type ShaderPreset,\n  defaultPatternSizing,\n  defaultObjectSizing,\n  GrainGradientShapes,\n} from '@paper-design/shaders';\n\nexport interface GrainGradientProps extends ShaderComponentProps, GrainGradientParams {}\n\ntype GrainGradientPreset = ShaderPreset<GrainGradientParams>;\n\nexport const defaultPreset: GrainGradientPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: '#000000',\n    colors: ['#7300ff', '#eba8ff', '#00bfff', '#2a00ff'],\n    softness: 0.5,\n    intensity: 0.5,\n    noise: 0.25,\n    shape: 'corners',\n  },\n};\n\nexport const wavePreset: GrainGradientPreset = {\n  name: 'Wave',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: '#000a0f',\n    colors: ['#c4730b', '#bdad5f', '#d8ccc7'],\n    softness: 0.7,\n    intensity: 0.15,\n    noise: 0.5,\n    shape: 'wave',\n  },\n};\n\nexport const dotsPreset: GrainGradientPreset = {\n  name: 'Dots',\n  params: {\n    ...defaultPatternSizing,\n    scale: 0.6,\n    speed: 1,\n    frame: 0,\n    colorBack: '#0a0000',\n    colors: ['#6f0000', '#0080ff', '#f2ebc9', '#33cc33'],\n    softness: 1,\n    intensity: 1,\n    noise: 0.7,\n    shape: 'dots',\n  },\n};\n\nexport const truchetPreset: GrainGradientPreset = {\n  name: 'Truchet',\n  params: {\n    ...defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: '#0a0000',\n    colors: ['#6f2200', '#eabb7c', '#39b523'],\n    softness: 0,\n    intensity: 0.2,\n    noise: 1,\n    shape: 'truchet',\n  },\n};\n\nexport const ripplePreset: GrainGradientPreset = {\n  name: 'Ripple',\n  params: {\n    ...defaultObjectSizing,\n    scale: 0.5,\n    speed: 1,\n    frame: 0,\n    colorBack: '#140a00',\n    colors: ['#6f2d00', '#88ddae', '#2c0b1d'],\n    softness: 0.5,\n    intensity: 0.5,\n    noise: 0.5,\n    shape: 'ripple',\n  },\n};\n\nexport const blobPreset: GrainGradientPreset = {\n  name: 'Blob',\n  params: {\n    ...defaultObjectSizing,\n    scale: 1.3,\n    speed: 1,\n    frame: 0,\n    colorBack: '#0f0e18',\n    colors: ['#3e6172', '#a49b74', '#568c50'],\n    softness: 0,\n    intensity: 0.15,\n    noise: 0.5,\n    shape: 'blob',\n  },\n};\n\nexport const grainGradientPresets: GrainGradientPreset[] = [\n  defaultPreset,\n  wavePreset,\n  dotsPreset,\n  truchetPreset,\n  ripplePreset,\n  blobPreset,\n];\n\nexport const GrainGradient: React.FC<GrainGradientProps> = memo(function GrainGradientImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colors = defaultPreset.params.colors,\n  softness = defaultPreset.params.softness,\n  intensity = defaultPreset.params.intensity,\n  noise = defaultPreset.params.noise,\n  shape = defaultPreset.params.shape,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: GrainGradientProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_softness: softness,\n    u_intensity: intensity,\n    u_noise: noise,\n    u_shape: GrainGradientShapes[shape],\n    u_noiseTexture: getShaderNoiseTexture(),\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies GrainGradientUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={grainGradientFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n});\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  getShaderNoiseTexture,\n  pulsingBorderFragmentShader,\n  ShaderFitOptions,\n  type PulsingBorderParams,\n  type PulsingBorderUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\nimport { PulsingBorderAspectRatios } from '@paper-design/shaders';\n\nexport interface PulsingBorderProps extends ShaderComponentProps, PulsingBorderParams {}\n\ntype PulsingBorderPreset = ShaderPreset<PulsingBorderParams>;\n\nexport const defaultPreset: PulsingBorderPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    scale: 0.6,\n    colorBack: '#000000',\n    colors: ['#0dc1fd', '#d915ef', '#ff3f2ecc'],\n    roundness: 0.25,\n    thickness: 0.1,\n    margin: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    marginBottom: 0,\n    aspectRatio: 'auto',\n    softness: 0.75,\n    intensity: 0.2,\n    bloom: 0.25,\n    spots: 5,\n    spotSize: 0.5,\n    pulse: 0.25,\n    smoke: 0.3,\n    smokeSize: 0.6,\n  },\n};\n\nexport const circlePreset: PulsingBorderPreset = {\n  name: 'Circle',\n  params: {\n    ...defaultObjectSizing,\n    aspectRatio: 'square',\n    scale: 0.6,\n    speed: 1,\n    frame: 0,\n    colorBack: '#000000',\n    colors: ['#0dc1fd', '#d915ef', '#ff3f2ecc'],\n    roundness: 1,\n    margin: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    marginBottom: 0,\n    thickness: 0,\n    softness: 0.75,\n    intensity: 0.2,\n    bloom: 0.45,\n    spots: 3,\n    spotSize: 0.4,\n    pulse: 0.5,\n    smoke: 1,\n    smokeSize: 0,\n  },\n};\n\nexport const northernLightsPreset: PulsingBorderPreset = {\n  name: 'Northern lights',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0.18,\n    scale: 1.1,\n    frame: 0,\n    colors: ['#4c4794', '#774a7d', '#12694a', '#0aff78', '#4733cc'],\n    colorBack: '#0c182c',\n    roundness: 0,\n    thickness: 1,\n    softness: 1,\n    margin: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    marginBottom: 0,\n    aspectRatio: 'auto',\n    intensity: 0.1,\n    bloom: 0.2,\n    spots: 4,\n    spotSize: 0.25,\n    pulse: 0,\n    smoke: 0.32,\n    smokeSize: 0.5,\n  },\n};\n\nexport const solidLinePreset: PulsingBorderPreset = {\n  name: 'Solid line',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: ['#81ADEC'],\n    colorBack: '#00000000',\n    roundness: 0,\n    thickness: 0.05,\n    margin: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    marginBottom: 0,\n    aspectRatio: 'auto',\n    softness: 0.0,\n    intensity: 0.0,\n    bloom: 0.15,\n    spots: 4,\n    spotSize: 1,\n    pulse: 0,\n    smoke: 0,\n    smokeSize: 0,\n  },\n};\n\nexport const pulsingBorderPresets: PulsingBorderPreset[] = [\n  defaultPreset,\n  circlePreset,\n  northernLightsPreset,\n  solidLinePreset,\n];\n\nexport const PulsingBorder: React.FC<PulsingBorderProps> = memo(function PulsingBorderImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  colorBack = defaultPreset.params.colorBack,\n  roundness = defaultPreset.params.roundness,\n  thickness = defaultPreset.params.thickness,\n  aspectRatio = defaultPreset.params.aspectRatio,\n  softness = defaultPreset.params.softness,\n  bloom = defaultPreset.params.bloom,\n  intensity = defaultPreset.params.intensity,\n  spots = defaultPreset.params.spots,\n  spotSize = defaultPreset.params.spotSize,\n  pulse = defaultPreset.params.pulse,\n  smoke = defaultPreset.params.smoke,\n  smokeSize = defaultPreset.params.smokeSize,\n  margin,\n  marginLeft = margin ?? defaultPreset.params.marginLeft,\n  marginRight = margin ?? defaultPreset.params.marginRight,\n  marginTop = margin ?? defaultPreset.params.marginTop,\n  marginBottom = margin ?? defaultPreset.params.marginBottom,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: PulsingBorderProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_roundness: roundness,\n    u_thickness: thickness,\n    u_marginLeft: marginLeft,\n    u_marginRight: marginRight,\n    u_marginTop: marginTop,\n    u_marginBottom: marginBottom,\n    u_aspectRatio: PulsingBorderAspectRatios[aspectRatio],\n    u_softness: softness,\n    u_intensity: intensity,\n    u_bloom: bloom,\n    u_spots: spots,\n    u_spotSize: spotSize,\n    u_pulse: pulse,\n    u_smoke: smoke,\n    u_smokeSize: smokeSize,\n    u_noiseTexture: getShaderNoiseTexture(),\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies PulsingBorderUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={pulsingBorderFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  getShaderColorFromString,\n  colorPanelsFragmentShader,\n  ShaderFitOptions,\n  type ColorPanelsUniforms,\n  type ColorPanelsParams,\n  type ShaderPreset,\n  defaultObjectSizing,\n} from '@paper-design/shaders';\n\nexport interface ColorPanelsProps extends ShaderComponentProps, ColorPanelsParams {}\n\ntype ColorPanelsPreset = ShaderPreset<ColorPanelsParams>;\n\nexport const defaultPreset: ColorPanelsPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0.5,\n    frame: 0,\n    colors: ['#ff9d00', '#fd4f30', '#809bff', '#6d2eff', '#333aff', '#f15cff', '#ffd557'],\n    colorBack: '#000000',\n    angle1: 0,\n    angle2: 0,\n    length: 1.1,\n    edges: false,\n    blur: 0,\n    fadeIn: 1,\n    fadeOut: 0.3,\n    gradient: 0,\n    density: 3,\n    scale: 0.8,\n  },\n};\n\nexport const glassPreset: ColorPanelsPreset = {\n  name: 'Glass',\n  params: {\n    ...defaultObjectSizing,\n    rotation: 112,\n    speed: 1,\n    frame: 0,\n    colors: ['#00cfff', '#ff2d55', '#34c759', '#af52de'],\n    colorBack: '#ffffff00',\n    angle1: 0.3,\n    angle2: 0.3,\n    length: 1,\n    edges: true,\n    blur: 0.25,\n    fadeIn: 0.85,\n    fadeOut: 0.3,\n    gradient: 0,\n    density: 1.6,\n  },\n};\n\nexport const gradientPreset: ColorPanelsPreset = {\n  name: 'Gradient',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0.5,\n    frame: 0,\n    colors: ['#f2ff00', '#00000000', '#00000000', '#5a0283', '#005eff'],\n    colorBack: '#8ffff2',\n    angle1: 0.4,\n    angle2: 0.4,\n    length: 3,\n    edges: false,\n    blur: 0.5,\n    fadeIn: 1.0,\n    fadeOut: 0.39,\n    gradient: 0.78,\n    density: 1.65,\n    scale: 1.72,\n    rotation: 270,\n    offsetX: 0.18,\n  },\n};\n\nexport const openingPreset: ColorPanelsPreset = {\n  name: 'Opening',\n  params: {\n    ...defaultObjectSizing,\n    speed: 2.0,\n    frame: 0,\n    colors: ['#00ffff'],\n    colorBack: '#570044',\n    angle1: -1.0,\n    angle2: -1.0,\n    length: 0.52,\n    edges: false,\n    blur: 0.0,\n    fadeIn: 0.0,\n    fadeOut: 1.0,\n    gradient: 0.0,\n    density: 2.21,\n    scale: 2.32,\n    rotation: 360,\n    offsetX: -0.3,\n    offsetY: 0.6,\n  },\n};\n\nexport const colorPanelsPresets: ColorPanelsPreset[] = [defaultPreset, glassPreset, gradientPreset, openingPreset];\n\nexport const ColorPanels: React.FC<ColorPanelsProps> = memo(function ColorPanelsImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  colorBack = defaultPreset.params.colorBack,\n  angle1 = defaultPreset.params.angle1,\n  angle2 = defaultPreset.params.angle2,\n  length = defaultPreset.params.length,\n  edges = defaultPreset.params.edges,\n  blur = defaultPreset.params.blur,\n  fadeIn = defaultPreset.params.fadeIn,\n  fadeOut = defaultPreset.params.fadeOut,\n  density = defaultPreset.params.density,\n  gradient = defaultPreset.params.gradient,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: ColorPanelsProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_angle1: angle1,\n    u_angle2: angle2,\n    u_length: length,\n    u_edges: edges,\n    u_blur: blur,\n    u_fadeIn: fadeIn,\n    u_fadeOut: fadeOut,\n    u_density: density,\n    u_gradient: gradient,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies ColorPanelsUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={colorPanelsFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  staticMeshGradientFragmentShader,\n  ShaderFitOptions,\n  type StaticMeshGradientParams,\n  type StaticMeshGradientUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface StaticMeshGradientProps extends ShaderComponentProps, StaticMeshGradientParams {}\n\ntype StaticMeshGradientPreset = ShaderPreset<StaticMeshGradientParams>;\n\nexport const defaultPreset: StaticMeshGradientPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    rotation: 270,\n    speed: 0,\n    frame: 0,\n    colors: ['#ffad0a', '#6200ff', '#e2a3ff', '#ff99fd'],\n    positions: 2,\n    waveX: 1.0,\n    waveXShift: 0.6,\n    waveY: 1.0,\n    waveYShift: 0.21,\n    mixing: 0.93,\n    grainMixer: 0.0,\n    grainOverlay: 0.0,\n  },\n};\n\nexport const seaPreset: StaticMeshGradientPreset = {\n  name: 'Sea',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0,\n    frame: 0,\n    colors: ['#013b65', '#03738c', '#a3d3ff', '#f2faef'],\n    positions: 0,\n    waveX: 0.53,\n    waveXShift: 0.0,\n    waveY: 0.95,\n    waveYShift: 0.64,\n    mixing: 0.5,\n    grainMixer: 0.0,\n    grainOverlay: 0.0,\n  },\n};\n\nexport const sixtiesPreset: StaticMeshGradientPreset = {\n  name: '1960s',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0,\n    frame: 0,\n    colors: ['#000000', '#082400', '#b1aa91', '#8e8c15'],\n    positions: 42,\n    waveX: 0.45,\n    waveXShift: 0.0,\n    waveY: 1.0,\n    waveYShift: 0.0,\n    mixing: 0.0,\n    grainMixer: 0.37,\n    grainOverlay: 0.78,\n  },\n};\n\nexport const sunsetPreset: StaticMeshGradientPreset = {\n  name: 'Sunset',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0,\n    frame: 0,\n    colors: ['#264653', '#9c2b2b', '#f4a261', '#ffffff'],\n    positions: 0,\n    waveX: 0.6,\n    waveXShift: 0.7,\n    waveY: 0.7,\n    waveYShift: 0.7,\n    mixing: 0.5,\n    grainMixer: 0,\n    grainOverlay: 0,\n  },\n};\n\nexport const staticMeshGradientPresets: StaticMeshGradientPreset[] = [\n  defaultPreset,\n  sixtiesPreset,\n  sunsetPreset,\n  seaPreset,\n];\n\nexport const StaticMeshGradient: React.FC<StaticMeshGradientProps> = memo(function StaticMeshGradientImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  positions = defaultPreset.params.positions,\n  waveX = defaultPreset.params.waveX,\n  waveXShift = defaultPreset.params.waveXShift,\n  waveY = defaultPreset.params.waveY,\n  waveYShift = defaultPreset.params.waveYShift,\n  mixing = defaultPreset.params.mixing,\n  grainMixer = defaultPreset.params.grainMixer,\n  grainOverlay = defaultPreset.params.grainOverlay,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: StaticMeshGradientProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_positions: positions,\n    u_waveX: waveX,\n    u_waveXShift: waveXShift,\n    u_waveY: waveY,\n    u_waveYShift: waveYShift,\n    u_mixing: mixing,\n    u_grainMixer: grainMixer,\n    u_grainOverlay: grainOverlay,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies StaticMeshGradientUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={staticMeshGradientFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  staticRadialGradientFragmentShader,\n  ShaderFitOptions,\n  type StaticRadialGradientParams,\n  type StaticRadialGradientUniforms,\n  type ShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface StaticRadialGradientProps extends ShaderComponentProps, StaticRadialGradientParams {}\n\ntype StaticRadialGradientPreset = ShaderPreset<StaticRadialGradientParams>;\n\nexport const defaultPreset: StaticRadialGradientPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    scale: 1,\n    speed: 0,\n    frame: 0,\n    colorBack: '#000000',\n    colors: ['#00bbff', '#00ffe1', '#ffffff'],\n    radius: 0.8,\n    focalDistance: 0.99,\n    focalAngle: 0,\n    falloff: 0.24,\n    mixing: 0.5,\n    distortion: 0.0,\n    distortionShift: 0,\n    distortionFreq: 12,\n    grainMixer: 0.0,\n    grainOverlay: 0.0,\n  },\n};\n\nexport const crossSectionPreset: StaticRadialGradientPreset = {\n  name: 'Cross Section',\n  params: {\n    ...defaultObjectSizing,\n    scale: 1,\n    speed: 0,\n    frame: 0,\n    colorBack: '#3d348b',\n    colors: ['#7678ed', '#f7b801', '#f18701', '#37a066'],\n    radius: 1,\n    focalDistance: 0,\n    focalAngle: 0,\n    falloff: 0,\n    mixing: 0,\n    distortion: 1,\n    distortionShift: 0,\n    distortionFreq: 12,\n    grainMixer: 0,\n    grainOverlay: 0,\n  },\n};\n\nexport const radialPreset: StaticRadialGradientPreset = {\n  name: 'Radial',\n  params: {\n    ...defaultObjectSizing,\n    scale: 1,\n    speed: 0,\n    frame: 0,\n    colorBack: '#264653',\n    colors: ['#9c2b2b', '#f4a261', '#ffffff'],\n    radius: 1,\n    focalDistance: 0,\n    focalAngle: 0,\n    falloff: 0,\n    mixing: 1,\n    distortion: 0,\n    distortionShift: 0,\n    distortionFreq: 12,\n    grainMixer: 0,\n    grainOverlay: 0,\n  },\n};\n\nexport const loFiPreset: StaticRadialGradientPreset = {\n  name: 'Lo-Fi',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0,\n    frame: 0,\n    colorBack: '#2e1f27',\n    colors: ['#d72638', '#3f88c5', '#f49d37'],\n    radius: 1,\n    focalDistance: 0,\n    focalAngle: 0,\n    falloff: 0.9,\n    mixing: 0.7,\n    distortion: 0,\n    distortionShift: 0,\n    distortionFreq: 12,\n    grainMixer: 1,\n    grainOverlay: 0.5,\n  },\n};\n\nexport const staticRadialGradientPresets: StaticRadialGradientPreset[] = [\n  defaultPreset,\n  loFiPreset,\n  crossSectionPreset,\n  radialPreset,\n];\n\nexport const StaticRadialGradient: React.FC<StaticRadialGradientProps> = memo(function StaticRadialGradientImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colors = defaultPreset.params.colors,\n  radius = defaultPreset.params.radius,\n  focalDistance = defaultPreset.params.focalDistance,\n  focalAngle = defaultPreset.params.focalAngle,\n  falloff = defaultPreset.params.falloff,\n  grainMixer = defaultPreset.params.grainMixer,\n  mixing = defaultPreset.params.mixing,\n  distortion = defaultPreset.params.distortion,\n  distortionShift = defaultPreset.params.distortionShift,\n  distortionFreq = defaultPreset.params.distortionFreq,\n  grainOverlay = defaultPreset.params.grainOverlay,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: StaticRadialGradientProps) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colors: colors.map(getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_radius: radius,\n    u_focalDistance: focalDistance,\n    u_focalAngle: focalAngle,\n    u_falloff: falloff,\n    u_mixing: mixing,\n    u_distortion: distortion,\n    u_distortionShift: distortionShift,\n    u_distortionFreq: distortionFreq,\n    u_grainMixer: grainMixer,\n    u_grainOverlay: grainOverlay,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies StaticRadialGradientUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={staticRadialGradientFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  defaultObjectSizing,\n  getShaderColorFromString,\n  getShaderNoiseTexture,\n  paperTextureFragmentShader,\n  ShaderFitOptions,\n  type ImageShaderPreset,\n  type PaperTextureParams,\n  type PaperTextureUniforms,\n} from '@paper-design/shaders';\n\nexport interface PaperTextureProps extends ShaderComponentProps, PaperTextureParams {\n  /** @deprecated use `fiberSize` instead */\n  fiberScale?: number;\n  /** @deprecated use `crumpleSize` instead */\n  crumplesScale?: number;\n  /** @deprecated use `foldCount` instead */\n  foldsNumber?: number;\n  /** @deprecated use `fade` instead */\n  blur?: number;\n}\n\ntype PaperTexturePreset = ImageShaderPreset<PaperTextureParams>;\n\nexport const defaultPreset: PaperTexturePreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    scale: 0.6,\n    speed: 0,\n    frame: 0,\n    colorFront: '#9fadbc',\n    colorBack: '#ffffff',\n    contrast: 0.3,\n    roughness: 0.4,\n    fiber: 0.3,\n    fiberSize: 0.2,\n    crumples: 0.3,\n    crumpleSize: 0.35,\n    folds: 0.65,\n    foldCount: 5,\n    fade: 0,\n    drops: 0.2,\n    seed: 5.8,\n  },\n};\n\nexport const abstractPreset: PaperTexturePreset = {\n  name: 'Abstract',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    scale: 0.6,\n    colorFront: '#00eeff',\n    colorBack: '#ff0a81',\n    contrast: 0.85,\n    roughness: 0,\n    fiber: 0.1,\n    fiberSize: 0.2,\n    crumples: 0,\n    crumpleSize: 0.3,\n    folds: 1,\n    foldCount: 3,\n    fade: 0,\n    drops: 0.2,\n    seed: 2.2,\n  },\n};\n\nexport const cardboardPreset: PaperTexturePreset = {\n  name: 'Cardboard',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    scale: 0.6,\n    colorFront: '#c7b89e',\n    colorBack: '#999180',\n    contrast: 0.4,\n    roughness: 0,\n    fiber: 0.35,\n    fiberSize: 0.14,\n    crumples: 0.7,\n    crumpleSize: 0.1,\n    folds: 0,\n    foldCount: 1,\n    fade: 0,\n    drops: 0.1,\n    seed: 1.6,\n  },\n};\n\nexport const detailsPreset: PaperTexturePreset = {\n  name: 'Details',\n  params: {\n    ...defaultObjectSizing,\n    speed: 0,\n    frame: 0,\n    fit: 'cover',\n    scale: 3,\n    colorFront: '#00000000',\n    colorBack: '#00000000',\n    contrast: 0,\n    roughness: 1,\n    fiber: 0.27,\n    fiberSize: 0.22,\n    crumples: 1,\n    crumpleSize: 0.5,\n    folds: 1,\n    foldCount: 15,\n    fade: 0,\n    drops: 0,\n    seed: 6,\n  },\n};\n\nexport const paperTexturePresets: PaperTexturePreset[] = [\n  defaultPreset,\n  cardboardPreset,\n  abstractPreset,\n  detailsPreset,\n] as const;\n\nexport const PaperTexture: React.FC<PaperTextureProps> = memo(function PaperTextureImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorFront = defaultPreset.params.colorFront,\n  colorBack = defaultPreset.params.colorBack,\n  image = '',\n  contrast = defaultPreset.params.contrast,\n  roughness = defaultPreset.params.roughness,\n  fiber = defaultPreset.params.fiber,\n  crumples = defaultPreset.params.crumples,\n  folds = defaultPreset.params.folds,\n  drops = defaultPreset.params.drops,\n  seed = defaultPreset.params.seed,\n\n  // Reworked props\n  fiberScale,\n  fiberSize = fiberScale === undefined ? defaultPreset.params.fiberSize : 0.2 / fiberScale,\n  crumplesScale,\n  crumpleSize = crumplesScale === undefined ? defaultPreset.params.crumpleSize : 0.2 / crumplesScale,\n  blur,\n  fade = blur === undefined ? defaultPreset.params.fade : blur,\n  foldsNumber,\n  foldCount = foldsNumber === undefined ? defaultPreset.params.foldCount : foldsNumber,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: PaperTextureProps) {\n  const noiseTexture = typeof window !== 'undefined' && { u_noiseTexture: getShaderNoiseTexture() };\n\n  const uniforms = {\n    // Own uniforms\n    u_image: image,\n    u_colorFront: getShaderColorFromString(colorFront),\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_contrast: contrast,\n    u_roughness: roughness,\n    u_fiber: fiber,\n    u_fiberSize: fiberSize,\n    u_crumples: crumples,\n    u_crumpleSize: crumpleSize,\n    u_foldCount: foldCount,\n    u_folds: folds,\n    u_fade: fade,\n    u_drops: drops,\n    u_seed: seed,\n    ...noiseTexture,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies PaperTextureUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={paperTextureFragmentShader}\n      mipmaps={['u_image']}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport {\n  flutedGlassFragmentShader,\n  ShaderFitOptions,\n  type FlutedGlassUniforms,\n  type FlutedGlassParams,\n  defaultObjectSizing,\n  GlassDistortionShapes,\n  GlassGridShapes,\n  type ImageShaderPreset,\n  getShaderColorFromString,\n} from '@paper-design/shaders';\n\nexport interface FlutedGlassProps extends ShaderComponentProps, FlutedGlassParams {\n  /** @deprecated use `size` instead */\n  count?: number;\n}\n\ntype FlutedGlassPreset = ImageShaderPreset<FlutedGlassParams>;\n\nexport const defaultPreset: FlutedGlassPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorBack: '#00000000',\n    colorShadow: '#000000',\n    colorHighlight: '#ffffff',\n    shadows: 0.25,\n    size: 0.5,\n    angle: 0,\n    distortionShape: 'prism',\n    highlights: 0.1,\n    shape: 'lines',\n    distortion: 0.5,\n    shift: 0,\n    blur: 0,\n    edges: 0.25,\n    stretch: 0,\n    margin: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    marginBottom: 0,\n    grainMixer: 0,\n    grainOverlay: 0,\n  },\n};\n\nexport const wavesPreset: FlutedGlassPreset = {\n  name: 'Waves',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    scale: 1.2,\n    speed: 0,\n    frame: 0,\n    colorBack: '#00000000',\n    colorShadow: '#000000',\n    colorHighlight: '#ffffff',\n    shadows: 0,\n    size: 0.9,\n    angle: 0,\n    distortionShape: 'contour',\n    highlights: 0,\n    shape: 'wave',\n    distortion: 0.5,\n    shift: 0,\n    blur: 0.1,\n    edges: 0.5,\n    stretch: 1,\n    margin: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    marginBottom: 0,\n    grainMixer: 0,\n    grainOverlay: 0.05,\n  },\n};\n\nexport const abstractPreset: FlutedGlassPreset = {\n  name: 'Abstract',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    scale: 4,\n    speed: 0,\n    frame: 0,\n    colorBack: '#00000000',\n    colorShadow: '#000000',\n    colorHighlight: '#ffffff',\n    shadows: 0,\n    size: 0.7,\n    angle: 30,\n    distortionShape: 'flat',\n    highlights: 0,\n    shape: 'linesIrregular',\n    distortion: 1,\n    shift: 0,\n    blur: 1,\n    edges: 0.5,\n    stretch: 1,\n    margin: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    marginBottom: 0,\n    grainMixer: 0.1,\n    grainOverlay: 0.1,\n  },\n};\n\nexport const foldsPreset: FlutedGlassPreset = {\n  name: 'Folds',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorBack: '#00000000',\n    colorShadow: '#000000',\n    colorHighlight: '#ffffff',\n    shadows: 0.4,\n    size: 0.4,\n    angle: 0,\n    distortionShape: 'cascade',\n    highlights: 0,\n    shape: 'lines',\n    distortion: 0.75,\n    shift: 0,\n    blur: 0.25,\n    edges: 0.5,\n    stretch: 0,\n    margin: 0.1,\n    marginLeft: 0.1,\n    marginRight: 0.1,\n    marginTop: 0.1,\n    marginBottom: 0.1,\n    grainMixer: 0,\n    grainOverlay: 0,\n  },\n};\n\nexport const flutedGlassPresets: FlutedGlassPreset[] = [defaultPreset, abstractPreset, wavesPreset, foldsPreset];\n\nexport const FlutedGlass: React.FC<FlutedGlassProps> = memo(function FlutedGlassImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colorShadow = defaultPreset.params.colorShadow,\n  colorHighlight = defaultPreset.params.colorHighlight,\n  image = '',\n  shadows = defaultPreset.params.shadows,\n  angle = defaultPreset.params.angle,\n  distortion = defaultPreset.params.distortion,\n  distortionShape = defaultPreset.params.distortionShape,\n  highlights = defaultPreset.params.highlights,\n  shape = defaultPreset.params.shape,\n  shift = defaultPreset.params.shift,\n  blur = defaultPreset.params.blur,\n  edges = defaultPreset.params.edges,\n  margin,\n  marginLeft = margin ?? defaultPreset.params.marginLeft,\n  marginRight = margin ?? defaultPreset.params.marginRight,\n  marginTop = margin ?? defaultPreset.params.marginTop,\n  marginBottom = margin ?? defaultPreset.params.marginBottom,\n  grainMixer = defaultPreset.params.grainMixer,\n  grainOverlay = defaultPreset.params.grainOverlay,\n  stretch = defaultPreset.params.stretch,\n\n  // integer `count` was deprecated in favor of the normalized `size` param\n  count,\n  size = count === undefined ? defaultPreset.params.size : Math.pow(1 / (count * 1.6), 1 / 6) / 0.7 - 0.5,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: FlutedGlassProps) {\n  const uniforms = {\n    // Own uniforms\n    u_image: image,\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colorShadow: getShaderColorFromString(colorShadow),\n    u_colorHighlight: getShaderColorFromString(colorHighlight),\n    u_shadows: shadows,\n    u_size: size,\n    u_angle: angle,\n    u_distortion: distortion,\n    u_shift: shift,\n    u_blur: blur,\n    u_edges: edges,\n    u_stretch: stretch,\n    u_distortionShape: GlassDistortionShapes[distortionShape],\n    u_highlights: highlights,\n    u_shape: GlassGridShapes[shape],\n    u_marginLeft: marginLeft,\n    u_marginRight: marginRight,\n    u_marginTop: marginTop,\n    u_marginBottom: marginBottom,\n    u_grainMixer: grainMixer,\n    u_grainOverlay: grainOverlay,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies FlutedGlassUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={flutedGlassFragmentShader}\n      mipmaps={['u_image']}\n      uniforms={uniforms}\n    />\n  );\n});\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  waterFragmentShader,\n  getShaderColorFromString,\n  ShaderFitOptions,\n  type WaterUniforms,\n  type WaterParams,\n  defaultObjectSizing,\n  type ImageShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface WaterProps extends ShaderComponentProps, WaterParams {\n  /** @deprecated use `size` instead */\n  effectScale?: number;\n}\n\ntype WaterPreset = ImageShaderPreset<WaterParams>;\n\nexport const defaultPreset: WaterPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    scale: 0.8,\n    speed: 1,\n    frame: 0,\n    colorBack: '#909090',\n    colorHighlight: '#ffffff',\n    highlights: 0.07,\n    layering: 0.5,\n    edges: 0.8,\n    waves: 0.3,\n    caustic: 0.1,\n    size: 1,\n  },\n};\n\nexport const abstractPreset: WaterPreset = {\n  name: 'Abstract',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    scale: 3,\n    speed: 1,\n    frame: 0,\n    colorBack: '#909090',\n    colorHighlight: '#ffffff',\n    highlights: 0,\n    layering: 0,\n    edges: 1,\n    waves: 1,\n    caustic: 0.4,\n    size: 0.15,\n  },\n};\n\nexport const streamingPreset: WaterPreset = {\n  name: 'Streaming',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'contain',\n    scale: 0.4,\n    speed: 2,\n    frame: 0,\n    colorBack: '#909090',\n    colorHighlight: '#ffffff',\n    highlights: 0,\n    layering: 0,\n    edges: 0,\n    waves: 0.5,\n    caustic: 0,\n    size: 0.5,\n  },\n};\n\nexport const slowMoPreset: WaterPreset = {\n  name: 'Slow-mo',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    scale: 1,\n    speed: 0.1,\n    frame: 0,\n    colorBack: '#909090',\n    colorHighlight: '#ffffff',\n    highlights: 0.4,\n    layering: 0,\n    edges: 0,\n    waves: 0,\n    caustic: 0.2,\n    size: 0.7,\n  },\n};\n\nexport const waterPresets: WaterPreset[] = [defaultPreset, slowMoPreset, abstractPreset, streamingPreset];\n\nexport const Water: React.FC<WaterProps> = memo(function WaterImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colorHighlight = defaultPreset.params.colorHighlight,\n  image = '',\n  highlights = defaultPreset.params.highlights,\n  layering = defaultPreset.params.layering,\n  waves = defaultPreset.params.waves,\n  edges = defaultPreset.params.edges,\n  caustic = defaultPreset.params.caustic,\n\n  // `effectScale` was deprecated in favor of `size`\n  // (it was a reverse value by mistake, so we took the opportunity to rename the param too)\n  effectScale,\n  size = effectScale === undefined ? defaultPreset.params.size : 10 / 9 / effectScale - 1 / 9,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: WaterProps) {\n  const uniforms = {\n    // Own uniforms\n    u_image: image,\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colorHighlight: getShaderColorFromString(colorHighlight),\n    u_highlights: highlights,\n    u_layering: layering,\n    u_waves: waves,\n    u_edges: edges,\n    u_caustic: caustic,\n    u_size: size,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies WaterUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={waterFragmentShader}\n      mipmaps={['u_image']}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  imageDitheringFragmentShader,\n  getShaderColorFromString,\n  ShaderFitOptions,\n  type ImageDitheringUniforms,\n  type ImageDitheringParams,\n  defaultObjectSizing,\n  DitheringTypes,\n  type ImageShaderPreset,\n} from '@paper-design/shaders';\n\nexport interface ImageDitheringProps extends ShaderComponentProps, ImageDitheringParams {\n  /** @deprecated use `size` instead */\n  pxSize?: number;\n}\n\ntype ImageDitheringPreset = ImageShaderPreset<ImageDitheringParams>;\n\nexport const defaultPreset: ImageDitheringPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    // scale: 0.95,\n    speed: 0,\n    frame: 0,\n    colorFront: '#94ffaf',\n    colorBack: '#000c38',\n    colorHighlight: '#eaff94',\n    type: '8x8',\n    size: 2,\n    colorSteps: 2,\n    originalColors: false,\n    inverted: false,\n  },\n} as const;\n\nexport const retroPreset: ImageDitheringPreset = {\n  name: 'Retro',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorFront: '#eeeeee',\n    colorBack: '#5452ff',\n    colorHighlight: '#eeeeee',\n    type: '2x2',\n    size: 3,\n    colorSteps: 1,\n    originalColors: true,\n    inverted: false,\n  },\n} as const;\n\nexport const noisePreset: ImageDitheringPreset = {\n  name: 'Noise',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorFront: '#a2997c',\n    colorBack: '#000000',\n    colorHighlight: '#ededed',\n    type: 'random',\n    size: 1,\n    colorSteps: 1,\n    originalColors: false,\n    inverted: false,\n  },\n} as const;\n\nexport const naturalPreset: ImageDitheringPreset = {\n  name: 'Natural',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorFront: '#ffffff',\n    colorBack: '#000000',\n    colorHighlight: '#ffffff',\n    type: '8x8',\n    size: 2,\n    colorSteps: 5,\n    originalColors: true,\n    inverted: false,\n  },\n} as const;\n\nexport const imageDitheringPresets: ImageDitheringPreset[] = [defaultPreset, noisePreset, retroPreset, naturalPreset];\n\nexport const ImageDithering: React.FC<ImageDitheringProps> = memo(function ImageDitheringImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorFront = defaultPreset.params.colorFront,\n  colorBack = defaultPreset.params.colorBack,\n  colorHighlight = defaultPreset.params.colorHighlight,\n  image = '',\n  type = defaultPreset.params.type,\n  colorSteps = defaultPreset.params.colorSteps,\n  originalColors = defaultPreset.params.originalColors,\n  inverted = defaultPreset.params.inverted,\n  pxSize,\n  size = pxSize === undefined ? defaultPreset.params.size : pxSize,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: ImageDitheringProps) {\n  const uniforms = {\n    // Own uniforms\n    u_image: image,\n    u_colorFront: getShaderColorFromString(colorFront),\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colorHighlight: getShaderColorFromString(colorHighlight),\n    u_type: DitheringTypes[type],\n    u_pxSize: size,\n    u_colorSteps: colorSteps,\n    u_originalColors: originalColors,\n    u_inverted: inverted,\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies ImageDitheringUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={imageDitheringFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import React, { memo, useLayoutEffect, useMemo, useState } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport {\n  getShaderColorFromString,\n  heatmapFragmentShader,\n  ShaderFitOptions,\n  type HeatmapUniforms,\n  type HeatmapParams,\n  defaultObjectSizing,\n  toProcessedHeatmap,\n  type ImageShaderPreset,\n} from '@paper-design/shaders';\n\nimport { transparentPixel } from '../transparent-pixel.js';\nimport { suspend } from '../suspend.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\n\nexport interface HeatmapProps extends ShaderComponentProps, HeatmapParams {\n  /**\n   * Suspends the component when the image is being processed.\n   */\n  suspendWhenProcessingImage?: boolean;\n}\n\nexport type HeatmapPreset = ImageShaderPreset<HeatmapParams>;\n\nexport const defaultPreset: HeatmapPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    scale: 0.75,\n    speed: 1,\n    frame: 0,\n    contour: 0.5,\n    angle: 0,\n    noise: 0,\n    innerGlow: 0.5,\n    outerGlow: 0.5,\n    colorBack: '#000000',\n    colors: ['#11206a', '#1f3ba2', '#2f63e7', '#6bd7ff', '#ffe679', '#ff991e', '#ff4c00'],\n  },\n} as const satisfies HeatmapPreset;\n\nexport const sepiaPreset: HeatmapPreset = {\n  name: 'Sepia',\n  params: {\n    ...defaultObjectSizing,\n    scale: 0.75,\n    speed: 0.5,\n    frame: 0,\n    contour: 0.5,\n    angle: 0,\n    noise: 0.75,\n    innerGlow: 0.5,\n    outerGlow: 0.5,\n    colorBack: '#000000',\n    colors: ['#997F45', '#ffffff'],\n  },\n} as const satisfies HeatmapPreset;\n\nexport const heatmapPresets: HeatmapPreset[] = [defaultPreset, sepiaPreset];\n\nexport const Heatmap: React.FC<HeatmapProps> = memo(function HeatmapImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  image = '',\n  contour = defaultPreset.params.contour,\n  angle = defaultPreset.params.angle,\n  noise = defaultPreset.params.noise,\n  innerGlow = defaultPreset.params.innerGlow,\n  outerGlow = defaultPreset.params.outerGlow,\n  colorBack = defaultPreset.params.colorBack,\n  colors = defaultPreset.params.colors,\n  suspendWhenProcessingImage = false,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  worldHeight = defaultPreset.params.worldHeight,\n  worldWidth = defaultPreset.params.worldWidth,\n  ...props\n}: HeatmapProps) {\n  const imageUrl = typeof image === 'string' ? image : image.src;\n  const [processedStateImage, setProcessedStateImage] = useState<string>(transparentPixel);\n\n  let processedImage: string;\n\n  // toProcessedHeatmap expects the document object to exist. This prevents SSR issues during builds.\n  if (suspendWhenProcessingImage && typeof window !== 'undefined') {\n    processedImage = suspend(\n      (): Promise<string> => toProcessedHeatmap(imageUrl).then((result) => URL.createObjectURL(result.blob)),\n      [imageUrl, 'heatmap']\n    );\n  } else {\n    processedImage = processedStateImage;\n  }\n\n  useLayoutEffect(() => {\n    if (suspendWhenProcessingImage) {\n      // Skip doing work in the effect as it's been handled by suspense.\n      return;\n    }\n\n    if (!imageUrl) {\n      setProcessedStateImage(transparentPixel);\n      return;\n    }\n\n    let url: string;\n    let current = true;\n\n    toProcessedHeatmap(imageUrl).then((result) => {\n      if (current) {\n        url = URL.createObjectURL(result.blob);\n        setProcessedStateImage(url);\n      }\n    });\n\n    return () => {\n      current = false;\n    };\n  }, [imageUrl, suspendWhenProcessingImage]);\n\n  const uniforms = useMemo(\n    () => ({\n      // Own uniforms\n      u_image: processedImage,\n      u_contour: contour,\n      u_angle: angle,\n      u_noise: noise,\n      u_innerGlow: innerGlow,\n      u_outerGlow: outerGlow,\n      u_colorBack: getShaderColorFromString(colorBack),\n      u_colors: colors.map(getShaderColorFromString),\n      u_colorsCount: colors.length,\n\n      // Sizing uniforms\n      u_fit: ShaderFitOptions[fit],\n      u_offsetX: offsetX,\n      u_offsetY: offsetY,\n      u_originX: originX,\n      u_originY: originY,\n      u_rotation: rotation,\n      u_scale: scale,\n      u_worldHeight: worldHeight,\n      u_worldWidth: worldWidth,\n    }),\n    [\n      speed,\n      frame,\n      contour,\n      angle,\n      noise,\n      innerGlow,\n      outerGlow,\n      colors,\n      colorBack,\n      processedImage,\n      fit,\n      offsetX,\n      offsetY,\n      originX,\n      originY,\n      rotation,\n      scale,\n      worldHeight,\n      worldWidth,\n    ]\n  ) satisfies HeatmapUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={heatmapFragmentShader}\n      mipmaps={['u_image']}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "export const transparentPixel = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n", "/**\n * A cut down version of suspend-react.\n * When paper-shaders only supports React 19+ we can use the use hook instead.\n */\n\ntype Tuple<T = any> = [T] | T[];\ntype Await<T> = T extends Promise<infer V> ? V : never;\ntype Cache<Keys extends Tuple<unknown>> = {\n  promise: Promise<unknown>;\n  keys: Keys;\n  error?: any;\n  response?: unknown;\n};\n\nconst isPromise = (promise: any): promise is Promise<unknown> =>\n  typeof promise === 'object' && typeof (promise as Promise<any>).then === 'function';\n\nconst globalCache: Cache<Tuple<unknown>>[] = [];\n\nfunction shallowEqualArrays(arrA: any[], arrB: any[]) {\n  if (arrA === arrB) return true;\n  if (!arrA || !arrB) return false;\n  const len = arrA.length;\n  if (arrB.length !== len) return false;\n  for (let i = 0; i < len; i++) if (arrA[i] !== arrB[i]) return false;\n  return true;\n}\n\nfunction query<Keys extends Tuple<unknown>, Fn extends (...keys: Keys) => Promise<unknown>>(\n  fn: Fn | Promise<unknown>,\n  keys: Keys = null as unknown as Keys\n) {\n  // If no keys were given, the function is the key\n  if (keys === null) keys = [fn] as unknown as Keys;\n\n  for (const entry of globalCache) {\n    // Find a match\n    if (shallowEqualArrays(keys, entry.keys)) {\n      // If an error occurred, throw\n      if (Object.prototype.hasOwnProperty.call(entry, 'error')) throw entry.error;\n      // If a response was successful, return\n      if (Object.prototype.hasOwnProperty.call(entry, 'response')) {\n        return entry.response as Await<ReturnType<Fn>>;\n      }\n      // If the promise is still unresolved, throw\n      throw entry.promise;\n    }\n  }\n\n  // The request is new or has changed.\n  const entry: Cache<Keys> = {\n    keys,\n    promise:\n      // Execute the promise\n      (isPromise(fn) ? fn : fn(...keys))\n        // When it resolves, store its value\n        .then((response) => {\n          entry.response = response;\n        })\n        // Store caught errors, they will be thrown in the render-phase to bubble into an error-bound\n        .catch((error) => (entry.error = error)),\n  };\n  // Register the entry\n  globalCache.push(entry);\n  // And throw the promise, this yields control back to React\n  throw entry.promise;\n}\n\nconst suspend = <Keys extends Tuple<unknown>, Fn extends (...keys: Keys) => Promise<unknown>>(\n  fn: Fn | Promise<unknown>,\n  keys?: Keys\n): Await<ReturnType<Fn>> => query(fn, keys);\n\nexport { suspend };\n", "import { memo, useLayoutEffect, useState } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport {\n  liquidMetalFragmentShader,\n  ShaderFitOptions,\n  defaultObjectSizing,\n  type LiquidMetalUniforms,\n  type LiquidMetalParams,\n  toProcessedLiquidMetal,\n  type ImageShaderPreset,\n  getShaderColorFromString,\n  LiquidMetalShapes,\n} from '@paper-design/shaders';\nimport { transparentPixel } from '../transparent-pixel.js';\nimport { suspend } from '../suspend.js';\n\nexport interface LiquidMetalProps extends ShaderComponentProps, LiquidMetalParams {\n  /**\n   * Suspends the component when the image is being processed.\n   */\n  suspendWhenProcessingImage?: boolean;\n}\n\ntype LiquidMetalPreset = ImageShaderPreset<LiquidMetalParams>;\n\nexport const defaultPreset: LiquidMetalPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    scale: 0.6,\n    speed: 1,\n    frame: 0,\n    colorBack: '#AAAAAC',\n    colorTint: '#ffffff',\n    distortion: 0.07,\n    repetition: 2.0,\n    shiftRed: 0.3,\n    shiftBlue: 0.3,\n    contour: 0.4,\n    softness: 0.1,\n    angle: 70,\n    shape: 'diamond',\n  },\n};\n\nexport const noirPreset: LiquidMetalPreset = {\n  name: 'Noir',\n  params: {\n    ...defaultObjectSizing,\n    scale: 0.6,\n    speed: 1,\n    frame: 0,\n    colorBack: '#000000',\n    colorTint: '#606060',\n    softness: 0.45,\n    repetition: 1.5,\n    shiftRed: 0,\n    shiftBlue: 0,\n    distortion: 0,\n    contour: 0,\n    angle: 90,\n    shape: 'diamond',\n  },\n};\n\nexport const fullScreenPreset: LiquidMetalPreset = {\n  name: 'Backdrop',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    scale: 1.5,\n    colorBack: '#AAAAAC',\n    colorTint: '#ffffff',\n    softness: 0.05,\n    repetition: 1.5,\n    shiftRed: 0.3,\n    shiftBlue: 0.3,\n    distortion: 0.1,\n    contour: 0.4,\n    shape: 'none',\n    angle: 90,\n    worldWidth: 0,\n    worldHeight: 0,\n  },\n};\n\nexport const stripesPreset: LiquidMetalPreset = {\n  name: 'Stripes',\n  params: {\n    ...defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    scale: 0.6,\n    colorBack: '#000000',\n    colorTint: '#2c5d72',\n    softness: 0.8,\n    repetition: 6,\n    shiftRed: 1,\n    shiftBlue: -1,\n    distortion: 0.4,\n    contour: 0.4,\n    shape: 'circle',\n    angle: 0,\n  },\n};\n\nexport const liquidMetalPresets: LiquidMetalPreset[] = [defaultPreset, noirPreset, fullScreenPreset, stripesPreset];\n\nexport const LiquidMetal: React.FC<LiquidMetalProps> = memo(function LiquidMetalImpl({\n  // Own props\n  colorBack = defaultPreset.params.colorBack,\n  colorTint = defaultPreset.params.colorTint,\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  image = '',\n  contour = defaultPreset.params.contour,\n  distortion = defaultPreset.params.distortion,\n  softness = defaultPreset.params.softness,\n  repetition = defaultPreset.params.repetition,\n  shiftRed = defaultPreset.params.shiftRed,\n  shiftBlue = defaultPreset.params.shiftBlue,\n  angle = defaultPreset.params.angle,\n  shape = defaultPreset.params.shape,\n  suspendWhenProcessingImage = false,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: LiquidMetalProps) {\n  const imageUrl = typeof image === 'string' ? image : image.src;\n  const [processedStateImage, setProcessedStateImage] = useState<string>(transparentPixel);\n\n  let processedImage: string;\n\n  if (suspendWhenProcessingImage && typeof window !== 'undefined' && imageUrl) {\n    processedImage = suspend(\n      (): Promise<string> => toProcessedLiquidMetal(imageUrl).then((result) => URL.createObjectURL(result.pngBlob)),\n      [imageUrl, 'liquid-metal']\n    );\n  } else {\n    processedImage = processedStateImage;\n  }\n\n  useLayoutEffect(() => {\n    if (suspendWhenProcessingImage) {\n      // Skip doing work in the effect as it's been handled by suspense.\n      return;\n    }\n\n    if (!imageUrl) {\n      setProcessedStateImage(transparentPixel);\n      return;\n    }\n\n    let url: string;\n    let current = true;\n\n    toProcessedLiquidMetal(imageUrl).then((result) => {\n      if (current) {\n        url = URL.createObjectURL(result.pngBlob);\n        setProcessedStateImage(url);\n      }\n    });\n\n    return () => {\n      current = false;\n    };\n  }, [imageUrl, suspendWhenProcessingImage]);\n\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colorTint: getShaderColorFromString(colorTint),\n\n    u_image: processedImage,\n    u_contour: contour,\n    u_distortion: distortion,\n    u_softness: softness,\n    u_repetition: repetition,\n    u_shiftRed: shiftRed,\n    u_shiftBlue: shiftBlue,\n    u_angle: angle,\n    u_isImage: Boolean(image),\n    u_shape: LiquidMetalShapes[shape],\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies LiquidMetalUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={liquidMetalFragmentShader}\n      mipmaps={['u_image']}\n      uniforms={uniforms}\n    />\n  );\n});\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  halftoneDotsFragmentShader,\n  getShaderColorFromString,\n  ShaderFitOptions,\n  type HalftoneDotsUniforms,\n  type HalftoneDotsParams,\n  defaultObjectSizing,\n  type ImageShaderPreset,\n  HalftoneDotsTypes,\n  HalftoneDotsGrids,\n} from '@paper-design/shaders';\n\nexport interface HalftoneDotsProps extends ShaderComponentProps, HalftoneDotsParams {}\n\ntype HalftoneDotsPreset = ImageShaderPreset<HalftoneDotsParams>;\n\nexport const defaultPreset: HalftoneDotsPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorBack: '#f2f1e8',\n    colorFront: '#2b2b2b',\n    size: 0.5,\n    radius: 1.25,\n    contrast: 0.4,\n    originalColors: false,\n    inverted: false,\n    grainMixer: 0.2,\n    grainOverlay: 0.2,\n    grainSize: 0.5,\n    grid: 'hex',\n    type: 'gooey',\n  },\n};\n\nexport const ledPreset: HalftoneDotsPreset = {\n  name: 'LED screen',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorBack: '#000000',\n    colorFront: '#29ff7b',\n    size: 0.5,\n    radius: 1.5,\n    contrast: 0.3,\n    originalColors: false,\n    inverted: false,\n    grainMixer: 0,\n    grainOverlay: 0,\n    grainSize: 0.5,\n    grid: 'square',\n    type: 'soft',\n  },\n};\n\nexport const netPreset: HalftoneDotsPreset = {\n  name: 'Mosaic',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorBack: '#000000',\n    colorFront: '#b2aeae',\n    size: 0.6,\n    radius: 2,\n    contrast: 0.01,\n    originalColors: true,\n    inverted: false,\n    grainMixer: 0,\n    grainOverlay: 0,\n    grainSize: 0.5,\n    grid: 'hex',\n    type: 'classic',\n  },\n};\n\nexport const roundAndSquarePreset: HalftoneDotsPreset = {\n  name: 'Round and square',\n  params: {\n    ...defaultObjectSizing,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorBack: '#141414',\n    colorFront: '#ff8000',\n    size: 0.8,\n    radius: 1,\n    contrast: 1,\n    originalColors: false,\n    inverted: true,\n    grainMixer: 0.05,\n    grainOverlay: 0.3,\n    grainSize: 0.5,\n    grid: 'square',\n    type: 'holes',\n  },\n};\n\nexport const halftoneDotsPresets: HalftoneDotsPreset[] = [defaultPreset, ledPreset, netPreset, roundAndSquarePreset];\n\nexport const HalftoneDots: React.FC<HalftoneDotsProps> = memo(function HalftoneDotsImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorFront = defaultPreset.params.colorFront,\n  colorBack = defaultPreset.params.colorBack,\n  image = '',\n  size = defaultPreset.params.size,\n  radius = defaultPreset.params.radius,\n  contrast = defaultPreset.params.contrast,\n  originalColors = defaultPreset.params.originalColors,\n  inverted = defaultPreset.params.inverted,\n  grainMixer = defaultPreset.params.grainMixer,\n  grainOverlay = defaultPreset.params.grainOverlay,\n  grainSize = defaultPreset.params.grainSize,\n  grid = defaultPreset.params.grid,\n  type = defaultPreset.params.type,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: HalftoneDotsProps) {\n  const uniforms = {\n    // Own uniforms\n    u_image: image,\n    u_colorFront: getShaderColorFromString(colorFront),\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_size: size,\n    u_radius: radius,\n    u_contrast: contrast,\n    u_originalColors: originalColors,\n    u_inverted: inverted,\n    u_grainMixer: grainMixer,\n    u_grainOverlay: grainOverlay,\n    u_grainSize: grainSize,\n    u_grid: HalftoneDotsGrids[grid],\n    u_type: HalftoneDotsTypes[type],\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies HalftoneDotsUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={halftoneDotsFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n", "import { memo } from 'react';\nimport { ShaderMount, type ShaderComponentProps } from '../shader-mount.js';\nimport { colorPropsAreEqual } from '../color-props-are-equal.js';\nimport {\n  halftoneCmykFragmentShader,\n  getShaderColorFromString,\n  getShaderNoiseTexture,\n  ShaderFitOptions,\n  type HalftoneCmykUniforms,\n  type HalftoneCmykParams,\n  defaultObjectSizing,\n  type ImageShaderPreset,\n  HalftoneCmykTypes,\n} from '@paper-design/shaders';\n\nexport interface HalftoneCmykProps extends ShaderComponentProps, HalftoneCmykParams {}\n\ntype HalftoneCmykPreset = ImageShaderPreset<HalftoneCmykParams>;\n\nexport const defaultPreset: HalftoneCmykPreset = {\n  name: 'Default',\n  params: {\n    ...defaultObjectSizing,\n    scale: 1,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorBack: '#fbfaf5',\n    colorC: '#00b4ff',\n    colorM: '#fc519f',\n    colorY: '#ffd800',\n    colorK: '#231f20',\n    size: 0.2,\n    contrast: 1,\n    softness: 1,\n    grainSize: 0.5,\n    grainMixer: 0,\n    grainOverlay: 0,\n    gridNoise: 0.2,\n    floodC: 0.15,\n    floodM: 0,\n    floodY: 0,\n    floodK: 0,\n    gainC: 0.3,\n    gainM: 0,\n    gainY: 0.2,\n    gainK: 0,\n    type: 'ink',\n  },\n};\n\nexport const dropsPreset: HalftoneCmykPreset = {\n  name: 'Drops',\n  params: {\n    ...defaultObjectSizing,\n    scale: 1,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorBack: '#eeefd7',\n    colorC: '#00b2ff',\n    colorM: '#fc4f4f',\n    colorY: '#ffd900',\n    colorK: '#231f20',\n    size: 0.88,\n    contrast: 1.15,\n    softness: 0,\n    grainSize: 0.01,\n    grainMixer: 0.05,\n    grainOverlay: 0.25,\n    gridNoise: 0.5,\n    floodC: 0.15,\n    floodM: 0,\n    floodY: 0,\n    floodK: 0,\n    gainC: 1.0,\n    gainM: 0.44,\n    gainY: -1.0,\n    gainK: 0,\n    type: 'ink',\n  },\n};\n\nexport const newspaper: HalftoneCmykPreset = {\n  name: 'Newspaper',\n  params: {\n    ...defaultObjectSizing,\n    scale: 1,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorBack: '#f2f1e8',\n    colorC: '#7a7a75',\n    colorM: '#7a7a75',\n    colorY: '#7a7a75',\n    colorK: '#231f20',\n    size: 0.01,\n    contrast: 2,\n    softness: 0.2,\n    grainSize: 0,\n    grainMixer: 0,\n    grainOverlay: 0.2,\n    gridNoise: 0.6,\n    floodC: 0,\n    floodM: 0,\n    floodY: 0,\n    floodK: 0.1,\n    gainC: -0.17,\n    gainM: -0.45,\n    gainY: -0.45,\n    gainK: 0,\n    type: 'dots',\n  },\n};\n\nexport const vintagePreset: HalftoneCmykPreset = {\n  name: 'Vintage',\n  params: {\n    ...defaultObjectSizing,\n    scale: 1,\n    fit: 'cover',\n    speed: 0,\n    frame: 0,\n    colorBack: '#fffaf0',\n    colorC: '#59afc5',\n    colorM: '#d8697c',\n    colorY: '#fad85c',\n    colorK: '#2d2824',\n    size: 0.2,\n    contrast: 1.25,\n    softness: 0.4,\n    grainSize: 0.5,\n    grainMixer: 0.15,\n    grainOverlay: 0.1,\n    gridNoise: 0.45,\n    floodC: 0.15,\n    floodM: 0,\n    floodY: 0,\n    floodK: 0,\n    gainC: 0.3,\n    gainM: 0,\n    gainY: 0.2,\n    gainK: 0,\n    type: 'sharp',\n  },\n};\n\nexport const halftoneCmykPresets: HalftoneCmykPreset[] = [defaultPreset, dropsPreset, newspaper, vintagePreset];\n\nexport const HalftoneCmyk: React.FC<HalftoneCmykProps> = memo(function HalftoneCmykImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colorC = defaultPreset.params.colorC,\n  colorM = defaultPreset.params.colorM,\n  colorY = defaultPreset.params.colorY,\n  colorK = defaultPreset.params.colorK,\n  image = '',\n  size = defaultPreset.params.size,\n  contrast = defaultPreset.params.contrast,\n  softness = defaultPreset.params.softness,\n  grainSize = defaultPreset.params.grainSize,\n  grainMixer = defaultPreset.params.grainMixer,\n  grainOverlay = defaultPreset.params.grainOverlay,\n  gridNoise = defaultPreset.params.gridNoise,\n  floodC = defaultPreset.params.floodC,\n  floodM = defaultPreset.params.floodM,\n  floodY = defaultPreset.params.floodY,\n  floodK = defaultPreset.params.floodK,\n  gainC = defaultPreset.params.gainC,\n  gainM = defaultPreset.params.gainM,\n  gainY = defaultPreset.params.gainY,\n  gainK = defaultPreset.params.gainK,\n  type = defaultPreset.params.type,\n\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}: HalftoneCmykProps) {\n  const uniforms = {\n    // Own uniforms\n    u_image: image,\n    u_noiseTexture: getShaderNoiseTexture(),\n    u_colorBack: getShaderColorFromString(colorBack),\n    u_colorC: getShaderColorFromString(colorC),\n    u_colorM: getShaderColorFromString(colorM),\n    u_colorY: getShaderColorFromString(colorY),\n    u_colorK: getShaderColorFromString(colorK),\n    u_size: size,\n    u_contrast: contrast,\n    u_softness: softness,\n    u_grainSize: grainSize,\n    u_grainMixer: grainMixer,\n    u_grainOverlay: grainOverlay,\n    u_gridNoise: gridNoise,\n    u_floodC: floodC,\n    u_floodM: floodM,\n    u_floodY: floodY,\n    u_floodK: floodK,\n    u_gainC: gainC,\n    u_gainM: gainM,\n    u_gainY: gainY,\n    u_gainK: gainK,\n    u_type: HalftoneCmykTypes[type],\n\n    // Sizing uniforms\n    u_fit: ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight,\n  } satisfies HalftoneCmykUniforms;\n\n  return (\n    <ShaderMount\n      {...props}\n      speed={speed}\n      frame={frame}\n      fragmentShader={halftoneCmykFragmentShader}\n      uniforms={uniforms}\n    />\n  );\n}, colorPropsAreEqual);\n"],
  "mappings": "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",
  "names": ["vertexShaderSource", "p", "q", "ShaderMount", "import_react", "_a", "import_jsx_runtime", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "solarPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "bubblesPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "swirlPreset", "warpPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ripplePreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "openingPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "abstractPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "abstractPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "entry", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount", "import_react", "import_jsx_runtime", "defaultPreset", "ShaderMount"]
}
