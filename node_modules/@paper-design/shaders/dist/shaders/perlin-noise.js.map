{
  "version": 3,
  "sources": ["../../src/shaders/perlin-noise.ts"],
  "sourcesContent": ["import type { ShaderMotionParams } from '../shader-mount.js';\nimport { type ShaderSizingParams, type ShaderSizingUniforms } from '../shader-sizing.js';\nimport { declarePI, colorBandingFix, proceduralHash11, proceduralHash21 } from '../shader-utils.js';\n\n/**\n * Classic animated 3D Perlin noise with exposed controls.\n * Original algorithm: https://www.shadertoy.com/view/NlSGDz\n *\n * Fragment shader uniforms:\n * - u_time (float): Animation time\n * - u_colorFront (vec4): Foreground color in RGBA\n * - u_colorBack (vec4): Background color in RGBA\n * - u_proportion (float): Blend point between 2 colors, 0.5 = equal distribution (0 to 1)\n * - u_softness (float): Color transition sharpness, 0 = hard edge, 1 = smooth gradient (0 to 1)\n * - u_octaveCount (float): Perlin noise octaves number, more octaves for more detailed patterns (1 to 8)\n * - u_persistence (float): Roughness, falloff between octaves (0.3 to 1)\n * - u_lacunarity (float): Frequency step, defines how compressed the pattern is (1.5 to 10)\n *\n * Vertex shader outputs (used in fragment shader):\n * - v_patternUV (vec2): UV coordinates for pattern with global sizing (rotation, scale, offset, etc) applied\n *\n * Vertex shader uniforms:\n * - u_resolution (vec2): Canvas resolution in pixels\n * - u_pixelRatio (float): Device pixel ratio\n * - u_originX (float): Reference point for positioning world width in the canvas (0 to 1)\n * - u_originY (float): Reference point for positioning world height in the canvas (0 to 1)\n * - u_worldWidth (float): Virtual width of the graphic before it's scaled to fit the canvas\n * - u_worldHeight (float): Virtual height of the graphic before it's scaled to fit the canvas\n * - u_fit (float): How to fit the rendered shader into the canvas dimensions (0 = none, 1 = contain, 2 = cover)\n * - u_scale (float): Overall zoom level of the graphics (0.01 to 4)\n * - u_rotation (float): Overall rotation angle of the graphics in degrees (0 to 360)\n * - u_offsetX (float): Horizontal offset of the graphics center (-1 to 1)\n * - u_offsetY (float): Vertical offset of the graphics center (-1 to 1)\n *\n */\n\n// language=GLSL\nexport const perlinNoiseFragmentShader: string = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colorFront;\nuniform vec4 u_colorBack;\nuniform float u_proportion;\nuniform float u_softness;\nuniform float u_octaveCount;\nuniform float u_persistence;\nuniform float u_lacunarity;\n\nin vec2 v_patternUV;\n\nout vec4 fragColor;\n\n${ declarePI }\n${ proceduralHash11 }\n${ proceduralHash21 }\n\nfloat hash31(vec3 p) {\n  p = fract(p * 0.3183099) + 0.1;\n  p += dot(p, p.yzx + 19.19);\n  return fract(p.x * (p.y + p.z));\n}\n\nvec3 gradientPredefined(float hash) {\n  int idx = int(hash * 12.0) % 12;\n\n  if (idx == 0) return vec3(1, 1, 0);\n  if (idx == 1) return vec3(-1, 1, 0);\n  if (idx == 2) return vec3(1, -1, 0);\n  if (idx == 3) return vec3(-1, -1, 0);\n  if (idx == 4) return vec3(1, 0, 1);\n  if (idx == 5) return vec3(-1, 0, 1);\n  if (idx == 6) return vec3(1, 0, -1);\n  if (idx == 7) return vec3(-1, 0, -1);\n  if (idx == 8) return vec3(0, 1, 1);\n  if (idx == 9) return vec3(0, -1, 1);\n  if (idx == 10) return vec3(0, 1, -1);\n  return vec3(0, -1, -1);// idx == 11\n}\n\nfloat interpolateSafe(float v000, float v001, float v010, float v011,\nfloat v100, float v101, float v110, float v111, vec3 t) {\n  t = clamp(t, 0.0, 1.0);\n\n  float v00 = mix(v000, v100, t.x);\n  float v01 = mix(v001, v101, t.x);\n  float v10 = mix(v010, v110, t.x);\n  float v11 = mix(v011, v111, t.x);\n\n  float v0 = mix(v00, v10, t.y);\n  float v1 = mix(v01, v11, t.y);\n\n  return mix(v0, v1, t.z);\n}\n\nvec3 fade(vec3 t) {\n  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec3 position, float seed) {\n  position += vec3(seed * 127.1, seed * 311.7, seed * 74.7);\n\n  vec3 i = floor(position);\n  vec3 f = fract(position);\n  float h000 = hash31(i);\n  float h001 = hash31(i + vec3(0, 0, 1));\n  float h010 = hash31(i + vec3(0, 1, 0));\n  float h011 = hash31(i + vec3(0, 1, 1));\n  float h100 = hash31(i + vec3(1, 0, 0));\n  float h101 = hash31(i + vec3(1, 0, 1));\n  float h110 = hash31(i + vec3(1, 1, 0));\n  float h111 = hash31(i + vec3(1, 1, 1));\n  vec3 g000 = gradientPredefined(h000);\n  vec3 g001 = gradientPredefined(h001);\n  vec3 g010 = gradientPredefined(h010);\n  vec3 g011 = gradientPredefined(h011);\n  vec3 g100 = gradientPredefined(h100);\n  vec3 g101 = gradientPredefined(h101);\n  vec3 g110 = gradientPredefined(h110);\n  vec3 g111 = gradientPredefined(h111);\n  float v000 = dot(g000, f - vec3(0, 0, 0));\n  float v001 = dot(g001, f - vec3(0, 0, 1));\n  float v010 = dot(g010, f - vec3(0, 1, 0));\n  float v011 = dot(g011, f - vec3(0, 1, 1));\n  float v100 = dot(g100, f - vec3(1, 0, 0));\n  float v101 = dot(g101, f - vec3(1, 0, 1));\n  float v110 = dot(g110, f - vec3(1, 1, 0));\n  float v111 = dot(g111, f - vec3(1, 1, 1));\n\n  vec3 u = fade(f);\n  return interpolateSafe(v000, v001, v010, v011, v100, v101, v110, v111, u);\n}\n\nfloat p_noise(vec3 position, int octaveCount, float persistence, float lacunarity) {\n  float value = 0.0;\n  float amplitude = 1.0;\n  float frequency = 10.0;\n  float maxValue = 0.0;\n  octaveCount = clamp(octaveCount, 1, 8);\n\n  for (int i = 0; i < octaveCount; i++) {\n    float seed = float(i) * 0.7319;\n    value += perlinNoise(position * frequency, seed) * amplitude;\n    maxValue += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n  return value;\n}\n\nfloat get_max_amp(float persistence, float octaveCount) {\n  persistence = clamp(persistence * 0.999, 0.0, 0.999);\n  octaveCount = clamp(octaveCount, 1.0, 8.0);\n\n  if (abs(persistence - 1.0) < 0.001) {\n    return octaveCount;\n  }\n\n  return (1.0 - pow(persistence, octaveCount)) / max(1e-4, (1.0 - persistence));\n}\n\nvoid main() {\n  vec2 uv = v_patternUV;\n  uv *= .5;\n\n  float t = .2 * u_time;\n\n  vec3 p = vec3(uv, t);\n\n  float octCount = floor(u_octaveCount);\n  float noise = p_noise(p, int(octCount), u_persistence, u_lacunarity);\n\n  float max_amp = get_max_amp(u_persistence, octCount);\n  float noise_normalized = clamp((noise + max_amp) / max(1e-4, (2. * max_amp)) + (u_proportion - .5), 0.0, 1.0);\n  float sharpness = clamp(u_softness, 0., 1.);\n  float smooth_w = 0.5 * max(fwidth(noise_normalized), 0.001);\n  float res = smoothstep(\n  .5 - .5 * sharpness - smooth_w,\n  .5 + .5 * sharpness + smooth_w,\n  noise_normalized\n  );\n\n  vec3 fgColor = u_colorFront.rgb * u_colorFront.a;\n  float fgOpacity = u_colorFront.a;\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  float bgOpacity = u_colorBack.a;\n\n  vec3 color = fgColor * res;\n  float opacity = fgOpacity * res;\n\n  color += bgColor * (1. - opacity);\n  opacity += bgOpacity * (1. - opacity);\n\n  ${ colorBandingFix }\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\nexport interface PerlinNoiseUniforms extends ShaderSizingUniforms {\n  u_colorFront: [number, number, number, number];\n  u_colorBack: [number, number, number, number];\n  u_proportion: number;\n  u_softness: number;\n  u_octaveCount: number;\n  u_persistence: number;\n  u_lacunarity: number;\n}\n\nexport interface PerlinNoiseParams extends ShaderSizingParams, ShaderMotionParams {\n  colorFront?: string;\n  colorBack?: string;\n  proportion?: number;\n  softness?: number;\n  octaveCount?: number;\n  persistence?: number;\n  lacunarity?: number;\n}\n"],
  "mappings": ";;;;;AACA,eAAmE;AACnE,SAAS,WAAW,iBAAiB,kBAAkB,wBAAwB;AAmCxE,MAAM,4BAAoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiB9C,SAAU;AAAA,EACV,gBAAiB;AAAA,EACjB,gBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA0If,eAAgB;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
