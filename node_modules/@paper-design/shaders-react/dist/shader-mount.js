/* * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                    Paper Shaders                    *
 *       https://github.com/paper-design/shaders       *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * */

"use client";
import { useEffect, useRef, forwardRef, useState } from "react";
import {
  ShaderMount as ShaderMountVanilla,
  getEmptyPixel
} from "@paper-design/shaders";
import { useMergeRefs } from "./use-merge-refs.js";
import { setMinImageSize } from "./set-min-image-size.js";
import { jsx } from "react/jsx-runtime";
async function processUniforms(uniformsProp) {
  const processedUniforms = {};
  const imageLoadPromises = [];
  const isValidUrl = (url) => {
    try {
      if (url.startsWith("/")) return true;
      new URL(url);
      return true;
    } catch {
      return false;
    }
  };
  const isExternalUrl = (url) => {
    try {
      if (url.startsWith("/")) return false;
      const urlObject = new URL(url, window.location.origin);
      return urlObject.origin !== window.location.origin;
    } catch {
      return false;
    }
  };
  Object.entries(uniformsProp).forEach(([key, value]) => {
    if (typeof value === "string") {
      if (!value) {
        processedUniforms[key] = getEmptyPixel();
        return;
      }
      if (!isValidUrl(value)) {
        console.warn(`Uniform "${key}" has invalid URL "${value}". Skipping image loading.`);
        return;
      }
      const imagePromise = new Promise((resolve, reject) => {
        const img = new Image();
        if (isExternalUrl(value)) {
          img.crossOrigin = "anonymous";
        }
        img.onload = () => {
          setMinImageSize(img);
          processedUniforms[key] = img;
          resolve();
        };
        img.onerror = () => {
          console.error(`Could not set uniforms. Failed to load image at ${value}`);
          reject();
        };
        img.src = value;
      });
      imageLoadPromises.push(imagePromise);
    } else if (value instanceof HTMLImageElement) {
      setMinImageSize(value);
      processedUniforms[key] = value;
    } else {
      processedUniforms[key] = value;
    }
  });
  await Promise.all(imageLoadPromises);
  return processedUniforms;
}
const ShaderMount = forwardRef(
  function ShaderMountImpl({
    fragmentShader,
    uniforms: uniformsProp,
    webGlContextAttributes,
    speed = 0,
    frame = 0,
    width,
    height,
    minPixelRatio,
    maxPixelCount,
    mipmaps,
    style,
    ...divProps
  }, forwardedRef) {
    const [isInitialized, setIsInitialized] = useState(false);
    const divRef = useRef(null);
    const shaderMountRef = useRef(null);
    const webGlContextAttributesRef = useRef(webGlContextAttributes);
    useEffect(() => {
      const initShader = async () => {
        const uniforms = await processUniforms(uniformsProp);
        if (divRef.current && !shaderMountRef.current) {
          shaderMountRef.current = new ShaderMountVanilla(
            divRef.current,
            fragmentShader,
            uniforms,
            webGlContextAttributesRef.current,
            speed,
            frame,
            minPixelRatio,
            maxPixelCount,
            mipmaps
          );
          setIsInitialized(true);
        }
      };
      initShader();
      return () => {
        shaderMountRef.current?.dispose();
        shaderMountRef.current = null;
      };
    }, [fragmentShader]);
    useEffect(() => {
      let isStale = false;
      const updateUniforms = async () => {
        const uniforms = await processUniforms(uniformsProp);
        if (!isStale) {
          shaderMountRef.current?.setUniforms(uniforms);
        }
      };
      updateUniforms();
      return () => {
        isStale = true;
      };
    }, [uniformsProp, isInitialized]);
    useEffect(() => {
      shaderMountRef.current?.setSpeed(speed);
    }, [speed, isInitialized]);
    useEffect(() => {
      shaderMountRef.current?.setMaxPixelCount(maxPixelCount);
    }, [maxPixelCount, isInitialized]);
    useEffect(() => {
      shaderMountRef.current?.setMinPixelRatio(minPixelRatio);
    }, [minPixelRatio, isInitialized]);
    useEffect(() => {
      shaderMountRef.current?.setFrame(frame);
    }, [frame, isInitialized]);
    const mergedRef = useMergeRefs([divRef, forwardedRef]);
    return /* @__PURE__ */ jsx(
      "div",
      {
        ref: mergedRef,
        style: width !== void 0 || height !== void 0 ? {
          width: typeof width === "string" && isNaN(+width) === false ? +width : width,
          height: typeof height === "string" && isNaN(+height) === false ? +height : height,
          ...style
        } : style,
        ...divProps
      }
    );
  }
);
ShaderMount.displayName = "ShaderMount";
export {
  ShaderMount
};
//# sourceMappingURL=shader-mount.js.map
